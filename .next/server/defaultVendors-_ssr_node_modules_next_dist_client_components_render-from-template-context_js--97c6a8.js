/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "defaultVendors-_ssr_node_modules_next_dist_client_components_render-from-template-context_js--97c6a8";
exports.ids = ["defaultVendors-_ssr_node_modules_next_dist_client_components_render-from-template-context_js--97c6a8"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { createProxy } = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js")

module.exports = createProxy("C:\\Users\\John\\corpinveca-web\\node_modules\\next\\dist\\client\\components\\render-from-template-context.js")


/***/ }),

/***/ "(rsc)/./node_modules/next/dist/client/components/static-generation-bailout.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBRWFBLHFCQUFxQjtlQUFyQkE7O0lBSUdDLHVCQUF1QjtlQUF2QkE7OztBQU5oQixNQUFNQywwQkFBMEI7QUFFekIsTUFBTUYsOEJBQThCRzs7UUFBcEMscUJBQ1dDLElBQUFBLEdBQU9GOztBQUN6QjtBQUVPLFNBQVNELHdCQUNkSSxLQUFjO0lBRWQsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFFLFdBQVVBLEtBQUFBLENBQUksRUFBSTtRQUNyRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtGO0FBQ3hCIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHN0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQgPSAnTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQnXG5cbmV4cG9ydCBjbGFzcyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBjb2RlID0gTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgU3RhdGljR2VuQmFpbG91dEVycm9yIHtcbiAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ29iamVjdCcgfHwgZXJyb3IgPT09IG51bGwgfHwgISgnY29kZScgaW4gZXJyb3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyb3IuY29kZSA9PT0gTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcbn1cbiJdLCJuYW1lcyI6WyJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJpc1N0YXRpY0dlbkJhaWxvdXRFcnJvciIsIk5FWFRfU1RBVElDX0dFTl9CQUlMT1VUIiwiRXJyb3IiLCJjb2RlIiwiZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/client/components/static-generation-bailout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/client/components/unauthorized-error.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/unauthorized-error.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return Unauthorized;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\nconst _errorfallback = __webpack_require__(/*! ./http-access-fallback/error-fallback */ \"(rsc)/./node_modules/next/dist/client/components/http-access-fallback/error-fallback.js\");\nfunction Unauthorized() {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorfallback.HTTPAccessErrorFallback, {\n        status: 401,\n        message: \"You're not authorized to access this page.\"\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unauthorized-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VuYXV0aG9yaXplZC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7OzJDQUVBOzs7ZUFBd0JBOzs7OzJDQUZnQjtBQUV6QixTQUFTQTtJQUN0QixxQkFDRSxxQkFBQ0MsZUFBQUEsdUJBQXVCO1FBQ3RCQyxRQUFRO1FBQ1JDLFNBQVE7O0FBR2QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcdW5hdXRob3JpemVkLWVycm9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIVFRQQWNjZXNzRXJyb3JGYWxsYmFjayB9IGZyb20gJy4vaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItZmFsbGJhY2snXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFVuYXV0aG9yaXplZCgpIHtcbiAgcmV0dXJuIChcbiAgICA8SFRUUEFjY2Vzc0Vycm9yRmFsbGJhY2tcbiAgICAgIHN0YXR1cz17NDAxfVxuICAgICAgbWVzc2FnZT1cIllvdSdyZSBub3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBwYWdlLlwiXG4gICAgLz5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIlVuYXV0aG9yaXplZCIsIkhUVFBBY2Nlc3NFcnJvckZhbGxiYWNrIiwic3RhdHVzIiwibWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/client/components/unauthorized-error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return RenderFromTemplateContext;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(ssr)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js\");\nfunction RenderFromTemplateContext() {\n    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0FLQTs7O2VBQXdCQTs7Ozs7NkVBSG9COzJEQUNaO0FBRWpCLFNBQVNBO0lBQ3RCLE1BQU1DLFdBQVdDLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdDLCtCQUFBQSxlQUFlO0lBQzNDLHFCQUFPO2tCQUFHRjs7QUFDWiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBUZW1wbGF0ZUNvbnRleHQgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCgpOiBKU1guRWxlbWVudCB7XG4gIGNvbnN0IGNoaWxkcmVuID0gdXNlQ29udGV4dChUZW1wbGF0ZUNvbnRleHQpXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0IiwiY2hpbGRyZW4iLCJ1c2VDb250ZXh0IiwiVGVtcGxhdGVDb250ZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/render-from-template-context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addSearchParamsToPageSegments: function() {\n        return addSearchParamsToPageSegments;\n    },\n    handleAliasedPrefetchEntry: function() {\n        return handleAliasedPrefetchEntry;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _approuter = __webpack_require__(/*! ../app-router */ \"(ssr)/./node_modules/next/dist/client/components/app-router.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ./apply-router-state-patch-to-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _fillcachewithnewsubtreedata = __webpack_require__(/*! ./fill-cache-with-new-subtree-data */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\");\nconst _handlemutable = __webpack_require__(/*! ./handle-mutable */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nfunction handleAliasedPrefetchEntry(navigatedAt, state, flightData, url, mutable) {\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    let applied;\n    if (typeof flightData === 'string') {\n        return false;\n    }\n    for (const normalizedFlightData of flightData){\n        // If the segment doesn't have a loading component, we don't need to do anything.\n        if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {\n            continue;\n        }\n        let treePatch = normalizedFlightData.tree;\n        // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n        // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n        // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n        treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));\n        const { seedData, isRootRender, pathToSegment } = normalizedFlightData;\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = [\n            '',\n            ...pathToSegment\n        ];\n        // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n        // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n        // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n        treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));\n        let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n        const newCache = (0, _approuter.createEmptyCacheNode)();\n        // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the\n        // loading state and not the actual parallel route seed data.\n        if (isRootRender && seedData) {\n            // Fill in the cache with the new loading / rsc data\n            const rsc = seedData[1];\n            const loading = seedData[3];\n            newCache.loading = loading;\n            newCache.rsc = rsc;\n            // Construct a new tree and apply the aliased loading state for each parallel route\n            fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, currentCache, treePatch, seedData);\n        } else {\n            // Copy rsc for the root node of the cache.\n            newCache.rsc = currentCache.rsc;\n            newCache.prefetchRsc = currentCache.prefetchRsc;\n            newCache.loading = currentCache.loading;\n            newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n            // copy the loading state only into the leaf node (the part that changed)\n            (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeDataButOnlyLoading)(navigatedAt, newCache, currentCache, normalizedFlightData);\n        }\n        // If we don't have an updated tree, there's no reason to update the cache, as the tree\n        // dictates what cache nodes to render.\n        if (newTree) {\n            currentTree = newTree;\n            currentCache = newCache;\n            applied = true;\n        }\n    }\n    if (!applied) {\n        return false;\n    }\n    mutable.patchedTree = currentTree;\n    mutable.cache = currentCache;\n    mutable.canonicalUrl = href;\n    mutable.hashFragment = url.hash;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction hasLoadingComponentInSeedData(seedData) {\n    if (!seedData) return false;\n    const parallelRoutes = seedData[2];\n    const loading = seedData[3];\n    if (loading) {\n        return true;\n    }\n    for(const key in parallelRoutes){\n        if (hasLoadingComponentInSeedData(parallelRoutes[key])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        return;\n    }\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined ? cacheNodeSeedData[2][key] : null;\n        let newCacheNode;\n        if (parallelSeedData !== null) {\n            // New data was sent from the server.\n            const rsc = parallelSeedData[1];\n            const loading = parallelSeedData[3];\n            newCacheNode = {\n                lazyData: null,\n                // copy the layout but null the page segment as that's not meant to be used\n                rsc: segmentForParallelRoute.includes(_segment.PAGE_SEGMENT_KEY) ? null : rsc,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading,\n                navigatedAt\n            };\n        } else {\n            // No data available for this node. This will trigger a lazy fetch\n            // during render.\n            newCacheNode = {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading: null,\n                navigatedAt: -1\n            };\n        }\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCacheNode, existingCache, parallelRouteState, parallelSeedData);\n    }\n}\nfunction addSearchParamsToPageSegments(flightRouterState, searchParams) {\n    const [segment, parallelRoutes, ...rest] = flightRouterState;\n    // If it's a page segment, modify the segment by adding search params\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY)) {\n        const newSegment = (0, _segment.addSearchParamsIfPageSegment)(segment, searchParams);\n        return [\n            newSegment,\n            parallelRoutes,\n            ...rest\n        ];\n    }\n    // Otherwise, recurse through the parallel routes and return a new tree\n    const updatedParallelRoutes = {};\n    for (const [key, parallelRoute] of Object.entries(parallelRoutes)){\n        updatedParallelRoutes[key] = addSearchParamsToPageSegments(parallelRoute, searchParams);\n    }\n    return [\n        segment,\n        updatedParallelRoutes,\n        ...rest\n    ];\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=aliased-prefetch-navigations.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2FsaWFzZWQtcHJlZmV0Y2gtbmF2aWdhdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBbU9nQkEsNkJBQTZCO2VBQTdCQTs7SUExTUFDLDBCQUEwQjtlQUExQkE7OztxQ0FqQlQ7dUNBRThCO3lEQUNPOytDQUNWO2tEQUNHO3lEQUNxQjsyQ0FDNUI7QUFVdkIsU0FBU0EsMkJBQ2RDLFdBQW1CLEVBQ25CQyxLQUEyQixFQUMzQkMsVUFBMkMsRUFDM0NDLEdBQVEsRUFDUkMsT0FBZ0I7SUFFaEIsSUFBSUMsY0FBY0osTUFBTUssSUFBSTtJQUM1QixJQUFJQyxlQUFlTixNQUFNTyxLQUFLO0lBQzlCLE1BQU1DLE9BQU9DLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JQO0lBQy9CLElBQUlRO0lBRUosSUFBSSxPQUFPVCxlQUFlLFVBQVU7UUFDbEMsT0FBTztJQUNUO0lBRUEsS0FBSyxNQUFNVSx3QkFBd0JWLFdBQVk7UUFDN0MsaUZBQWlGO1FBQ2pGLElBQUksQ0FBQ1csOEJBQThCRCxxQkFBcUJFLFFBQVEsR0FBRztZQUNqRTtRQUNGO1FBRUEsSUFBSUMsWUFBWUgscUJBQXFCTixJQUFJO1FBQ3pDLHVIQUF1SDtRQUN2SCxnSkFBZ0o7UUFDaEosc0hBQXNIO1FBQ3RIUyxZQUFZakIsOEJBQ1ZpQixXQUNBQyxPQUFPQyxXQUFXLENBQUNkLElBQUllLFlBQVk7UUFHckMsTUFBTSxFQUFFSixRQUFRLEVBQUVLLFlBQVksRUFBRUMsYUFBYSxFQUFFLEdBQUdSO1FBQ2xELHNCQUFzQjtRQUN0QixNQUFNUyxvQ0FBb0M7WUFBQztlQUFPRDtTQUFjO1FBRWhFLHVIQUF1SDtRQUN2SCxnSkFBZ0o7UUFDaEosc0hBQXNIO1FBQ3RITCxZQUFZakIsOEJBQ1ZpQixXQUNBQyxPQUFPQyxXQUFXLENBQUNkLElBQUllLFlBQVk7UUFHckMsSUFB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QkFBcUIsQ0FBQzNCLElBQUksR0FBR3hDLDhCQUMzQm9FLGVBQ0FoRDtJQUVKO0lBRUEsT0FBTztRQUFDMkM7UUFBU0k7V0FBMEJIO0tBQUs7QUFDbEQiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXGFsaWFzZWQtcHJlZmV0Y2gtbmF2aWdhdGlvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7XG4gIGFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQsXG4gIFBBR0VfU0VHTUVOVF9LRVksXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZEZsaWdodERhdGEgfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB7IGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YUJ1dE9ubHlMb2FkaW5nIH0gZnJvbSAnLi9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YSdcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHR5cGUgeyBNdXRhYmxlLCBSZWFkb25seVJlZHVjZXJTdGF0ZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5cbi8qKlxuICogVGhpcyBpcyBhIHN0b3AtZ2FwIHVudGlsIHBlci1zZWdtZW50IGNhY2hpbmcgaXMgaW1wbGVtZW50ZWQuIEl0IGxldmVyYWdlcyB0aGUgYGFsaWFzZWRgIGZsYWcgdGhhdCBpcyBhZGRlZFxuICogdG8gcHJlZmV0Y2ggZW50cmllcyB3aGVuIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IHRoZSBsb2FkaW5nIHN0YXRlIGZyb20gdGhhdCBlbnRyeSBzaG91bGQgYmUgdXNlZCBmb3IgdGhpcyBuYXZpZ2F0aW9uLlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgYWxpYXNlZCBlbnRyeSBhbmQgb25seSBhcHBsaWVzIHRoZSBsb2FkaW5nIHN0YXRlIHRvIHRoZSB1cGRhdGVkIGNhY2hlIG5vZGUuXG4gKiBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgb25jZSBwZXItc2VnbWVudCBmZXRjaGluZyBpcyBpbXBsZW1lbnRlZCBhcyBpZGVhbGx5IHRoZSBwcmVmZXRjaCBjYWNoZSB3aWxsIGNvbnRhaW4gYVxuICogbW9yZSBncmFudWxhciBzZWdtZW50IG1hcCBhbmQgc28gdGhlIHJvdXRlciB3aWxsIGJlIGFibGUgdG8gc2ltcGx5IHJlLXVzZSB0aGUgbG9hZGluZyBzZWdtZW50IGZvciB0aGUgbmV3IG5hdmlnYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeShcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBmbGlnaHREYXRhOiBzdHJpbmcgfCBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdLFxuICB1cmw6IFVSTCxcbiAgbXV0YWJsZTogTXV0YWJsZVxuKSB7XG4gIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcbiAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG4gIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpXG4gIGxldCBhcHBsaWVkXG5cbiAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgLy8gSWYgdGhlIHNlZ21lbnQgZG9lc24ndCBoYXZlIGEgbG9hZGluZyBjb21wb25lbnQsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgaWYgKCFoYXNMb2FkaW5nQ29tcG9uZW50SW5TZWVkRGF0YShub3JtYWxpemVkRmxpZ2h0RGF0YS5zZWVkRGF0YSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgbGV0IHRyZWVQYXRjaCA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhLnRyZWVcbiAgICAvLyBTZWdtZW50cyBhcmUga2V5ZWQgYnkgc2VhcmNoUGFyYW1zIChlLmcuIF9fUEFHRV9fP3tcImZvb1wiOlwiYmFyXCJ9KS4gV2UgbWlnaHQgcmV0dXJuIGEgbGVzcyBzcGVjaWZpYywgcGFyYW0tbGVzcyBlbnRyeSxcbiAgICAvLyBzbyB3ZSBlbnN1cmUgdGhhdCB0aGUgZmluYWwgdHJlZSBjb250YWlucyB0aGUgY29ycmVjdCBzZWFyY2hQYXJhbXMgKHJlZmxlY3RlZCBpbiB0aGUgVVJMKSBhcmUgcHJvdmlkZWQgaW4gdGhlIHVwZGF0ZWQgRmxpZ2h0Um91dGVyU3RhdGUgdHJlZS5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgb24gdGhlIGZpcnN0IHJlYWQsIGFzIG90aGVyd2lzZSB3ZSdkIGJlIG92ZXJ3cml0aW5nIHRoZSBzZWFyY2hQYXJhbXMgdGhhdCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0XG4gICAgdHJlZVBhdGNoID0gYWRkU2VhcmNoUGFyYW1zVG9QYWdlU2VnbWVudHMoXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXModXJsLnNlYXJjaFBhcmFtcylcbiAgICApXG5cbiAgICBjb25zdCB7IHNlZWREYXRhLCBpc1Jvb3RSZW5kZXIsIHBhdGhUb1NlZ21lbnQgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSA9IFsnJywgLi4ucGF0aFRvU2VnbWVudF1cblxuICAgIC8vIFNlZ21lbnRzIGFyZSBrZXllZCBieSBzZWFyY2hQYXJhbXMgKGUuZy4gX19QQUdFX18/e1wiZm9vXCI6XCJiYXJcIn0pLiBXZSBtaWdodCByZXR1cm4gYSBsZXNzIHNwZWNpZmljLCBwYXJhbS1sZXNzIGVudHJ5LFxuICAgIC8vIHNvIHdlIGVuc3VyZSB0aGF0IHRoZSBmaW5hbCB0cmVlIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHNlYXJjaFBhcmFtcyAocmVmbGVjdGVkIGluIHRoZSBVUkwpIGFyZSBwcm92aWRlZCBpbiB0aGUgdXBkYXRlZCBGbGlnaHRSb3V0ZXJTdGF0ZSB0cmVlLlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgZmlyc3QgcmVhZCwgYXMgb3RoZXJ3aXNlIHdlJ2QgYmUgb3ZlcndyaXRpbmcgdGhlIHNlYXJjaFBhcmFtcyB0aGF0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBzZXRcbiAgICB0cmVlUGF0Y2ggPSBhZGRTZWFyY2hQYXJhbXNUb1BhZ2VTZWdtZW50cyhcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyh1cmwuc2VhcmNoUGFyYW1zKVxuICAgIClcblxuICAgIGxldCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgY3VycmVudFRyZWUsXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBocmVmXG4gICAgKVxuXG4gICAgY29uc3QgbmV3Q2FjaGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG5cbiAgICAvLyBUaGUgcHJlZmV0Y2ggY2FjaGUgZW50cnkgd2FzIGFsaWFzZWQgLS0gdGhpcyBzaWduYWxzIHRoYXQgd2Ugb25seSBmaWxsIGluIHRoZSBjYWNoZSB3aXRoIHRoZVxuICAgIC8vIGxvYWRpbmcgc3RhdGUgYW5kIG5vdCB0aGUgYWN0dWFsIHBhcmFsbGVsIHJvdXRlIHNlZWQgZGF0YS5cbiAgICBpZiAoaXNSb290UmVuZGVyICYmIHNlZWREYXRhKSB7XG4gICAgICAvLyBGaWxsIGluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgbG9hZGluZyAvIHJzYyBkYXRhXG4gICAgICBjb25zdCByc2MgPSBzZWVkRGF0YVsxXVxuICAgICAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzNdXG4gICAgICBuZXdDYWNoZS5sb2FkaW5nID0gbG9hZGluZ1xuICAgICAgbmV3Q2FjaGUucnNjID0gcnNjXG5cbiAgICAgIC8vIENvbnN0cnVjdCBhIG5ldyB0cmVlIGFuZCBhcHBseSB0aGUgYWxpYXNlZCBsb2FkaW5nIHN0YXRlIGZvciBlYWNoIHBhcmFsbGVsIHJvdXRlXG4gICAgICBmaWxsTmV3VHJlZVdpdGhPbmx5TG9hZGluZ1NlZ21lbnRzKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgbmV3Q2FjaGUsXG4gICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICBzZWVkRGF0YVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICBuZXdDYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjXG4gICAgICBuZXdDYWNoZS5wcmVmZXRjaFJzYyA9IGN1cnJlbnRDYWNoZS5wcmVmZXRjaFJzY1xuICAgICAgbmV3Q2FjaGUubG9hZGluZyA9IGN1cnJlbnRDYWNoZS5sb2FkaW5nXG4gICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoY3VycmVudENhY2hlLnBhcmFsbGVsUm91dGVzKVxuXG4gICAgICAvLyBjb3B5IHRoZSBsb2FkaW5nIHN0YXRlIG9ubHkgaW50byB0aGUgbGVhZiBub2RlICh0aGUgcGFydCB0aGF0IGNoYW5nZWQpXG4gICAgICBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGFCdXRPbmx5TG9hZGluZyhcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgIG5ld0NhY2hlLFxuICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiB1cGRhdGVkIHRyZWUsIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIHVwZGF0ZSB0aGUgY2FjaGUsIGFzIHRoZSB0cmVlXG4gICAgLy8gZGljdGF0ZXMgd2hhdCBjYWNoZSBub2RlcyB0byByZW5kZXIuXG4gICAgaWYgKG5ld1RyZWUpIHtcbiAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgY3VycmVudENhY2hlID0gbmV3Q2FjaGVcbiAgICAgIGFwcGxpZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgaWYgKCFhcHBsaWVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gY3VycmVudFRyZWVcbiAgbXV0YWJsZS5jYWNoZSA9IGN1cnJlbnRDYWNoZVxuICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWZcbiAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSB1cmwuaGFzaFxuXG4gIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxufVxuXG5mdW5jdGlvbiBoYXNMb2FkaW5nQ29tcG9uZW50SW5TZWVkRGF0YShzZWVkRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsKSB7XG4gIGlmICghc2VlZERhdGEpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gc2VlZERhdGFbMl1cbiAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzNdXG5cbiAgaWYgKGxvYWRpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBpZiAoaGFzTG9hZGluZ0NvbXBvbmVudEluU2VlZERhdGEocGFyYWxsZWxSb3V0ZXNba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGZpbGxOZXdUcmVlV2l0aE9ubHlMb2FkaW5nU2VnbWVudHMoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBjYWNoZU5vZGVTZWVkRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsXG4pIHtcbiAgY29uc3QgaXNMYXN0U2VnbWVudCA9IE9iamVjdC5rZXlzKHJvdXRlclN0YXRlWzFdKS5sZW5ndGggPT09IDBcbiAgaWYgKGlzTGFzdFNlZ21lbnQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZVN0YXRlID0gcm91dGVyU3RhdGVbMV1ba2V5XVxuICAgIGNvbnN0IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlID0gcGFyYWxsZWxSb3V0ZVN0YXRlWzBdXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSlcblxuICAgIGNvbnN0IHBhcmFsbGVsU2VlZERhdGEgPVxuICAgICAgY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwgJiYgY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XVxuICAgICAgICA6IG51bGxcblxuICAgIGxldCBuZXdDYWNoZU5vZGU6IENhY2hlTm9kZVxuICAgIGlmIChwYXJhbGxlbFNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAvLyBOZXcgZGF0YSB3YXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICBjb25zdCByc2MgPSBwYXJhbGxlbFNlZWREYXRhWzFdXG4gICAgICBjb25zdCBsb2FkaW5nID0gcGFyYWxsZWxTZWVkRGF0YVszXVxuICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgLy8gY29weSB0aGUgbGF5b3V0IGJ1dCBudWxsIHRoZSBwYWdlIHNlZ21lbnQgYXMgdGhhdCdzIG5vdCBtZWFudCB0byBiZSB1c2VkXG4gICAgICAgIHJzYzogc2VnbWVudEZvclBhcmFsbGVsUm91dGUuaW5jbHVkZXMoUEFHRV9TRUdNRU5UX0tFWSkgPyBudWxsIDogcnNjLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gZGF0YSBhdmFpbGFibGUgZm9yIHRoaXMgbm9kZS4gVGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoXG4gICAgICAvLyBkdXJpbmcgcmVuZGVyLlxuICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpXG4gICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMuc2V0KGNhY2hlS2V5LCBuZXdDYWNoZU5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIG5ldyBNYXAoW1tjYWNoZUtleSwgbmV3Q2FjaGVOb2RlXV0pKVxuICAgIH1cblxuICAgIGZpbGxOZXdUcmVlV2l0aE9ubHlMb2FkaW5nU2VnbWVudHMoXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIG5ld0NhY2hlTm9kZSxcbiAgICAgIGV4aXN0aW5nQ2FjaGUsXG4gICAgICBwYXJhbGxlbFJvdXRlU3RhdGUsXG4gICAgICBwYXJhbGxlbFNlZWREYXRhXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQWRkIHNlYXJjaCBwYXJhbXMgdG8gdGhlIHBhZ2Ugc2VnbWVudHMgaW4gdGhlIGZsaWdodCByb3V0ZXIgc3RhdGVcbiAqIFBhZ2Ugc2VnbWVudHMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHNlYXJjaCBwYXJhbXMgaGF2ZSBhIHBhZ2Ugc2VnbWVudCBrZXlcbiAqIGZvbGxvd2VkIGJ5IGEgcXVlcnkgc3RyaW5nLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIHRob3NlIHBhcmFtcyB0byB0aGUgcGFnZSBzZWdtZW50LlxuICogVGhpcyBpcyB1c2VmdWwgaWYgd2UgcmV0dXJuIGFuIGFsaWFzZWQgcHJlZmV0Y2ggZW50cnkgKGllLCB3b24ndCBoYXZlIHNlYXJjaCBwYXJhbXMpXG4gKiBidXQgdGhlIGNhbm9uaWNhbCByb3V0ZXIgVVJMIGhhcyBzZWFyY2ggcGFyYW1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkU2VhcmNoUGFyYW1zVG9QYWdlU2VnbWVudHMoXG4gIGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgc2VhcmNoUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD5cbik6IEZsaWdodFJvdXRlclN0YXRlIHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAuLi5yZXN0XSA9IGZsaWdodFJvdXRlclN0YXRlXG5cbiAgLy8gSWYgaXQncyBhIHBhZ2Ugc2VnbWVudCwgbW9kaWZ5IHRoZSBzZWdtZW50IGJ5IGFkZGluZyBzZWFyY2ggcGFyYW1zXG4gIGlmIChzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgY29uc3QgbmV3U2VnbWVudCA9IGFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQoc2VnbWVudCwgc2VhcmNoUGFyYW1zKVxuICAgIHJldHVybiBbbmV3U2VnbWVudCwgcGFyYWxsZWxSb3V0ZXMsIC4uLnJlc3RdXG4gIH1cblxuICAvLyBPdGhlcndpc2UsIHJlY3Vyc2UgdGhyb3VnaCB0aGUgcGFyYWxsZWwgcm91dGVzIGFuZCByZXR1cm4gYSBuZXcgdHJlZVxuICBjb25zdCB1cGRhdGVkUGFyYWxsZWxSb3V0ZXM6IHsgW2tleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGUgfSA9IHt9XG5cbiAgZm9yIChjb25zdCBba2V5LCBwYXJhbGxlbFJvdXRlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbGxlbFJvdXRlcykpIHtcbiAgICB1cGRhdGVkUGFyYWxsZWxSb3V0ZXNba2V5XSA9IGFkZFNlYXJjaFBhcmFtc1RvUGFnZVNlZ21lbnRzKFxuICAgICAgcGFyYWxsZWxSb3V0ZSxcbiAgICAgIHNlYXJjaFBhcmFtc1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBbc2VnbWVudCwgdXBkYXRlZFBhcmFsbGVsUm91dGVzLCAuLi5yZXN0XVxufVxuIl0sIm5hbWVzIjpbImFkZFNlYXJjaFBhcmFtc1RvUGFnZVNlZ21lbnRzIiwiaGFuZGxlQWxpYXNlZFByZWZldGNoRW50cnkiLCJuYXZpZ2F0ZWRBdCIsInN0YXRlIiwiZmxpZ2h0RGF0YSIsInVybCIsIm11dGFibGUiLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImFwcGxpZWQiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsImhhc0xvYWRpbmdDb21wb25lbnRJblNlZWREYXRhIiwic2VlZERhdGEiLCJ0cmVlUGF0Y2giLCJPYmplY3QiLCJmcm9tRW50cmllcyIsInNlYXJjaFBhcmFtcyIsImlzUm9vdFJlbmRlciIsInBhdGhUb1NlZ21lbnQiLCJmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkiLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwibmV3Q2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsInJzYyIsImxvYWRpbmciLCJmaWxsTmV3VHJlZVdpdGhPbmx5TG9hZGluZ1NlZ21lbnRzIiwicHJlZmV0Y2hSc2MiLCJwYXJhbGxlbFJvdXRlcyIsIk1hcCIsImZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YUJ1dE9ubHlMb2FkaW5nIiwicGF0Y2hlZFRyZWUiLCJjYW5vbmljYWxVcmwiLCJoYXNoRnJhZ21lbnQiLCJoYXNoIiwiaGFuZGxlTXV0YWJsZSIsImtleSIsImV4aXN0aW5nQ2FjaGUiLCJyb3V0ZXJTdGF0ZSIsImNhY2hlTm9kZVNlZWREYXRhIiwiaXNMYXN0U2VnbWVudCIsImtleXMiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlU3RhdGUiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJwYXJhbGxlbFNlZWREYXRhIiwidW5kZWZpbmVkIiwibmV3Q2FjaGVOb2RlIiwibGF6eURhdGEiLCJpbmNsdWRlcyIsIlBBR0VfU0VHTUVOVF9LRVkiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyIsImdldCIsInNldCIsImZsaWdodFJvdXRlclN0YXRlIiwic2VnbWVudCIsInJlc3QiLCJuZXdTZWdtZW50IiwiYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCIsInVwZGF0ZWRQYXJhbGxlbFJvdXRlcyIsInBhcmFsbGVsUm91dGUiLCJlbnRyaWVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"applyFlightData\", ({\n    enumerable: true,\n    get: function() {\n        return applyFlightData;\n    }\n}));\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _fillcachewithnewsubtreedata = __webpack_require__(/*! ./fill-cache-with-new-subtree-data */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\");\nfunction applyFlightData(navigatedAt, existingCache, cache, flightData, prefetchEntry) {\n    // The one before last item is the router state tree patch\n    const { tree: treePatch, seedData, head, isRootRender } = flightData;\n    // Handles case where prefetch only returns the router tree patch without rendered components.\n    if (seedData === null) {\n        return false;\n    }\n    if (isRootRender) {\n        const rsc = seedData[1];\n        const loading = seedData[3];\n        cache.loading = loading;\n        cache.rsc = rsc;\n        // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n        // this path during a navigation, but until PPR is fully implemented\n        // yet it's possible the existing node does have a non-null\n        // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n        // old behavior â€” no PPR value.\n        cache.prefetchRsc = null;\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, existingCache, treePatch, seedData, head, prefetchEntry);\n    } else {\n        // Copy rsc for the root node of the cache.\n        cache.rsc = existingCache.rsc;\n        // This is a PPR-only field. Unlike the previous branch, since we're\n        // just cloning the existing cache node, we might as well keep the\n        // PPR value, if it exists.\n        cache.prefetchRsc = existingCache.prefetchRsc;\n        cache.parallelRoutes = new Map(existingCache.parallelRoutes);\n        cache.loading = existingCache.loading;\n        // Create a copy of the existing cache with the rsc applied.\n        (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(navigatedAt, cache, existingCache, flightData, prefetchEntry);\n    }\n    return true;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-flight-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2FwcGx5LWZsaWdodC1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBTWdCQTs7O2VBQUFBOzs7MkRBTDhCO3lEQUNGO0FBSXJDLFNBQVNBLGdCQUNkQyxXQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLEtBQWdCLEVBQ2hCQyxVQUFnQyxFQUNoQ0MsYUFBa0M7SUFFbEMsMERBQTBEO0lBQzFELE1BQU0sRUFBRUMsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsWUFBWSxFQUFFLEdBQUdOO0lBRTFELDhGQUE4RjtJQUM5RixJQUFJSSxhQUFhLE1BQU07UUFDckIsT0FBTztJQUNUO0lBRUEsSUFBSUUsY0FBYztRQUNoQixNQUFNQyxNQUFNSCxRQUFRLENBQUMsRUFBRTtRQUN2QixNQUFNSSxVQUFVSixRQUFRLENBQUMsRUFBRTtRQUMzQkwsTUFBTVMsT0FBTyxHQUFHQTtRQUNoQlQsTUFBTVEsR0FBRyxHQUFHQTtRQUNaLGtFQUFrRTtRQUNsRSxvRUFBb0U7UUFDcEUsMkRBQTJEO1FBQzNELGtFQUFrRTtRQUNsRSwrQkFBK0I7UUFDL0JSLE1BQU1VLFdBQVcsR0FBRztRQUNwQkMsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUFBQSxFQUNFYixhQUNBRSxPQUNBRCxlQUNBSyxXQUNBQyxVQUNBQyxNQUNBSjtJQUVKLE9BQU87UUFDTCwyQ0FBMkM7UUFDM0NGLE1BQU1RLEdBQUcsR0FBR1QsY0FBY1MsR0FBRztRQUM3QixvRUFBb0U7UUFDcEUsa0VBQWtFO1FBQ2xFLDJCQUEyQjtRQUMzQlIsTUFBTVUsV0FBVyxHQUFHWCxjQUFjVyxXQUFXO1FBQzdDVixNQUFNWSxjQUFjLEdBQUcsSUFBSUMsSUFBSWQsY0FBY2EsY0FBYztRQUMzRFosTUFBTVMsT0FBTyxHQUFHVixjQUFjVSxPQUFPO1FBQ3JDLDREQUE0RDtRQUM1REssQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUNFaEIsYUFDQUUsT0FDQUQsZUFDQUUsWUFDQUM7SUFFSjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcYXBwbHktZmxpZ2h0LWRhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZCdcbmltcG9ydCB7IGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSB9IGZyb20gJy4vZmlsbC1jYWNoZS13aXRoLW5ldy1zdWJ0cmVlLWRhdGEnXG5pbXBvcnQgdHlwZSB7IFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgdHlwZSB7IE5vcm1hbGl6ZWRGbGlnaHREYXRhIH0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RmxpZ2h0RGF0YShcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICBjYWNoZTogQ2FjaGVOb2RlLFxuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbiAgcHJlZmV0Y2hFbnRyeT86IFByZWZldGNoQ2FjaGVFbnRyeVxuKTogYm9vbGVhbiB7XG4gIC8vIFRoZSBvbmUgYmVmb3JlIGxhc3QgaXRlbSBpcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgcGF0Y2hcbiAgY29uc3QgeyB0cmVlOiB0cmVlUGF0Y2gsIHNlZWREYXRhLCBoZWFkLCBpc1Jvb3RSZW5kZXIgfSA9IGZsaWdodERhdGFcblxuICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgcHJlZmV0Y2ggb25seSByZXR1cm5zIHRoZSByb3V0ZXIgdHJlZSBwYXRjaCB3aXRob3V0IHJlbmRlcmVkIGNvbXBvbmVudHMuXG4gIGlmIChzZWVkRGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGlzUm9vdFJlbmRlcikge1xuICAgIGNvbnN0IHJzYyA9IHNlZWREYXRhWzFdXG4gICAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzNdXG4gICAgY2FjaGUubG9hZGluZyA9IGxvYWRpbmdcbiAgICBjYWNoZS5yc2MgPSByc2NcbiAgICAvLyBUaGlzIGlzIGEgUFBSLW9ubHkgZmllbGQuIFdoZW4gUFBSIGlzIGVuYWJsZWQsIHdlIHNob3VsZG4ndCBoaXRcbiAgICAvLyB0aGlzIHBhdGggZHVyaW5nIGEgbmF2aWdhdGlvbiwgYnV0IHVudGlsIFBQUiBpcyBmdWxseSBpbXBsZW1lbnRlZFxuICAgIC8vIHlldCBpdCdzIHBvc3NpYmxlIHRoZSBleGlzdGluZyBub2RlIGRvZXMgaGF2ZSBhIG5vbi1udWxsXG4gICAgLy8gYHByZWZldGNoUnNjYC4gQXMgYW4gaW5jcmVtZW50YWwgc3RlcCwgd2UnbGwganVzdCBkZS1vcHQgdG8gdGhlXG4gICAgLy8gb2xkIGJlaGF2aW9yIOKAlCBubyBQUFIgdmFsdWUuXG4gICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBudWxsXG4gICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIGNhY2hlLFxuICAgICAgZXhpc3RpbmdDYWNoZSxcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIHNlZWREYXRhLFxuICAgICAgaGVhZCxcbiAgICAgIHByZWZldGNoRW50cnlcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgLy8gQ29weSByc2MgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgIGNhY2hlLnJzYyA9IGV4aXN0aW5nQ2FjaGUucnNjXG4gICAgLy8gVGhpcyBpcyBhIFBQUi1vbmx5IGZpZWxkLiBVbmxpa2UgdGhlIHByZXZpb3VzIGJyYW5jaCwgc2luY2Ugd2UncmVcbiAgICAvLyBqdXN0IGNsb25pbmcgdGhlIGV4aXN0aW5nIGNhY2hlIG5vZGUsIHdlIG1pZ2h0IGFzIHdlbGwga2VlcCB0aGVcbiAgICAvLyBQUFIgdmFsdWUsIGlmIGl0IGV4aXN0cy5cbiAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IGV4aXN0aW5nQ2FjaGUucHJlZmV0Y2hSc2NcbiAgICBjYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcylcbiAgICBjYWNoZS5sb2FkaW5nID0gZXhpc3RpbmdDYWNoZS5sb2FkaW5nXG4gICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZXhpc3RpbmcgY2FjaGUgd2l0aCB0aGUgcnNjIGFwcGxpZWQuXG4gICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICBjYWNoZSxcbiAgICAgIGV4aXN0aW5nQ2FjaGUsXG4gICAgICBmbGlnaHREYXRhLFxuICAgICAgcHJlZmV0Y2hFbnRyeVxuICAgIClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOlsiYXBwbHlGbGlnaHREYXRhIiwibmF2aWdhdGVkQXQiLCJleGlzdGluZ0NhY2hlIiwiY2FjaGUiLCJmbGlnaHREYXRhIiwicHJlZmV0Y2hFbnRyeSIsInRyZWUiLCJ0cmVlUGF0Y2giLCJzZWVkRGF0YSIsImhlYWQiLCJpc1Jvb3RSZW5kZXIiLCJyc2MiLCJsb2FkaW5nIiwicHJlZmV0Y2hSc2MiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"applyRouterStatePatchToTree\", ({\n    enumerable: true,\n    get: function() {\n        return applyRouterStatePatchToTree;\n    }\n}));\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(ssr)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(ssr)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */ function applyPatch(initialTree, patchTree) {\n    const [initialSegment, initialParallelRoutes] = initialTree;\n    const [patchSegment, patchParallelRoutes] = patchTree;\n    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n    // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n    if (patchSegment === _segment.DEFAULT_SEGMENT_KEY && initialSegment !== _segment.DEFAULT_SEGMENT_KEY) {\n        return initialTree;\n    }\n    if ((0, _matchsegments.matchSegment)(initialSegment, patchSegment)) {\n        const newParallelRoutes = {};\n        for(const key in initialParallelRoutes){\n            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== 'undefined';\n            if (isInPatchTreeParallelRoutes) {\n                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key]);\n            } else {\n                newParallelRoutes[key] = initialParallelRoutes[key];\n            }\n        }\n        for(const key in patchParallelRoutes){\n            if (newParallelRoutes[key]) {\n                continue;\n            }\n            newParallelRoutes[key] = patchParallelRoutes[key];\n        }\n        const tree = [\n            initialSegment,\n            newParallelRoutes\n        ];\n        // Copy over the existing tree\n        if (initialTree[2]) {\n            tree[2] = initialTree[2];\n        }\n        if (initialTree[3]) {\n            tree[3] = initialTree[3];\n        }\n        if (initialTree[4]) {\n            tree[4] = initialTree[4];\n        }\n        return tree;\n    }\n    return patchTree;\n}\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {\n    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = applyPatch(flightRouterState, treePatch);\n        (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch);\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey], treePatch, path);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        {\n            ...parallelRoutes,\n            [parallelRouteKey]: parallelRoutePatch\n        },\n        url,\n        refetch\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n    return tree;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0RBNkVnQkE7OztlQUFBQTs7O3FDQXpFb0I7K0NBQ0s7MkNBQ1o7NkRBQzRCO0FBRXpEOztDQUVDLEdBQ0QsU0FBU0MsV0FDUEMsV0FBOEIsRUFDOUJDLFNBQTRCO0lBRTVCLE1BQU0sQ0FBQ0MsZ0JBQWdCQyxzQkFBc0IsR0FBR0g7SUFDaEQsTUFBTSxDQUFDSSxjQUFjQyxvQkFBb0IsR0FBR0o7SUFFNUMsa0dBQWtHO0lBQ2xHLGlGQUFpRjtJQUNqRixJQUNFRyxpQkFBaUJFLFNBQUFBLG1CQUFtQixJQUNwQ0osbUJBQW1CSSxTQUFBQSxtQkFBbUIsRUFDdEM7UUFDQSxPQUFPTjtJQUNUO0lBRUEsSUFBSU8sQ0FBQUEsR0FBQUEsZUFBQUEsWUFBQUEsRUFBYUwsZ0JBQWdCRSxlQUFlO1FBQzlDLE1BQU1JLG9CQUEwQyxDQUFDO1FBQ2pELElBQUssTUFBTUMsT0FBT04sc0JBQXVCO1lBQ3ZDLE1BQU1PLDhCQUNKLE9BQU9MLG1CQUFtQixDQUFDSSxJQUFJLEtBQUs7WUFDdEMsSUFBSUMsNkJBQTZCO2dCQUMvQkYsaUJBQWlCLENBQUNDLElBQUksR0FBR1YsV0FDdkJJLHFCQUFxQixDQUFDTSxJQUFJLEVBQzFCSixtQkFBbUIsQ0FBQ0ksSUFBSTtZQUU1QixPQUFPO2dCQUNMRCxpQkFBaUIsQ0FBQ0MsSUFBSSxHQUFHTixxQkFBcUIsQ0FBQ00sSUFBSTtZQUNyRDtRQUNGO1FBRUEsSUFBSyxNQUFNQSxPQUFPSixvQkFBcUI7WUFDckMsSUFBSUcsaUJBQWlCLENBQUNDLElBQUksRUFBRTtnQkFDMUI7WUFDRjtZQUVBRCxpQkFBaUIsQ0FBQ0MsSUFBSSxHQUFHSixtQkFBbUIsQ0FBQ0ksSUFBSTtRQUNuRDtRQUVBLE1BQU1FLE9BQTBCO1lBQUNUO1lBQWdCTTtTQUFrQjtRQUVuRSw4QkFBOEI7UUFDOUIsSUFBSVIsV0FBVyxDQUFDLEVBQUUsRUFBRTtZQUNsQlcsSUFBSSxDQUFDLEVBQUUsR0FBR1gsV0FBVyxDQUFDLEVBQUU7UUFDMUI7UUFFQSxJQUFJQSxXQUFXLENBQUMsRUFBRSxFQUFFO1lBQ2xCVyxJQUFJLENBQUMsRUFBRSxHQUFHWCxXQUFXLENBQUMsRUFBRTtRQUMxQjtRQUVBLElBQUlBLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDbEJXLElBQUksQ0FBQyxFQUFFLEdBQUdYLFdBQVcsQ0FBQyxFQUFFO1FBQzFCO1FBRUEsT0FBT1c7SUFDVDtJQUVBLE9BQU9WO0FBQ1Q7QUFPTyxTQUFTSCw0QkFDZGMsaUJBQW9DLEVBQ3BDQyxpQkFBb0MsRUFDcENDLFNBQTRCLEVBQzVCQyxJQUFZO0lBRVosTUFBTSxDQUFDQyxTQUFTQyxnQkFBZ0JDLEtBQUtDLFNBQVNDLGFBQWEsR0FDekRQO0lBRUYsZUFBZTtJQUNmLElBQUlELGtCQUFrQlMsTUFBTSxLQUFLLEdBQUc7UUFDbEMsTUFBTVYsT0FBMEJaLFdBQVdjLG1CQUFtQkM7UUFFOURRLENBQUFBLEdBQUFBLGlDQUFBQSx3Q0FBQUEsRUFBeUNYLE1BQU1JO1FBRS9DLE9BQU9KO0lBQ1Q7SUFFQSxNQUFNLENBQUNZLGdCQUFnQkMsaUJBQWlCLEdBQUdaO0lBRTNDLGlHQUFpRztJQUNqRyxJQUFJLENBQUNMLENBQUFBLEdBQUFBLGVBQUFBLFlBQUFBLEVBQWFnQixnQkFBZ0JQLFVBQVU7UUFDMUMsT0FBTztJQUNUO0lBRUEsTUFBTVMsY0FBY2Isa0JBQWtCUyxNQUFNLEtBQUs7SUFFakQsSUFBSUs7SUFDSixJQUFJRCxhQUFhO1FBQ2ZDLHFCQUFxQjNCLFdBQVdrQixjQUFjLENBQUNPLGlCQUFpQixFQUFFVjtJQUNwRSxPQUFPO1FBQ0xZLHFCQUFxQjVCLDRCQUNuQjZCLENBQUFBLEdBQUFBLG1CQUFBQSx3QkFBQUEsRUFBeUJmLG9CQUN6QkssY0FBYyxDQUFDTyxpQkFBaUIsRUFDaENWLFdBQ0FDO1FBR0YsSUFBSVcsdUJBQXVCLE1BQU07WUFDL0IsT0FBTztRQUNUO0lBQ0Y7SUFFQSxNQUFNZixPQUEwQjtRQUM5QkMsaUJBQWlCLENBQUMsRUFBRTtRQUNwQjtZQUNFLEdBQUdLLGNBQWM7WUFDakIsQ0FBQ08saUJBQWlCLEVBQUVFO1FBQ3RCO1FBQ0FSO1FBQ0FDO0tBQ0Q7SUFFRCxxQ0FBcUM7SUFDckMsSUFBSUMsY0FBYztRQUNoQlQsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNaO0lBRUFXLENBQUFBLEdBQUFBLGlDQUFBQSx3Q0FBQUEsRUFBeUNYLE1BQU1JO0lBRS9DLE9BQU9KO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXGFwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEZsaWdodFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi4vbWF0Y2gtc2VnbWVudHMnXG5pbXBvcnQgeyBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIH0gZnJvbSAnLi9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzJ1xuXG4vKipcbiAqIERlZXAgbWVyZ2Ugb2YgdGhlIHR3byByb3V0ZXIgc3RhdGVzLiBQYXJhbGxlbCByb3V0ZSBrZXlzIGFyZSBwcmVzZXJ2ZWQgaWYgdGhlIHBhdGNoIGRvZXNuJ3QgaGF2ZSB0aGVtLlxuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoKFxuICBpbml0aWFsVHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHBhdGNoVHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IEZsaWdodFJvdXRlclN0YXRlIHtcbiAgY29uc3QgW2luaXRpYWxTZWdtZW50LCBpbml0aWFsUGFyYWxsZWxSb3V0ZXNdID0gaW5pdGlhbFRyZWVcbiAgY29uc3QgW3BhdGNoU2VnbWVudCwgcGF0Y2hQYXJhbGxlbFJvdXRlc10gPSBwYXRjaFRyZWVcblxuICAvLyBpZiB0aGUgYXBwbGllZCBwYXRjaCBzZWdtZW50IGlzIF9fREVGQVVMVF9fIHRoZW4gaXQgY2FuIGJlIGlnbm9yZWQgaW4gZmF2b3Igb2YgdGhlIGluaXRpYWwgdHJlZVxuICAvLyB0aGlzIGlzIGJlY2F1c2UgdGhlIF9fREVGQVVMVF9fIHNlZ21lbnQgaXMgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIG9uIG5hdmlnYXRpb25cbiAgaWYgKFxuICAgIHBhdGNoU2VnbWVudCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSAmJlxuICAgIGluaXRpYWxTZWdtZW50ICE9PSBERUZBVUxUX1NFR01FTlRfS0VZXG4gICkge1xuICAgIHJldHVybiBpbml0aWFsVHJlZVxuICB9XG5cbiAgaWYgKG1hdGNoU2VnbWVudChpbml0aWFsU2VnbWVudCwgcGF0Y2hTZWdtZW50KSkge1xuICAgIGNvbnN0IG5ld1BhcmFsbGVsUm91dGVzOiBGbGlnaHRSb3V0ZXJTdGF0ZVsxXSA9IHt9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5pdGlhbFBhcmFsbGVsUm91dGVzKSB7XG4gICAgICBjb25zdCBpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMgPVxuICAgICAgICB0eXBlb2YgcGF0Y2hQYXJhbGxlbFJvdXRlc1trZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgaWYgKGlzSW5QYXRjaFRyZWVQYXJhbGxlbFJvdXRlcykge1xuICAgICAgICBuZXdQYXJhbGxlbFJvdXRlc1trZXldID0gYXBwbHlQYXRjaChcbiAgICAgICAgICBpbml0aWFsUGFyYWxsZWxSb3V0ZXNba2V5XSxcbiAgICAgICAgICBwYXRjaFBhcmFsbGVsUm91dGVzW2tleV1cbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNba2V5XSA9IGluaXRpYWxQYXJhbGxlbFJvdXRlc1trZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2hQYXJhbGxlbFJvdXRlcykge1xuICAgICAgaWYgKG5ld1BhcmFsbGVsUm91dGVzW2tleV0pIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNba2V5XSA9IHBhdGNoUGFyYWxsZWxSb3V0ZXNba2V5XVxuICAgIH1cblxuICAgIGNvbnN0IHRyZWU6IEZsaWdodFJvdXRlclN0YXRlID0gW2luaXRpYWxTZWdtZW50LCBuZXdQYXJhbGxlbFJvdXRlc11cblxuICAgIC8vIENvcHkgb3ZlciB0aGUgZXhpc3RpbmcgdHJlZVxuICAgIGlmIChpbml0aWFsVHJlZVsyXSkge1xuICAgICAgdHJlZVsyXSA9IGluaXRpYWxUcmVlWzJdXG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxUcmVlWzNdKSB7XG4gICAgICB0cmVlWzNdID0gaW5pdGlhbFRyZWVbM11cbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbFRyZWVbNF0pIHtcbiAgICAgIHRyZWVbNF0gPSBpbml0aWFsVHJlZVs0XVxuICAgIH1cblxuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICByZXR1cm4gcGF0Y2hUcmVlXG59XG5cbi8qKlxuICogQXBwbHkgdGhlIHJvdXRlciBzdGF0ZSBmcm9tIHRoZSBGbGlnaHQgcmVzcG9uc2UsIGJ1dCBza2lwIHBhdGNoaW5nIGRlZmF1bHQgc2VnbWVudHMuXG4gKiBVc2VmdWwgZm9yIHBhdGNoaW5nIHRoZSByb3V0ZXIgY2FjaGUgd2hlbiBuYXZpZ2F0aW5nLCB3aGVyZSB3ZSBwZXJzaXN0IHRoZSBleGlzdGluZyBkZWZhdWx0IHNlZ21lbnQgaWYgdGhlcmUgaXNuJ3QgYSBuZXcgb25lLlxuICogQ3JlYXRlcyBhIG5ldyByb3V0ZXIgc3RhdGUgdHJlZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHRyZWVQYXRjaDogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHBhdGg6IHN0cmluZ1xuKTogRmxpZ2h0Um91dGVyU3RhdGUgfCBudWxsIHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCB1cmwsIHJlZmV0Y2gsIGlzUm9vdExheW91dF0gPVxuICAgIGZsaWdodFJvdXRlclN0YXRlXG5cbiAgLy8gUm9vdCByZWZyZXNoXG4gIGlmIChmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IGFwcGx5UGF0Y2goZmxpZ2h0Um91dGVyU3RhdGUsIHRyZWVQYXRjaClcblxuICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHModHJlZSwgcGF0aClcblxuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICBjb25zdCBbY3VycmVudFNlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gZmxpZ2h0U2VnbWVudFBhdGhcblxuICAvLyBUcmVlIHBhdGggcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIHNob3VsZCBhbHdheXMgbWF0Y2ggdXAgd2l0aCB0aGUgY3VycmVudCB0cmVlIGluIHRoZSBicm93c2VyXG4gIGlmICghbWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA9PT0gMlxuXG4gIGxldCBwYXJhbGxlbFJvdXRlUGF0Y2hcbiAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gYXBwbHlQYXRjaChwYXJhbGxlbFJvdXRlc1twYXJhbGxlbFJvdXRlS2V5XSwgdHJlZVBhdGNoKVxuICB9IGVsc2Uge1xuICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgIGdldE5leHRGbGlnaHRTZWdtZW50UGF0aChmbGlnaHRTZWdtZW50UGF0aCksXG4gICAgICBwYXJhbGxlbFJvdXRlc1twYXJhbGxlbFJvdXRlS2V5XSxcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIHBhdGhcbiAgICApXG5cbiAgICBpZiAocGFyYWxsZWxSb3V0ZVBhdGNoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRyZWU6IEZsaWdodFJvdXRlclN0YXRlID0gW1xuICAgIGZsaWdodFNlZ21lbnRQYXRoWzBdLFxuICAgIHtcbiAgICAgIC4uLnBhcmFsbGVsUm91dGVzLFxuICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiBwYXJhbGxlbFJvdXRlUGF0Y2gsXG4gICAgfSxcbiAgICB1cmwsXG4gICAgcmVmZXRjaCxcbiAgXVxuXG4gIC8vIEN1cnJlbnQgc2VnbWVudCBpcyB0aGUgcm9vdCBsYXlvdXRcbiAgaWYgKGlzUm9vdExheW91dCkge1xuICAgIHRyZWVbNF0gPSB0cnVlXG4gIH1cblxuICBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHRyZWUsIHBhdGgpXG5cbiAgcmV0dXJuIHRyZWVcbn1cbiJdLCJuYW1lcyI6WyJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJhcHBseVBhdGNoIiwiaW5pdGlhbFRyZWUiLCJwYXRjaFRyZWUiLCJpbml0aWFsU2VnbWVudCIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsInBhdGNoU2VnbWVudCIsInBhdGNoUGFyYWxsZWxSb3V0ZXMiLCJERUZBVUxUX1NFR01FTlRfS0VZIiwibWF0Y2hTZWdtZW50IiwibmV3UGFyYWxsZWxSb3V0ZXMiLCJrZXkiLCJpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMiLCJ0cmVlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInRyZWVQYXRjaCIsInBhdGgiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJ1cmwiLCJyZWZldGNoIiwiaXNSb290TGF5b3V0IiwibGVuZ3RoIiwiYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsImN1cnJlbnRTZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsImxhc3RTZWdtZW50IiwicGFyYWxsZWxSb3V0ZVBhdGNoIiwiZ2V0TmV4dEZsaWdodFNlZ21lbnRQYXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js ***!
  \***********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"clearCacheNodeDataForSegmentPath\", ({\n    enumerable: true,\n    get: function() {\n        return clearCacheNodeDataForSegmentPath;\n    }\n}));\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(ssr)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction clearCacheNodeDataForSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap == null ? void 0 : existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading: null,\n                navigatedAt: -1\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading: null,\n                navigatedAt: -1\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes),\n            loading: childCacheNode.loading\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    return clearCacheNodeDataForSegmentPath(childCacheNode, existingChildCacheNode, (0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=clear-cache-node-data-for-segment-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NsZWFyLWNhY2hlLW5vZGUtZGF0YS1mb3Itc2VnbWVudC1wYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7b0VBUWdCQTs7O2VBQUFBOzs7K0NBTnlCO2tEQUNKO0FBSzlCLFNBQVNBLGlDQUNkQyxRQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLGlCQUFvQztJQUVwQyxNQUFNQyxjQUFjRCxrQkFBa0JFLE1BQU0sSUFBSTtJQUVoRCxNQUFNLENBQUNDLGtCQUFrQkMsUUFBUSxHQUFHSjtJQUNwQyxNQUFNSyxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQUFBLEVBQXFCRjtJQUV0QyxNQUFNRywwQkFDSlIsY0FBY1MsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBRW5DLElBQUlPLGtCQUFrQlosU0FBU1UsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBRWxELElBQUksQ0FBQ08sbUJBQW1CQSxvQkFBb0JILHlCQUF5QjtRQUNuRUcsa0JBQWtCLElBQUlDLElBQUlKO1FBQzFCVCxTQUFTVSxjQUFjLENBQUNJLEdBQUcsQ0FBQ1Qsa0JBQWtCTztJQUNoRDtJQUVBLE1BQU1HLHlCQUF5Qk4sMkJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHdCQUF5QkUsR0FBRyxDQUFDSjtJQUM1RCxJQUFJUyxpQkFBaUJKLGdCQUFnQkQsR0FBRyxDQUFDSjtJQUV6Qyx5RkFBeUY7SUFDekYsSUFBSUosYUFBYTtRQUNmLElBQ0UsQ0FBQ2Esa0JBQ0QsQ0FBQ0EsZUFBZUMsUUFBUSxJQUN4QkQsbUJBQW1CRCx3QkFDbkI7WUFDQUgsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVU7Z0JBQzVCVSxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxhQUFhO2dCQUNiQyxNQUFNO2dCQUNOQyxjQUFjO2dCQUNkWCxnQkFBZ0IsSUFBSUc7Z0JBQ3BCUyxTQUFTO2dCQUNUQyxhQUFhLENBQUM7WUFDaEI7UUFDRjtRQUNBO0lBQ0Y7SUFFQSxJQUFJLENBQUNQLGtCQUFrQixDQUFDRCx3QkFBd0I7UUFDOUMsK0VBQStFO1FBQy9FLElBQUksQ0FBQ0MsZ0JBQWdCO1lBQ25CSixnQkFBZ0JFLEdBQUcsQ0FBQ1AsVUFBVTtnQkFDNUJVLFVBQVU7Z0JBQ1ZDLEtBQUs7Z0JBQ0xDLGFBQWE7Z0JBQ2JDLE1BQU07Z0JBQ05DLGNBQWM7Z0JBQ2RYLGdCQUFnQixJQUFJRztnQkFDcEJTLFNBQVM7Z0JBQ1RDLGFBQWEsQ0FBQztZQUNoQjtRQUNGO1FBQ0E7SUFDRjtJQUVBLElBQUlQLG1CQUFtQkQsd0JBQXdCO1FBQzdDQyxpQkFBaUI7WUFDZkMsVUFBVUQsZUFBZUMsUUFBUTtZQUNqQ0MsS0FBS0YsZUFBZUUsR0FBRztZQUN2QkMsYUFBYUgsZUFBZUcsV0FBVztZQUN2Q0MsTUFBTUosZUFBZUksSUFBSTtZQUN6QkMsY0FBY0wsZUFBZUssWUFBWTtZQUN6Q1gsZ0JBQWdCLElBQUlHLElBQUlHLGVBQWVOLGNBQWM7WUFDckRZLFNBQVNOLGVBQWVNLE9BQU87UUFDakM7UUFDQVYsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVVTO0lBQ2hDO0lBRUEsT0FBT2pCLGlDQUNMaUIsZ0JBQ0FELHdCQUNBUyxDQUFBQSxHQUFBQSxtQkFBQUEsd0JBQUFBLEVBQXlCdEI7QUFFN0IiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXGNsZWFyLWNhY2hlLW5vZGUtZGF0YS1mb3Itc2VnbWVudC1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuXG4vKipcbiAqIFRoaXMgd2lsbCBjbGVhciB0aGUgQ2FjaGVOb2RlIGRhdGEgZm9yIGEgcGFydGljdWxhciBzZWdtZW50IHBhdGguIFRoaXMgd2lsbCBjYXVzZSBhIGxhenktZmV0Y2ggaW4gbGF5b3V0IHJvdXRlciB0byBmaWxsIGluIG5ldyBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgoXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4pOiB2b2lkIHtcbiAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMlxuXG4gIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodFNlZ21lbnRQYXRoXG4gIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcblxuICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9XG4gICAgZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcblxuICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG5cbiAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApXG4gICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcClcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcD8uZ2V0KGNhY2hlS2V5KVxuICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuXG4gIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IG9mZiB0aGUgZmV0Y2ggYXQgdGhpcyBsZXZlbCBhbmQgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gIGlmIChpc0xhc3RFbnRyeSkge1xuICAgIGlmIChcbiAgICAgICFjaGlsZENhY2hlTm9kZSB8fFxuICAgICAgIWNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhIHx8XG4gICAgICBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZVxuICAgICkge1xuICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAvLyBTdGFydCBmZXRjaCBpbiB0aGUgcGxhY2Ugd2hlcmUgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXNuJ3QgaGF2ZSB0aGUgZGF0YSB5ZXQuXG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSkge1xuICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgbGF6eURhdGE6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICBwcmVmZXRjaFJzYzogY2hpbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICBoZWFkOiBjaGlsZENhY2hlTm9kZS5oZWFkLFxuICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcyksXG4gICAgICBsb2FkaW5nOiBjaGlsZENhY2hlTm9kZS5sb2FkaW5nLFxuICAgIH0gYXMgQ2FjaGVOb2RlXG4gICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpXG4gIH1cblxuICByZXR1cm4gY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgoXG4gICAgY2hpbGRDYWNoZU5vZGUsXG4gICAgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSxcbiAgICBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoZmxpZ2h0U2VnbWVudFBhdGgpXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiaXNMYXN0RW50cnkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJsb2FkaW5nIiwibmF2aWdhdGVkQXQiLCJnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    computeChangedPath: function() {\n        return computeChangedPath;\n    },\n    extractPathFromFlightRouterState: function() {\n        return extractPathFromFlightRouterState;\n    },\n    getSelectedParams: function() {\n        return getSelectedParams;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../shared/lib/router/utils/interception-routes */ \"(ssr)/./node_modules/next/dist/shared/lib/router/utils/interception-routes.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(ssr)/./node_modules/next/dist/client/components/match-segments.js\");\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === '/' ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === 'string') {\n        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n        if (segment === 'children') return '';\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === '' || (0, _segment.isGroupSegment)(segment)) {\n            return acc;\n        }\n        return acc + \"/\" + segment;\n    }, '') || '/';\n}\nfunction extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return '';\n    const segments = [\n        segmentToPathname(segment)\n    ];\n    var _flightRouterState_;\n    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === 'children') continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return '';\n    }\n    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {\n        var _extractPathFromFlightRouterState;\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : '';\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return segmentToPathname(segmentB) + \"/\" + changedPath;\n            }\n        }\n    }\n    return null;\n}\nfunction computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === '/') {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split('/'));\n}\nfunction getSelectedParams(currentTree, params) {\n    if (params === void 0) params = {};\n    const parallelRoutes = currentTree[1];\n    for (const parallelRoute of Object.values(parallelRoutes)){\n        const segment = parallelRoute[0];\n        const isDynamicParameter = Array.isArray(segment);\n        const segmentValue = isDynamicParameter ? segment[1] : segment;\n        if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) continue;\n        // Ensure catchAll and optional catchall are turned into an array\n        const isCatchAll = isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc');\n        if (isCatchAll) {\n            params[segment[0]] = segment[1].split('/');\n        } else if (isDynamicParameter) {\n            params[segment[0]] = segment[1];\n        }\n        params = getSelectedParams(parallelRoute, params);\n    }\n    return params;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=compute-changed-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NvbXB1dGUtY2hhbmdlZC1wYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXdIZ0JBLGtCQUFrQjtlQUFsQkE7O0lBOUVBQyxnQ0FBZ0M7ZUFBaENBOztJQStGQUMsaUJBQWlCO2VBQWpCQTs7O2dEQXJJMkI7cUNBTXBDOzJDQUNzQjtBQUU3QixNQUFNQyxxQkFBcUIsQ0FBQ0M7SUFDMUIsT0FBT0EsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNQSxRQUFRQyxLQUFLLENBQUMsS0FBS0Q7QUFDakQ7QUFFQSxNQUFNRSxvQkFBb0IsQ0FBQ0Y7SUFDekIsSUFBSSxPQUFPQSxZQUFZLFVBQVU7UUFDL0IsdUhBQXVIO1FBQ3ZILGdIQUFnSDtRQUNoSCxJQUFJQSxZQUFZLFlBQVksT0FBTztRQUVuQyxPQUFPQTtJQUNUO0lBRUEsT0FBT0EsT0FBTyxDQUFDLEVBQUU7QUFDbkI7QUFFQSxTQUFTRyxrQkFBa0JDLFFBQWtCO0lBQzNDLE9BQ0VBLFNBQVNDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLTjtRQUNwQkEsVUFBVUQsbUJBQW1CQztRQUM3QixJQUFJQSxZQUFZLE1BQU1PLENBQUFBLEdBQUFBLFNBQUFBLGNBQUFBLEVBQWVQLFVBQVU7WUFDN0MsT0FBT007UUFDVDtRQUVBLE9BQVVBLE1BQUksTUFBR047SUFDbkIsR0FBRyxPQUFPO0FBRWQ7QUFFTyxTQUFTSCxpQ0FDZFcsaUJBQW9DO0lBRXBDLE1BQU1SLFVBQVVTLE1BQU1DLE9BQU8sQ0FBQ0YsaUJBQWlCLENBQUMsRUFBRSxJQUM5Q0EsaUJBQWlCLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FDdkJBLGlCQUFpQixDQUFDLEVBQUU7SUFFeEIsSUFDRVIsWUFBWVcsU0FBQUEsbUJBQW1CLElBQy9CQyxvQkFBQUEsMEJBQTBCLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUFNZCxRQUFRZSxVQUFVLENB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QUc7UUFFakUsSUFBSThDLFlBQVk7WUFDZEwsTUFBTSxDQUFDekMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHQSxPQUFPLENBQUMsRUFBRSxDQUFDdUMsS0FBSyxDQUFDO1FBQ3hDLE9BQU8sSUFBSUssb0JBQW9CO1lBQzdCSCxNQUFNLENBQUN6QyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUdBLE9BQU8sQ0FBQyxFQUFFO1FBQ2pDO1FBRUF5QyxTQUFTM0Msa0JBQWtCNEMsZUFBZUQ7SUFDNUM7SUFFQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxjb21wdXRlLWNoYW5nZWQtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBTZWdtZW50LFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJjZXB0aW9uLXJvdXRlcydcbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuaW1wb3J0IHtcbiAgaXNHcm91cFNlZ21lbnQsXG4gIERFRkFVTFRfU0VHTUVOVF9LRVksXG4gIFBBR0VfU0VHTUVOVF9LRVksXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB7IG1hdGNoU2VnbWVudCB9IGZyb20gJy4uL21hdGNoLXNlZ21lbnRzJ1xuXG5jb25zdCByZW1vdmVMZWFkaW5nU2xhc2ggPSAoc2VnbWVudDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHNlZ21lbnRbMF0gPT09ICcvJyA/IHNlZ21lbnQuc2xpY2UoMSkgOiBzZWdtZW50XG59XG5cbmNvbnN0IHNlZ21lbnRUb1BhdGhuYW1lID0gKHNlZ21lbnQ6IFNlZ21lbnQpOiBzdHJpbmcgPT4ge1xuICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gJ2NoaWxkcmVuJyBpcyBub3QgYSB2YWxpZCBwYXRoIC0tIGl0J3MgdGVjaG5pY2FsbHkgYSBwYXJhbGxlbCByb3V0ZSB0aGF0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGN1cnJlbnQgc2VnbWVudCdzIHBhZ2VcbiAgICAvLyBpZiB3ZSBkb24ndCBza2lwIGl0LCB0aGVuIHRoZSBjb21wdXRlZCBwYXRobmFtZSBtaWdodCBiZSBzb21ldGhpbmcgbGlrZSBgL2NoaWxkcmVuYCB3aGljaCBkb2Vzbid0IG1ha2Ugc2Vuc2UuXG4gICAgaWYgKHNlZ21lbnQgPT09ICdjaGlsZHJlbicpIHJldHVybiAnJ1xuXG4gICAgcmV0dXJuIHNlZ21lbnRcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50WzFdXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnRzKHNlZ21lbnRzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIHJldHVybiAoXG4gICAgc2VnbWVudHMucmVkdWNlKChhY2MsIHNlZ21lbnQpID0+IHtcbiAgICAgIHNlZ21lbnQgPSByZW1vdmVMZWFkaW5nU2xhc2goc2VnbWVudClcbiAgICAgIGlmIChzZWdtZW50ID09PSAnJyB8fCBpc0dyb3VwU2VnbWVudChzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gYWNjXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHthY2N9LyR7c2VnbWVudH1gXG4gICAgfSwgJycpIHx8ICcvJ1xuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZShcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCBzZWdtZW50ID0gQXJyYXkuaXNBcnJheShmbGlnaHRSb3V0ZXJTdGF0ZVswXSlcbiAgICA/IGZsaWdodFJvdXRlclN0YXRlWzBdWzFdXG4gICAgOiBmbGlnaHRSb3V0ZXJTdGF0ZVswXVxuXG4gIGlmIChcbiAgICBzZWdtZW50ID09PSBERUZBVUxUX1NFR01FTlRfS0VZIHx8XG4gICAgSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuc29tZSgobSkgPT4gc2VnbWVudC5zdGFydHNXaXRoKG0pKVxuICApXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuXG4gIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoUEFHRV9TRUdNRU5UX0tFWSkpIHJldHVybiAnJ1xuXG4gIGNvbnN0IHNlZ21lbnRzID0gW3NlZ21lbnRUb1BhdGhuYW1lKHNlZ21lbnQpXVxuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IGZsaWdodFJvdXRlclN0YXRlWzFdID8/IHt9XG5cbiAgY29uc3QgY2hpbGRyZW5QYXRoID0gcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW5cbiAgICA/IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuKVxuICAgIDogdW5kZWZpbmVkXG5cbiAgaWYgKGNoaWxkcmVuUGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VnbWVudHMucHVzaChjaGlsZHJlblBhdGgpXG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYWxsZWxSb3V0ZXMpKSB7XG4gICAgICBpZiAoa2V5ID09PSAnY2hpbGRyZW4nKSBjb250aW51ZVxuXG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSh2YWx1ZSlcblxuICAgICAgaWYgKGNoaWxkUGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goY2hpbGRQYXRoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVTZWdtZW50cyhzZWdtZW50cylcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRQYXRoSW1wbChcbiAgdHJlZUE6IEZsaWdodFJvdXRlclN0YXRlLFxuICB0cmVlQjogRmxpZ2h0Um91dGVyU3RhdGVcbik6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBbc2VnbWVudEEsIHBhcmFsbGVsUm91dGVzQV0gPSB0cmVlQVxuICBjb25zdCBbc2VnbWVudEIsIHBhcmFsbGVsUm91dGVzQl0gPSB0cmVlQlxuXG4gIGNvbnN0IG5vcm1hbGl6ZWRTZWdtZW50QSA9IHNlZ21lbnRUb1BhdGhuYW1lKHNlZ21lbnRBKVxuICBjb25zdCBub3JtYWxpemVkU2VnbWVudEIgPSBzZWdtZW50VG9QYXRobmFtZShzZWdtZW50QilcblxuICBpZiAoXG4gICAgSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuc29tZShcbiAgICAgIChtKSA9PlxuICAgICAgICBub3JtYWxpemVkU2VnbWVudEEuc3RhcnRzV2l0aChtKSB8fCBub3JtYWxpemVkU2VnbWVudEIuc3RhcnRzV2l0aChtKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIW1hdGNoU2VnbWVudChzZWdtZW50QSwgc2VnbWVudEIpKSB7XG4gICAgLy8gb25jZSB3ZSBmaW5kIHdoZXJlIHRoZSB0cmVlIGNoYW5nZWQsIHdlIGNvbXB1dGUgdGhlIHJlc3Qgb2YgdGhlIHBhdGggYnkgdHJhdmVyc2luZyB0aGUgdHJlZVxuICAgIHJldHVybiBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSh0cmVlQikgPz8gJydcbiAgfVxuXG4gIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZXJLZXkgaW4gcGFyYWxsZWxSb3V0ZXNBKSB7XG4gICAgaWYgKHBhcmFsbGVsUm91dGVzQltwYXJhbGxlbFJvdXRlcktleV0pIHtcbiAgICAgIGNvbnN0IGNoYW5nZWRQYXRoID0gY29tcHV0ZUNoYW5nZWRQYXRoSW1wbChcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXNBW3BhcmFsbGVsUm91dGVyS2V5XSxcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXNCW3BhcmFsbGVsUm91dGVyS2V5XVxuICAgICAgKVxuICAgICAgaWYgKGNoYW5nZWRQYXRoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgJHtzZWdtZW50VG9QYXRobmFtZShzZWdtZW50Qil9LyR7Y2hhbmdlZFBhdGh9YFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQ2hhbmdlZFBhdGgoXG4gIHRyZWVBOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgdHJlZUI6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgY2hhbmdlZFBhdGggPSBjb21wdXRlQ2hhbmdlZFBhdGhJbXBsKHRyZWVBLCB0cmVlQilcblxuICBpZiAoY2hhbmdlZFBhdGggPT0gbnVsbCB8fCBjaGFuZ2VkUGF0aCA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIGNoYW5nZWRQYXRoXG4gIH1cblxuICAvLyBsaWdodHdlaWdodCBub3JtYWxpemF0aW9uIHRvIHJlbW92ZSByb3V0ZSBncm91cHNcbiAgcmV0dXJuIG5vcm1hbGl6ZVNlZ21lbnRzKGNoYW5nZWRQYXRoLnNwbGl0KCcvJykpXG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZXh0cmFjdHMgZHluYW1pYyBwYXJhbWV0ZXJzIGZyb20gRmxpZ2h0Um91dGVyU3RhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RlZFBhcmFtcyhcbiAgY3VycmVudFRyZWU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXJhbXM6IFBhcmFtcyA9IHt9XG4pOiBQYXJhbXMge1xuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IGN1cnJlbnRUcmVlWzFdXG5cbiAgZm9yIChjb25zdCBwYXJhbGxlbFJvdXRlIG9mIE9iamVjdC52YWx1ZXMocGFyYWxsZWxSb3V0ZXMpKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHBhcmFsbGVsUm91dGVbMF1cbiAgICBjb25zdCBpc0R5bmFtaWNQYXJhbWV0ZXIgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpXG4gICAgY29uc3Qgc2VnbWVudFZhbHVlID0gaXNEeW5hbWljUGFyYW1ldGVyID8gc2VnbWVudFsxXSA6IHNlZ21lbnRcbiAgICBpZiAoIXNlZ21lbnRWYWx1ZSB8fCBzZWdtZW50VmFsdWUuc3RhcnRzV2l0aChQQUdFX1NFR01FTlRfS0VZKSkgY29udGludWVcblxuICAgIC8vIEVuc3VyZSBjYXRjaEFsbCBhbmQgb3B0aW9uYWwgY2F0Y2hhbGwgYXJlIHR1cm5lZCBpbnRvIGFuIGFycmF5XG4gICAgY29uc3QgaXNDYXRjaEFsbCA9XG4gICAgICBpc0R5bmFtaWNQYXJhbWV0ZXIgJiYgKHNlZ21lbnRbMl0gPT09ICdjJyB8fCBzZWdtZW50WzJdID09PSAnb2MnKVxuXG4gICAgaWYgKGlzQ2F0Y2hBbGwpIHtcbiAgICAgIHBhcmFtc1tzZWdtZW50WzBdXSA9IHNlZ21lbnRbMV0uc3BsaXQoJy8nKVxuICAgIH0gZWxzZSBpZiAoaXNEeW5hbWljUGFyYW1ldGVyKSB7XG4gICAgICBwYXJhbXNbc2VnbWVudFswXV0gPSBzZWdtZW50WzFdXG4gICAgfVxuXG4gICAgcGFyYW1zID0gZ2V0U2VsZWN0ZWRQYXJhbXMocGFyYWxsZWxSb3V0ZSwgcGFyYW1zKVxuICB9XG5cbiAgcmV0dXJuIHBhcmFtc1xufVxuIl0sIm5hbWVzIjpbImNvbXB1dGVDaGFuZ2VkUGF0aCIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiZ2V0U2VsZWN0ZWRQYXJhbXMiLCJyZW1vdmVMZWFkaW5nU2xhc2giLCJzZWdtZW50Iiwic2xpY2UiLCJzZWdtZW50VG9QYXRobmFtZSIsIm5vcm1hbGl6ZVNlZ21lbnRzIiwic2VnbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJpc0dyb3VwU2VnbWVudCIsImZsaWdodFJvdXRlclN0YXRlIiwiQXJyYXkiLCJpc0FycmF5IiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsIklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIiwic29tZSIsIm0iLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiUEFHRV9TRUdNRU5UX0tFWSIsInBhcmFsbGVsUm91dGVzIiwiY2hpbGRyZW5QYXRoIiwiY2hpbGRyZW4iLCJwdXNoIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiY2hpbGRQYXRoIiwiY29tcHV0ZUNoYW5nZWRQYXRoSW1wbCIsInRyZWVBIiwidHJlZUIiLCJzZWdtZW50QSIsInBhcmFsbGVsUm91dGVzQSIsInNlZ21lbnRCIiwicGFyYWxsZWxSb3V0ZXNCIiwibm9ybWFsaXplZFNlZ21lbnRBIiwibm9ybWFsaXplZFNlZ21lbnRCIiwibWF0Y2hTZWdtZW50IiwicGFyYWxsZWxSb3V0ZXJLZXkiLCJjaGFuZ2VkUGF0aCIsInNwbGl0IiwiY3VycmVudFRyZWUiLCJwYXJhbXMiLCJwYXJhbGxlbFJvdXRlIiwidmFsdWVzIiwiaXNEeW5hbWljUGFyYW1ldGVyIiwic2VnbWVudFZhbHVlIiwiaXNDYXRjaEFsbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js ***!
  \*****************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createHrefFromUrl\", ({\n    enumerable: true,\n    get: function() {\n        return createHrefFromUrl;\n    }\n}));\nfunction createHrefFromUrl(url, includeHash) {\n    if (includeHash === void 0) includeHash = true;\n    return url.pathname + url.search + (includeHash ? url.hash : '');\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-href-from-url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7cURBQWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxrQkFDZEMsR0FBOEMsRUFDOUNDLFdBQTJCO0lBQTNCQSxJQUFBQSxnQkFBQUEsS0FBQUEsR0FBQUEsY0FBdUI7SUFFdkIsT0FBT0QsSUFBSUUsUUFBUSxHQUFHRixJQUFJRyxNQUFNLEdBQUlGLENBQUFBLGNBQWNELElBQUlJLElBQUksR0FBRyxHQUFDO0FBQ2hFIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxjcmVhdGUtaHJlZi1mcm9tLXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gY3JlYXRlSHJlZkZyb21VcmwoXG4gIHVybDogUGljazxVUkwsICdwYXRobmFtZScgfCAnc2VhcmNoJyB8ICdoYXNoJz4sXG4gIGluY2x1ZGVIYXNoOiBib29sZWFuID0gdHJ1ZVxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyAoaW5jbHVkZUhhc2ggPyB1cmwuaGFzaCA6ICcnKVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUhyZWZGcm9tVXJsIiwidXJsIiwiaW5jbHVkZUhhc2giLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createRouterCacheKey\", ({\n    enumerable: true,\n    get: function() {\n        return createRouterCacheKey;\n    }\n}));\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\nfunction createRouterCacheKey(segment, withoutSearchParameters) {\n    if (withoutSearchParameters === void 0) withoutSearchParameters = false;\n    // if the segment is an array, it means it's a dynamic segment\n    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n    if (Array.isArray(segment)) {\n        return segment[0] + \"|\" + segment[1] + \"|\" + segment[2];\n    }\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\n    // When `withoutSearchParameters` is true, we only want to return the page segment\n    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-router-cache-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7d0RBR2dCQTs7O2VBQUFBOzs7cUNBRmlCO0FBRTFCLFNBQVNBLHFCQUNkQyxPQUFnQixFQUNoQkMsdUJBQXdDO0lBQXhDQSxJQUFBQSw0QkFBQUEsS0FBQUEsR0FBQUEsMEJBQW1DO0lBRW5DLDhEQUE4RDtJQUM5RCx1R0FBdUc7SUFDdkcsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxVQUFVO1FBQzFCLE9BQVVBLE9BQU8sQ0FBQyxFQUFFLEdBQUMsTUFBR0EsT0FBTyxDQUFDLEVBQUUsR0FBQyxNQUFHQSxPQUFPLENBQUMsRUFBRTtJQUNsRDtJQUVBLGtFQUFrRTtJQUNsRSxrRkFBa0Y7SUFDbEYsSUFBSUMsMkJBQTJCRCxRQUFRSSxVQUFVLENBQUNDLFNBQUFBLGdCQUFnQixHQUFHO1FBQ25FLE9BQU9BLFNBQUFBLGdCQUFnQjtJQUN6QjtJQUVBLE9BQU9MO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXGNyZWF0ZS1yb3V0ZXItY2FjaGUta2V5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VnbWVudCB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlckNhY2hlS2V5KFxuICBzZWdtZW50OiBTZWdtZW50LFxuICB3aXRob3V0U2VhcmNoUGFyYW1ldGVyczogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgLy8gaWYgdGhlIHNlZ21lbnQgaXMgYW4gYXJyYXksIGl0IG1lYW5zIGl0J3MgYSBkeW5hbWljIHNlZ21lbnRcbiAgLy8gZm9yIGV4YW1wbGUsIFsnbGFuZycsICdlbicsICdkJ10uIFdlIG5lZWQgdG8gY29udmVydCBpdCB0byBhIHN0cmluZyB0byBzdG9yZSBpdCBhcyBhIGNhY2hlIG5vZGUga2V5LlxuICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgIHJldHVybiBgJHtzZWdtZW50WzBdfXwke3NlZ21lbnRbMV19fCR7c2VnbWVudFsyXX1gXG4gIH1cblxuICAvLyBQYWdlIHNlZ21lbnRzIG1pZ2h0IGhhdmUgc2VhcmNoIHBhcmFtZXRlcnMsIGllIF9fUEFHRV9fP2Zvbz1iYXJcbiAgLy8gV2hlbiBgd2l0aG91dFNlYXJjaFBhcmFtZXRlcnNgIGlzIHRydWUsIHdlIG9ubHkgd2FudCB0byByZXR1cm4gdGhlIHBhZ2Ugc2VnbWVudFxuICBpZiAod2l0aG91dFNlYXJjaFBhcmFtZXRlcnMgJiYgc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgcmV0dXJuIFBBR0VfU0VHTUVOVF9LRVlcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJzZWdtZW50Iiwid2l0aG91dFNlYXJjaFBhcmFtZXRlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJzdGFydHNXaXRoIiwiUEFHRV9TRUdNRU5UX0tFWSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(ssr)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ \"(ssr)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../app-find-source-map-url */ \"(ssr)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(ssr)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(ssr)/./node_modules/next/dist/client/app-build-id.js\");\nconst _setcachebustingsearchparam = __webpack_require__(/*! ./set-cache-busting-search-param */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\");\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromReadableStream } from 'react-server-dom-webpack/client'\nconst { createFromReadableStream } =  true ? __webpack_require__(/*! react-server-dom-webpack/client.edge */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-webpack-client-edge.js\") : 0;\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction doMpaNavigation(url) {\n    return {\n        flightData: urlToUrlWithoutFlightMarker(url).toString(),\n        canonicalUrl: undefined,\n        couldBeIntercepted: false,\n        prerendered: false,\n        postponed: false,\n        staleTime: -1\n    };\n}\nlet abortController = new AbortController();\nif (false) {}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(flightRouterState))\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if ( true && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        var _res_headers_get;\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        if (false) {}\n        const res = await createFetch(url, headers, fetchPriority, abortController.signal);\n        const responseUrl = urlToUrlWithoutFlightMarker(res.url);\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeader = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeader !== null ? parseInt(staleTimeHeader, 10) : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        if (true) {\n            await (__webpack_require__(/*! ../react-dev-overlay/app/hot-reloader-client */ \"(ssr)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js\").waitForWebpackRuntimeHotUpdate)();\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n        const response = await createFromNextReadableStream(flightStream);\n        if ((0, _appbuildid.getAppBuildId)() !== response.b) {\n            return doMpaNavigation(res.url);\n        }\n        return {\n            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            canonicalUrl: canonicalUrl,\n            couldBeIntercepted: interception,\n            prerendered: response.S,\n            postponed,\n            staleTime\n        };\n    } catch (err) {\n        if (!abortController.signal.aborted) {\n            console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return {\n            flightData: url.toString(),\n            canonicalUrl: undefined,\n            couldBeIntercepted: false,\n            prerendered: false,\n            postponed: false,\n            staleTime: -1\n        };\n    }\n}\nfunction createFetch(url, headers, fetchPriority, signal) {\n    const fetchUrl = new URL(url);\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    if (false) {}\n    if (false) {}\n    return fetch(fetchUrl, {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    });\n}\nfunction createFromNextReadableStream(flightStream) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF1UWdCQSxXQUFXO2VBQVhBOztJQThCQUMsNEJBQTRCO2VBQTVCQTs7SUEvS01DLG1CQUFtQjtlQUFuQkE7O0lBbEROQywyQkFBMkI7ZUFBM0JBOzs7OENBdkNUOzJDQUNvQjtpREFDTTtnREFDSjsrQ0FJdEI7d0NBQ3VCO3dEQUNhO0FBcEMzQyxhQUFhO0FBQ2IsNkRBQTZEO0FBQzdELDZFQUE2RTtBQUM3RSxNQUFNLEVBQUVDLHdCQUF3QixFQUFFLEdBQ2hDLEtBQTBCLEdBRXRCSSxtQkFBT0EsQ0FBQywrSkFBc0MsSUFFOUNBLENBQTBDO0FBMER6QyxTQUFTTCw0QkFBNEJNLEdBQVc7SUFDckQsTUFBTUMsNkJBQTZCLElBQUlDLElBQUlGLEtBQUtHLFNBQVNDLE1BQU07SUFDL0RILDJCQUEyQkksWUFBWSxDQUFDQyxNQUFNLENBQUNDLGtCQUFBQSxvQkFBb0I7SUFDbkUsSUF6Q3lCLEtBeUNELEVBQW1CLEVBVTFDO0lBQ0QsT0FBT047QUFDVDtBQUVBLFNBQVNhLGdCQUFnQmQsR0FBVztJQUNsQyxPQUFPO1FBQ0xlLFlBQVlyQiw0QkFBNEJNLEtBQUtnQixRQUFRO1FBQ3JEQyxjQUFjQztRQUNkQyxvQkFBb0I7UUFDcEJDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxXQUFXLENBQUM7SUFDZDtBQUNGO0FBRUEsSUFBSUMsa0JBQWtCLElBQUlDO0FBRTFCLElBQUksS0FBNkIsRUFBRSxFQWNsQztBQU1NLGVBQWUvQixvQkFDcEJPLEdBQVEsRUFDUjRCLE9BQW1DO0lBRW5DLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUVDLE9BQU8sRUFBRUMsWUFBWSxFQUFFLEdBQUdIO0lBRXJELE1BQU1JLFVBQTBCO1FBQzlCLHlCQUF5QjtRQUN6QixDQUFDQyxrQkFBQUEsVUFB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QUFTO0lBQzdDLE9BQU8sSUFBSUMsZUFBZTtRQUN4QixNQUFNQyxNQUFLQyxVQUFVO1lBQ25CLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT08sSUFBSTtnQkFDekMsSUFBSSxDQUFDRixNQUFNO29CQUNULG1FQUFtRTtvQkFDbkUsbUJBQW1CO29CQUNuQkQsV0FBV0ksT0FBTyxDQUFDRjtvQkFDbkI7Z0JBQ0Y7Z0JBQ0EscUVBQXFFO2dCQUNyRSxxQkFBcUI7Z0JBQ3JCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXGZldGNoLXNlcnZlci1yZXNwb25zZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLy8gQHRzLWlnbm9yZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IHsgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbmNvbnN0IHsgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIH0gPSAoXG4gICEhcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gICAgICByZXF1aXJlKCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmVkZ2UnKVxuICAgIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuICAgICAgcmVxdWlyZSgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCcpXG4pIGFzIHR5cGVvZiBpbXBvcnQoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnKVxuXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2UsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5pbXBvcnQgdHlwZSB7IE5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSIH0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHtcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUixcbiAgTkVYVF9SU0NfVU5JT05fUVVFUlksXG4gIE5FWFRfVVJMLFxuICBSU0NfSEVBREVSLFxuICBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIsXG4gIE5FWFRfRElEX1BPU1RQT05FX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIsXG59IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB7IGNhbGxTZXJ2ZXIgfSBmcm9tICcuLi8uLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgeyBmaW5kU291cmNlTWFwVVJMIH0gZnJvbSAnLi4vLi4vYXBwLWZpbmQtc291cmNlLW1hcC11cmwnXG5pbXBvcnQgeyBQcmVmZXRjaEtpbmQgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplRmxpZ2h0RGF0YSxcbiAgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbn0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IGdldEFwcEJ1aWxkSWQgfSBmcm9tICcuLi8uLi9hcHAtYnVpbGQtaWQnXG5pbXBvcnQgeyBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSB9IGZyb20gJy4vc2V0LWNhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zIHtcbiAgcmVhZG9ubHkgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIHJlYWRvbmx5IG5leHRVcmw6IHN0cmluZyB8IG51bGxcbiAgcmVhZG9ubHkgcHJlZmV0Y2hLaW5kPzogUHJlZmV0Y2hLaW5kXG4gIHJlYWRvbmx5IGlzSG1yUmVmcmVzaD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCA9IHtcbiAgZmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGFbXSB8IHN0cmluZ1xuICBjYW5vbmljYWxVcmw6IFVSTCB8IHVuZGVmaW5lZFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cbiAgcHJlcmVuZGVyZWQ6IGJvb2xlYW5cbiAgcG9zdHBvbmVkOiBib29sZWFuXG4gIHN0YWxlVGltZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RIZWFkZXJzID0ge1xuICBbUlNDX0hFQURFUl0/OiAnMSdcbiAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXT86IHN0cmluZ1xuICBbTkVYVF9VUkxdPzogc3RyaW5nXG4gIFtORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdPzogJzEnXG4gIFtORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUl0/OiBzdHJpbmdcbiAgJ3gtZGVwbG95bWVudC1pZCc/OiBzdHJpbmdcbiAgW05FWFRfSE1SX1JFRlJFU0hfSEVBREVSXT86ICcxJ1xuICAvLyBBIGhlYWRlciB0aGF0IGlzIG9ubHkgYWRkZWQgaW4gdGVzdCBtb2RlIHRvIGFzc2VydCBvbiBmZXRjaCBwcmlvcml0eVxuICAnTmV4dC1UZXN0LUZldGNoLVByaW9yaXR5Jz86IFJlcXVlc3RJbml0Wydwcmlvcml0eSddXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsOiBzdHJpbmcpOiBVUkwge1xuICBjb25zdCB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pXG4gIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnICYmXG4gICAgICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5wYXRobmFtZS5lbmRzV2l0aCgnLnR4dCcpXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVyc1xuICAgICAgY29uc3QgbGVuZ3RoID0gcGF0aG5hbWUuZW5kc1dpdGgoJy9pbmRleC50eHQnKSA/IDEwIDogNFxuICAgICAgLy8gU2xpY2Ugb2ZmIGAvaW5kZXgudHh0YCBvciBgLnR4dGAgZnJvbSB0aGUgZW5kIG9mIHRoZSBwYXRobmFtZVxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgwLCAtbGVuZ3RoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbn1cblxuZnVuY3Rpb24gZG9NcGFOYXZpZ2F0aW9uKHVybDogc3RyaW5nKTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgZmxpZ2h0RGF0YTogdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkudG9TdHJpbmcoKSxcbiAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgIHN0YWxlVGltZTogLTEsXG4gIH1cbn1cblxubGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gQWJvcnQgYW55IGluLWZsaWdodCByZXF1ZXN0cyB3aGVuIHRoZSBwYWdlIGlzIHVubG9hZGVkLCBlLmcuIGR1ZSB0b1xuICAvLyByZWxvYWRpbmcgdGhlIHBhZ2Ugb3IgcGVyZm9ybWluZyBoYXJkIG5hdmlnYXRpb25zLiBUaGlzIGFsbG93cyB1cyB0byBpZ25vcmVcbiAgLy8gd2hhdCB3b3VsZCBvdGhlcndpc2UgYmUgYSB0aHJvd24gVHlwZUVycm9yIHdoZW4gdGhlIGJyb3dzZXIgY2FuY2VscyB0aGVcbiAgLy8gcmVxdWVzdHMuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICB9KVxuXG4gIC8vIFVzZSBhIGZyZXNoIEFib3J0Q29udHJvbGxlciBpbnN0YW5jZSBvbiBwYWdlc2hvdywgZS5nLiB3aGVuIG5hdmlnYXRpbmcgYmFja1xuICAvLyBhbmQgdGhlIEphdmFTY3JpcHQgZXhlY3V0aW9uIGNvbnRleHQgaXMgcmVzdG9yZWQgYnkgdGhlIGJyb3dzZXIuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgfSlcbn1cblxuLyoqXG4gKiBGZXRjaCB0aGUgZmxpZ2h0IGRhdGEgZm9yIHRoZSBwcm92aWRlZCB1cmwuIFRha2VzIGluIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICogdG8gZGVjaWRlIHdoYXQgdG8gcmVuZGVyIHNlcnZlci1zaWRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgdXJsOiBVUkwsXG4gIG9wdGlvbnM6IEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zXG4pOiBQcm9taXNlPEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQ+IHtcbiAgY29uc3QgeyBmbGlnaHRSb3V0ZXJTdGF0ZSwgbmV4dFVybCwgcHJlZmV0Y2hLaW5kIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgLy8gRW5hYmxlIGZsaWdodCByZXNwb25zZVxuICAgIFtSU0NfSEVBREVSXTogJzEnLFxuICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTogZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgSlNPTi5zdHJpbmdpZnkoZmxpZ2h0Um91dGVyU3RhdGUpXG4gICAgKSxcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJlZSBjYXNlczpcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgdW5kZWZpbmVkYCwgaXQgbWVhbnMgaXQncyBhIG5vcm1hbCBuYXZpZ2F0aW9uLCBzbyB3ZSB3YW50IHRvIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgZnVsbHlcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgZnVsbGAgLSB3ZSB3YW50IHRvIHByZWZldGNoIHRoZSB3aG9sZSBwYWdlIHNvIHNhbWUgYXMgYWJvdmVcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgYXV0b2AgLSBpZiB0aGUgcGFnZSBpcyBkeW5hbWljLCBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIHBhcnRpYWxseSwgaWYgc3RhdGljIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgZnVsbHlcbiAgICovXG4gIGlmIChwcmVmZXRjaEtpbmQgPT09IFByZWZldGNoS2luZC5BVVRPKSB7XG4gICAgaGVhZGVyc1tORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdID0gJzEnXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgb3B0aW9ucy5pc0htclJlZnJlc2gpIHtcbiAgICBoZWFkZXJzW05FWFRfSE1SX1JFRlJFU0hfSEVBREVSXSA9ICcxJ1xuICB9XG5cbiAgaWYgKG5leHRVcmwpIHtcbiAgICBoZWFkZXJzW05FWFRfVVJMXSA9IG5leHRVcmxcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gV2hlbiBjcmVhdGluZyBhIFwidGVtcG9yYXJ5XCIgcHJlZmV0Y2ggKHRoZSBcIm9uLWRlbWFuZFwiIHByZWZldGNoIHRoYXQgZ2V0cyBjcmVhdGVkIG9uIG5hdmlnYXRpb24sIGlmIG9uZSBkb2Vzbid0IGV4aXN0KVxuICAgIC8vIHdlIHNlbmQgdGhlIHJlcXVlc3Qgd2l0aCBhIFwiaGlnaFwiIHByaW9yaXR5IGFzIGl0J3MgaW4gcmVzcG9uc2UgdG8gYSB1c2VyIGludGVyYWN0aW9uIHRoYXQgY291bGQgYmUgYmxvY2tpbmcgYSB0cmFuc2l0aW9uLlxuICAgIC8vIE90aGVyd2lzZSwgYWxsIG90aGVyIHByZWZldGNoZXMgYXJlIHNlbnQgd2l0aCBhIFwibG93XCIgcHJpb3JpdHkuXG4gICAgLy8gV2UgdXNlIFwiYXV0b1wiIGZvciBpbiBhbGwgb3RoZXIgY2FzZXMgdG8gbWF0Y2ggdGhlIGV4aXN0aW5nIGRlZmF1bHQsIGFzIHRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIG91dHNpZGUgb2YgcHJlZmV0Y2hpbmcuXG4gICAgY29uc3QgZmV0Y2hQcmlvcml0eSA9IHByZWZldGNoS2luZFxuICAgICAgPyBwcmVmZXRjaEtpbmQgPT09IFByZWZldGNoS2luZC5URU1QT1JBUllcbiAgICAgICAgPyAnaGlnaCdcbiAgICAgICAgOiAnbG93J1xuICAgICAgOiAnYXV0bydcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIC8vIEluIFwib3V0cHV0OiBleHBvcnRcIiBtb2RlLCB3ZSBjYW4ndCByZWx5IG9uIGhlYWRlcnMgdG8gZGlzdGluZ3Vpc2hcbiAgICAgICAgLy8gYmV0d2VlbiBIVE1MIGFuZCBSU0MgcmVxdWVzdHMuIEluc3RlYWQsIHdlIGFwcGVuZCBhbiBleHRyYSBwcmVmaXhcbiAgICAgICAgLy8gdG8gdGhlIHJlcXVlc3QuXG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICB1cmwucGF0aG5hbWUgKz0gJ2luZGV4LnR4dCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwucGF0aG5hbWUgKz0gJy50eHQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBjcmVhdGVGZXRjaChcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBmZXRjaFByaW9yaXR5LFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlVXJsID0gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHJlcy51cmwpXG4gICAgY29uc3QgY2Fub25pY2FsVXJsID0gcmVzLnJlZGlyZWN0ZWQgPyByZXNwb25zZVVybCA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnXG4gICAgY29uc3QgaW50ZXJjZXB0aW9uID0gISFyZXMuaGVhZGVycy5nZXQoJ3ZhcnknKT8uaW5jbHVkZXMoTkVYVF9VUkwpXG4gICAgY29uc3QgcG9zdHBvbmVkID0gISFyZXMuaGVhZGVycy5nZXQoTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSKVxuICAgIGNvbnN0IHN0YWxlVGltZUhlYWRlciA9IHJlcy5oZWFkZXJzLmdldChORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUilcbiAgICBjb25zdCBzdGFsZVRpbWUgPVxuICAgICAgc3RhbGVUaW1lSGVhZGVyICE9PSBudWxsID8gcGFyc2VJbnQoc3RhbGVUaW1lSGVhZGVyLCAxMCkgOiAtMVxuICAgIGxldCBpc0ZsaWdodFJlc3BvbnNlID0gY29udGVudFR5cGUuc3RhcnRzV2l0aChSU0NfQ09OVEVOVF9UWVBFX0hFQURFUilcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSkge1xuICAgICAgICAgIGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKCd0ZXh0L3BsYWluJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGZldGNoIHJldHVybnMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGZsaWdodCByZXNwb25zZSBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgLy8gSWYgdGhlIGZldGNoIHdhcyBub3QgMjAwLCB3ZSBhbHNvIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UgfHwgIXJlcy5vayB8fCAhcmVzLmJvZHkpIHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9yaWdpbmFsIFVSTCBjYW1lIHdpdGggYSBoYXNoLCBwcmVzZXJ2ZSBpdCBiZWZvcmUgcmVkaXJlY3RpbmcgdG8gdGhlIG5ldyBVUkxcbiAgICAgIGlmICh1cmwuaGFzaCkge1xuICAgICAgICByZXNwb25zZVVybC5oYXNoID0gdXJsLmhhc2hcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvTXBhTmF2aWdhdGlvbihyZXNwb25zZVVybC50b1N0cmluZygpKVxuICAgIH1cblxuICAgIC8vIFdlIG1heSBuYXZpZ2F0ZSB0byBhIHBhZ2UgdGhhdCByZXF1aXJlcyBhIGRpZmZlcmVudCBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gcHJvZCwgZXZlcnkgcGFnZSB3aWxsIGhhdmUgdGhlIHNhbWUgV2VicGFjayBydW50aW1lLlxuICAgIC8vIEluIGRldiwgdGhlIFdlYnBhY2sgcnVudGltZSBpcyBtaW5pbWFsIGZvciBlYWNoIHBhZ2UuXG4gICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhlIFdlYnBhY2sgcnVudGltZSBpcyB1cGRhdGVkIGJlZm9yZSBleGVjdXRpbmcgY2xpZW50LXNpZGUgSlMgb2YgdGhlIG5ldyBwYWdlLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgIGF3YWl0IHJlcXVpcmUoJy4uL3JlYWN0LWRldi1vdmVybGF5L2FwcC9ob3QtcmVsb2FkZXItY2xpZW50Jykud2FpdEZvcldlYnBhY2tSdW50aW1lSG90VXBkYXRlKClcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIGBmZXRjaGAgcmVhZGFibGUgc3RyZWFtIHRoYXQgY2FuIGJlIHVud3JhcHBlZCBieSBgUmVhY3QudXNlYC5cbiAgICBjb25zdCBmbGlnaHRTdHJlYW0gPSBwb3N0cG9uZWRcbiAgICAgID8gY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0ocmVzLmJvZHkpXG4gICAgICA6IHJlcy5ib2R5XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbShcbiAgICAgIGZsaWdodFN0cmVhbVxuICAgICkgYXMgUHJvbWlzZTxOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2U+KVxuXG4gICAgaWYgKGdldEFwcEJ1aWxkSWQoKSAhPT0gcmVzcG9uc2UuYikge1xuICAgICAgcmV0dXJuIGRvTXBhTmF2aWdhdGlvbihyZXMudXJsKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmbGlnaHREYXRhOiBub3JtYWxpemVGbGlnaHREYXRhKHJlc3BvbnNlLmYpLFxuICAgICAgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmwsXG4gICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGludGVyY2VwdGlvbixcbiAgICAgIHByZXJlbmRlcmVkOiByZXNwb25zZS5TLFxuICAgICAgcG9zdHBvbmVkLFxuICAgICAgc3RhbGVUaW1lLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCFhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggUlNDIHBheWxvYWQgZm9yICR7dXJsfS4gRmFsbGluZyBiYWNrIHRvIGJyb3dzZXIgbmF2aWdhdGlvbi5gLFxuICAgICAgICBlcnJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBJZiBmZXRjaCBmYWlscyBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgLy8gVE9ETy1BUFA6IEFkZCBhIHRlc3QgZm9yIHRoZSBjYXNlIHdoZXJlIGEgQ09SUyByZXF1ZXN0IGZhaWxzLCBlLmcuIGV4dGVybmFsIHVybCByZWRpcmVjdCBjb21pbmcgZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvNDM2MDUjaXNzdWVjb21tZW50LTE0NTE2MTc1MjEgZm9yIGEgcmVwcm9kdWN0aW9uLlxuICAgIHJldHVybiB7XG4gICAgICBmbGlnaHREYXRhOiB1cmwudG9TdHJpbmcoKSxcbiAgICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgICAgY291bGRCZUludGVyY2VwdGVkOiBmYWxzZSxcbiAgICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICAgIHBvc3Rwb25lZDogZmFsc2UsXG4gICAgICBzdGFsZVRpbWU6IC0xLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmV0Y2goXG4gIHVybDogVVJMLFxuICBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVycyxcbiAgZmV0Y2hQcmlvcml0eTogJ2F1dG8nIHwgJ2hpZ2gnIHwgJ2xvdycgfCBudWxsLFxuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuKSB7XG4gIGNvbnN0IGZldGNoVXJsID0gbmV3IFVSTCh1cmwpXG5cbiAgLy8gVE9ETzogSW4gb3V0cHV0OiBcImV4cG9ydFwiIG1vZGUsIHRoZSBoZWFkZXJzIGRvIG5vdGhpbmcuIE9taXQgdGhlbSAoYW5kIHRoZVxuICAvLyBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbSkgZnJvbSB0aGUgcmVxdWVzdCBzbyB0aGV5J3JlXG4gIC8vIG1heGltYWxseSBjYWNoZWFibGUuXG4gIHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKGZldGNoVXJsLCBoZWFkZXJzKVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFICYmIGZldGNoUHJpb3JpdHkgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzWydOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknXSA9IGZldGNoUHJpb3JpdHlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQpIHtcbiAgICBoZWFkZXJzWyd4LWRlcGxveW1lbnQtaWQnXSA9IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICB9XG5cbiAgcmV0dXJuIGZldGNoKGZldGNoVXJsLCB7XG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3Igb2xkZXIgYnJvd3NlcnMuIGBzYW1lLW9yaWdpbmAgaXMgdGhlIGRlZmF1bHQgaW4gbW9kZXJuIGJyb3dzZXJzLlxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIGhlYWRlcnMsXG4gICAgcHJpb3JpdHk6IGZldGNoUHJpb3JpdHkgfHwgdW5kZWZpbmVkLFxuICAgIHNpZ25hbCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gIGZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKGZsaWdodFN0cmVhbSwge1xuICAgIGNhbGxTZXJ2ZXIsXG4gICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0oXG4gIG9yaWdpbmFsRmxpZ2h0U3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCBwcmVmZXRjaCBzdHJlYW1zIG1heSBjb250YWluIHJlZmVyZW5jZXMgdGhhdCBuZXZlclxuICAvLyByZXNvbHZlLCBiZWNhdXNlIHRoYXQncyBob3cgd2UgZW5jb2RlIGR5bmFtaWMgZGF0YSBhY2Nlc3MuIEluIHRoZSBkZWNvZGVkXG4gIC8vIG9iamVjdCByZXR1cm5lZCBieSB0aGUgRmxpZ2h0IGNsaWVudCwgdGhlc2UgYXJlIHJlaWZpZWQgaW50byBoYW5naW5nXG4gIC8vIHByb21pc2VzIHRoYXQgc3VzcGVuZCBkdXJpbmcgcmVuZGVyLCB3aGljaCBpcyBlZmZlY3RpdmVseSB3aGF0IHdlIHdhbnQuXG4gIC8vIFRoZSBVSSByZXNvbHZlcyB3aGVuIGl0IHN3aXRjaGVzIHRvIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtXG4gIC8vICh2aWEgdXNlRGVmZXJyZWRWYWx1ZShkeW5hbWljLCBzdGF0aWMpKS5cbiAgLy9cbiAgLy8gSG93ZXZlciwgdGhlIEZsaWdodCBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZXJyb3JzIGlmIHRoZSBzZXJ2ZXIgY2xvc2VzXG4gIC8vIHRoZSByZXNwb25zZSBiZWZvcmUgYWxsIHRoZSByZWZlcmVuY2VzIGFyZSByZXNvbHZlZC4gQXMgYSBjaGVhdCB0byB3b3JrXG4gIC8vIGFyb3VuZCB0aGlzLCB3ZSB3cmFwIHRoZSBvcmlnaW5hbCBzdHJlYW0gaW4gYSBuZXcgc3RyZWFtIHRoYXQgbmV2ZXIgY2xvc2VzLFxuICAvLyBhbmQgdGhlcmVmb3JlIGRvZXNuJ3QgZXJyb3IuXG4gIGNvbnN0IHJlYWRlciA9IG9yaWdpbmFsRmxpZ2h0U3RyZWFtLmdldFJlYWRlcigpXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAvLyBQYXNzIHRvIHRoZSB0YXJnZXQgc3RyZWFtIGFuZCBrZWVwIGNvbnN1bWluZyB0aGUgRmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgICAgLy8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVGZXRjaCIsImNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0iLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInJlcXVpcmUiLCJ1cmwiLCJ1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJOT0RFX0VOViIsIl9fTkVYVF9DT05GSUdfT1VUUFVUIiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiZG9NcGFOYXZpZ2F0aW9uIiwiZmxpZ2h0RGF0YSIsInRvU3RyaW5nIiwiY2Fub25pY2FsVXJsIiwidW5kZWZpbmVkIiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlcmVuZGVyZWQiLCJwb3N0cG9uZWQiLCJzdGFsZVRpbWUiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJvcHRpb25zIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwicHJlZmV0Y2hLaW5kIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiaXNIbXJSZWZyZXNoIiwiTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIiLCJORVhUX1VSTCIsInJlcyIsImZldGNoUHJpb3JpdHkiLCJURU1QT1JBUlkiLCJzaWduYWwiLCJyZXNwb25zZVVybCIsInJlZGlyZWN0ZWQiLCJjb250ZW50VHlwZSIsImdldCIsImludGVyY2VwdGlvbiIsImluY2x1ZGVzIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwic3RhbGVUaW1lSGVhZGVyIiwiTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIiLCJwYXJzZUludCIsImlzRmxpZ2h0UmVzcG9uc2UiLCJzdGFydHNXaXRoIiwiUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIiLCJvayIsImJvZHkiLCJoYXNoIiwiVFVSQk9QQUNLIiwid2FpdEZvcldlYnBhY2tSdW50aW1lSG90VXBkYXRlIiwiZmxpZ2h0U3RyZWFtIiwiY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0iLCJyZXNwb25zZSIsImdldEFwcEJ1aWxkSWQiLCJiIiwibm9ybWFsaXplRmxpZ2h0RGF0YSIsImYiLCJTIiwiZXJyIiwiYWJvcnRlZCIsImNvbnNvbGUiLCJlcnJvciIsImZldGNoVXJsIiwic2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0iLCJfX05FWFRfVEVTVF9NT0RFIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInByaW9yaXR5IiwiY2FsbFNlcnZlciIsImZpbmRTb3VyY2VNYXBVUkwiLCJvcmlnaW5hbEZsaWdodFN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtIiwicHVsbCIsImNvbnRyb2xsZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZW5xdWV1ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    fillCacheWithNewSubTreeData: function() {\n        return fillCacheWithNewSubTreeData;\n    },\n    fillCacheWithNewSubTreeDataButOnlyLoading: function() {\n        return fillCacheWithNewSubTreeDataButOnlyLoading;\n    }\n});\nconst _invalidatecachebyrouterstate = __webpack_require__(/*! ./invalidate-cache-by-router-state */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\n/**\n * Common logic for filling cache with new sub tree data.\n */ function fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, fillLazyItems) {\n    const { segmentPath, seedData: cacheNodeSeedData, tree: treePatch, head } = flightData;\n    let newCacheNode = newCache;\n    let existingCacheNode = existingCache;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        // segmentPath is a repeating tuple of parallelRouteKey and segment\n        // we know we've hit the last entry we've reached our final pair\n        const isLastEntry = i === segmentPath.length - 2;\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const existingChildSegmentMap = existingCacheNode.parallelRoutes.get(parallelRouteKey);\n        if (!existingChildSegmentMap) {\n            continue;\n        }\n        let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey);\n        if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n            childSegmentMap = new Map(existingChildSegmentMap);\n            newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n        }\n        const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n        let childCacheNode = childSegmentMap.get(cacheKey);\n        if (isLastEntry) {\n            if (cacheNodeSeedData && (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode)) {\n                const incomingSegment = cacheNodeSeedData[0];\n                const rsc = cacheNodeSeedData[1];\n                const loading = cacheNodeSeedData[3];\n                childCacheNode = {\n                    lazyData: null,\n                    // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n                    // not the page segment.\n                    rsc: fillLazyItems || incomingSegment !== _segment.PAGE_SEGMENT_KEY ? rsc : null,\n                    prefetchRsc: null,\n                    head: null,\n                    prefetchHead: null,\n                    loading,\n                    parallelRoutes: fillLazyItems && existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),\n                    navigatedAt\n                };\n                if (existingChildCacheNode && fillLazyItems) {\n                    (0, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, treePatch);\n                }\n                if (fillLazyItems) {\n                    (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, childCacheNode, existingChildCacheNode, treePatch, cacheNodeSeedData, head, prefetchEntry);\n                }\n                childSegmentMap.set(cacheKey, childCacheNode);\n            }\n            continue;\n        }\n        if (!childCacheNode || !existingChildCacheNode) {\n            continue;\n        }\n        if (childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                lazyData: childCacheNode.lazyData,\n                rsc: childCacheNode.rsc,\n                prefetchRsc: childCacheNode.prefetchRsc,\n                head: childCacheNode.head,\n                prefetchHead: childCacheNode.prefetchHead,\n                parallelRoutes: new Map(childCacheNode.parallelRoutes),\n                loading: childCacheNode.loading\n            };\n            childSegmentMap.set(cacheKey, childCacheNode);\n        }\n        // Move deeper into the cache nodes\n        newCacheNode = childCacheNode;\n        existingCacheNode = existingChildCacheNode;\n    }\n}\nfunction fillCacheWithNewSubTreeData(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {\n    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, true);\n}\nfunction fillCacheWithNewSubTreeDataButOnlyLoading(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {\n    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, false);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXdJZ0JBLDJCQUEyQjtlQUEzQkE7O0lBaUJBQyx5Q0FBeUM7ZUFBekNBOzs7MERBdko2QjsyREFDQztrREFDVDtxQ0FFSjtBQUdqQzs7Q0FFQyxHQUNELFNBQVNDLGdCQUNQQyxXQUFtQixFQUNuQkMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxVQUFnQyxFQUNoQ0MsYUFBNkMsRUFDN0NDLGFBQXNCO0lBRXRCLE1BQU0sRUFDSkMsV0FBVyxFQUNYQyxVQUFVQyxpQkFBaUIsRUFDM0JDLE1BQU1DLFNBQVMsRUFDZkMsSUFBSSxFQUNMLEdBQUdSO0lBQ0osSUFBSVMsZUFBZVg7SUFDbkIsSUFBSVksb0JBQW9CWDtJQUV4QixJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSVIsWUFBWVMsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDOUMsTUFBTUUsbUJBQTJCVixXQUFXLENBQUNRLEVBQUU7UUFDL0MsTUFBTUcsVUFBbUJYLFdBQVcsQ0FBQ1EsSUFBSSxFQUFFO1FBRTNDLG1FQUFtRTtRQUNuRSxnRUFBZ0U7UUFDaEUsTUFBTUksY0FBY0osTUFBTVIsWUFBWVMsTUFBTSxHQUFHO1FBQy9DLE1BQU1JLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBQUEsRUFBcUJIO1FBRXRDLE1BQU1JLDBCQUNKUixrQkFBa0JTLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUDtRQUV2QyxJQUFJLENBQUNLLHlCQUF5QjtZQUc1QjtRQUNGO1FBRUEsSUFBSUcsa0JBQWtCWixhQUFhVSxjQUFjLENBQUNDLEdBQUcsQ0FBQ1A7UUFDdEQsSUFBSSxDQUFDUSxtQkFBbUJBLG9CQUFvQkgseUJBQXlCO1lBQ25FRyxrQkFBa0IsSUFBSUMsSUFBSUo7WUFDMUJULGFBQWFVLGNBQWMsQ0FBQ0ksR0FBRyxDQUFDVixrQkFBa0JRO1FBQ3BEO1FBRUEsTUFBTUcseUJBQXlCTix3QkFBd0JFLEdBQUcsQ0FBQ0o7UUFDM0QsSUFBSVMsaUJBQWlCSixnQkFBZ0JELEdBQUcsQ0FBQ0o7UUFFekMsSUFBSUQsYUFBYTtZQUNmLElBQ0VWLHFCQUNDLEVBQUNvQixrQkFDQSxDQUFDQSxlQUFlQyxRQUFRLElBQ3hCRCxtQkFBbUJELHNCQUFBQSxDQUFxQixFQUMxQztnQkFDQSxNQUFNRyxrQkFBa0J0QixpQkFBaUIsQ0FBQyxFQUFFO2dCQUM1QyxNQUFNdUIsTUFBTXZCLGlCQUFpQixDQUFDLEVBQUU7Z0JBQ2hDLE1BQU13QixVQUFVeEIsaUJBQWlCLENBQUMsRUFBRTtnQkFFcENvQixpQkFBaUI7b0JBQ2ZDLFVBQVU7b0JBQ1YsbUZBQW1GO29CQUNuRix3QkFBd0I7b0JBQ3hCRSxLQUNFMUIsaUJBQWlCeUIsb0JBQW9CRyxTQUFBQSxnQkFBZ0IsR0FBR0YsTUFBTTtvQkFDaEVHLGFBQWE7b0JBQ2J2QixNQUFNO29CQUNOd0IsY0FBYztvQkFDZEg7b0JBQ0FWLGdCQUNFakIsaUJBQWlCc0IseUJBQ2IsSUFBSUYsSUFBSUUsdUJBQXVCTCxjQUFjLElBQzdDLElBQUlHO29CQUNWekI7Z0JBQ0Y7Z0JBRUEsSUFBSTJCLDBCQUEwQnRCLGVBQWU7b0JBQzNDK0IsQ0FBQUEsR0FBQUEsOEJBQUFBLDRCQUFBQSxFQUNFUixnQkFDQUQsd0JBQ0FqQjtnQkFFSjtnQkFDQSxJQUFJTCxlQUFlO29CQUNqQmdDLENBQUFBLEdBQUFBLCtCQUFBQSw2QkFBQUEsRUFDRXJDLGFBQ0E0QixnQkFDQUQsd0JBQ0FqQixXQUNBRixtQkFDQUcsTUFDQVA7Z0JBRUo7Z0JBRUFvQixnQkFBZ0JFLEdBQUcsQ0FBQ1AsVUFBVVM7WUFDaEM7WUFDQTtRQUNGO1FBRUEsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQ0Qsd0JBQXdCO1lBRzlDO1FBQ0Y7UUFFQSxJQUFJQyxtQkFBbUJELHdCQUF3QjtZQUM3Q0MsaUJBQWlCO2dCQUNmQyxVQUFVRCxlQUFlQyxRQUFRO2dCQUNqQ0UsS0FBS0gsZUFBZUcsR0FBRztnQkFDdkJHLGFBQWFOLGVBQWVNLFdBQVc7Z0JBQ3ZDdkIsTUFBTWlCLGVBQWVqQixJQUFJO2dCQUN6QndCLGNBQWNQLGVBQWVPLFlBQVk7Z0JBQ3pDYixnQkFBZ0IsSUFBSUcsSUFBSUcsZUFBZU4sY0FBYztnQkFDckRVLFNBQVNKLGVBQWVJLE9BQU87WUFDakM7WUFDQVIsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVVTO1FBQ2hDO1FBRUEsbUNBQW1DO1FBQ25DaEIsZUFBZWdCO1FBQ2ZmLG9CQUFvQmM7SUFDdEI7QUFDRjtBQUtPLFNBQVM5Qiw0QkFDZEcsV0FBbUIsRUFDbkJDLFFBQW1CLEVBQ25CQyxhQUF3QixFQUN4QkMsVUFBZ0MsRUFDaENDLGFBQWtDO0lBRWxDTCxnQkFDRUMsYUFDQUMsVUFDQUMsZUFDQUMsWUFDQUMsZUFDQTtBQUVKO0FBRU8sU0FBU04sMENBQ2RFLFdBQW1CLEVBQ25CQyxRQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLFVBQWdDLEVBQ2hDQyxhQUFrQztJQUVsQ0wsZ0JBQ0VDLGFBQ0FDLFVBQ0FDLGVBQ0FDLFlBQ0FDLGVBQ0E7QUFFSiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcZmlsbC1jYWNoZS13aXRoLW5ldy1zdWJ0cmVlLWRhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgU2VnbWVudCB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vaW52YWxpZGF0ZS1jYWNoZS1ieS1yb3V0ZXItc3RhdGUnXG5pbXBvcnQgeyBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCB9IGZyb20gJy4vZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5pbXBvcnQgdHlwZSB7IFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBQQUdFX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHR5cGUgeyBOb3JtYWxpemVkRmxpZ2h0RGF0YSB9IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5cbi8qKlxuICogQ29tbW9uIGxvZ2ljIGZvciBmaWxsaW5nIGNhY2hlIHdpdGggbmV3IHN1YiB0cmVlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGZpbGxDYWNoZUhlbHBlcihcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbiAgcHJlZmV0Y2hFbnRyeTogUHJlZmV0Y2hDYWNoZUVudHJ5IHwgdW5kZWZpbmVkLFxuICBmaWxsTGF6eUl0ZW1zOiBib29sZWFuXG4pOiB2b2lkIHtcbiAgY29uc3Qge1xuICAgIHNlZ21lbnRQYXRoLFxuICAgIHNlZWREYXRhOiBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICB0cmVlOiB0cmVlUGF0Y2gsXG4gICAgaGVhZCxcbiAgfSA9IGZsaWdodERhdGFcbiAgbGV0IG5ld0NhY2hlTm9kZSA9IG5ld0NhY2hlXG4gIGxldCBleGlzdGluZ0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGVcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gc2VnbWVudFBhdGhbaV1cbiAgICBjb25zdCBzZWdtZW50OiBTZWdtZW50ID0gc2VnbWVudFBhdGhbaSArIDFdXG5cbiAgICAvLyBzZWdtZW50UGF0aCBpcyBhIHJlcGVhdGluZyB0dXBsZSBvZiBwYXJhbGxlbFJvdXRlS2V5IGFuZCBzZWdtZW50XG4gICAgLy8gd2Uga25vdyB3ZSd2ZSBoaXQgdGhlIGxhc3QgZW50cnkgd2UndmUgcmVhY2hlZCBvdXIgZmluYWwgcGFpclxuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gaSA9PT0gc2VnbWVudFBhdGgubGVuZ3RoIC0gMlxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcblxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID1cbiAgICAgIGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuXG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKVxuICAgICAgbmV3Q2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBjaGlsZFNlZ21lbnRNYXApXG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhY2hlTm9kZVNlZWREYXRhICYmXG4gICAgICAgICghY2hpbGRDYWNoZU5vZGUgfHxcbiAgICAgICAgICAhY2hpbGRDYWNoZU5vZGUubGF6eURhdGEgfHxcbiAgICAgICAgICBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCBpbmNvbWluZ1NlZ21lbnQgPSBjYWNoZU5vZGVTZWVkRGF0YVswXVxuICAgICAgICBjb25zdCByc2MgPSBjYWNoZU5vZGVTZWVkRGF0YVsxXVxuICAgICAgICBjb25zdCBsb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM11cblxuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgICAvLyBXaGVuIGBmaWxsTGF6eUl0ZW1zYCBpcyBmYWxzZSwgd2Ugb25seSB3YW50IHRvIGZpbGwgdGhlIFJTQyBkYXRhIGZvciB0aGUgbGF5b3V0LFxuICAgICAgICAgIC8vIG5vdCB0aGUgcGFnZSBzZWdtZW50LlxuICAgICAgICAgIHJzYzpcbiAgICAgICAgICAgIGZpbGxMYXp5SXRlbXMgfHwgaW5jb21pbmdTZWdtZW50ICE9PSBQQUdFX1NFR01FTlRfS0VZID8gcnNjIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgIHBhcmFsbGVsUm91dGVzOlxuICAgICAgICAgICAgZmlsbExhenlJdGVtcyAmJiBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlXG4gICAgICAgICAgICAgID8gbmV3IE1hcChleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICAgICAgICA6IG5ldyBNYXAoKSxcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGlzdGluZ0NoaWxkQ2FjaGVOb2RlICYmIGZpbGxMYXp5SXRlbXMpIHtcbiAgICAgICAgICBpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlKFxuICAgICAgICAgICAgY2hpbGRDYWNoZU5vZGUsXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLFxuICAgICAgICAgICAgdHJlZVBhdGNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsTGF6eUl0ZW1zKSB7XG4gICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgIGNoaWxkQ2FjaGVOb2RlLFxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSxcbiAgICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICAgIGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIHByZWZldGNoRW50cnlcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBjaGlsZENhY2hlTm9kZSlcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgbGF6eURhdGE6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgICByc2M6IGNoaWxkQ2FjaGVOb2RlLnJzYyxcbiAgICAgICAgcHJlZmV0Y2hSc2M6IGNoaWxkQ2FjaGVOb2RlLnByZWZldGNoUnNjLFxuICAgICAgICBoZWFkOiBjaGlsZENhY2hlTm9kZS5oZWFkLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IGNoaWxkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpLFxuICAgICAgICBsb2FkaW5nOiBjaGlsZENhY2hlTm9kZS5sb2FkaW5nLFxuICAgICAgfSBhcyBDYWNoZU5vZGVcbiAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoY2FjaGVLZXksIGNoaWxkQ2FjaGVOb2RlKVxuICAgIH1cblxuICAgIC8vIE1vdmUgZGVlcGVyIGludG8gdGhlIGNhY2hlIG5vZGVzXG4gICAgbmV3Q2FjaGVOb2RlID0gY2hpbGRDYWNoZU5vZGVcbiAgICBleGlzdGluZ0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGVcbiAgfVxufVxuXG4vKipcbiAqIEZpbGwgY2FjaGUgd2l0aCByc2MgYmFzZWQgb24gZmxpZ2h0RGF0YVBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbiAgcHJlZmV0Y2hFbnRyeT86IFByZWZldGNoQ2FjaGVFbnRyeVxuKTogdm9pZCB7XG4gIGZpbGxDYWNoZUhlbHBlcihcbiAgICBuYXZpZ2F0ZWRBdCxcbiAgICBuZXdDYWNoZSxcbiAgICBleGlzdGluZ0NhY2hlLFxuICAgIGZsaWdodERhdGEsXG4gICAgcHJlZmV0Y2hFbnRyeSxcbiAgICB0cnVlXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YUJ1dE9ubHlMb2FkaW5nKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICBuZXdDYWNoZTogQ2FjaGVOb2RlLFxuICBleGlzdGluZ0NhY2hlOiBDYWNoZU5vZGUsXG4gIGZsaWdodERhdGE6IE5vcm1hbGl6ZWRGbGlnaHREYXRhLFxuICBwcmVmZXRjaEVudHJ5PzogUHJlZmV0Y2hDYWNoZUVudHJ5XG4pOiB2b2lkIHtcbiAgZmlsbENhY2hlSGVscGVyKFxuICAgIG5hdmlnYXRlZEF0LFxuICAgIG5ld0NhY2hlLFxuICAgIGV4aXN0aW5nQ2FjaGUsXG4gICAgZmxpZ2h0RGF0YSxcbiAgICBwcmVmZXRjaEVudHJ5LFxuICAgIGZhbHNlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEiLCJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGFCdXRPbmx5TG9hZGluZyIsImZpbGxDYWNoZUhlbHBlciIsIm5hdmlnYXRlZEF0IiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0RGF0YSIsInByZWZldGNoRW50cnkiLCJmaWxsTGF6eUl0ZW1zIiwic2VnbWVudFBhdGgiLCJzZWVkRGF0YSIsImNhY2hlTm9kZVNlZWREYXRhIiwidHJlZSIsInRyZWVQYXRjaCIsImhlYWQiLCJuZXdDYWNoZU5vZGUiLCJleGlzdGluZ0NhY2hlTm9kZSIsImkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsImlzTGFzdEVudHJ5IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJsYXp5RGF0YSIsImluY29taW5nU2VnbWVudCIsInJzYyIsImxvYWRpbmciLCJQQUdFX1NFR01FTlRfS0VZIiwicHJlZmV0Y2hSc2MiLCJwcmVmZXRjaEhlYWQiLCJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js ***!
  \********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"fillLazyItemsTillLeafWithHead\", ({\n    enumerable: true,\n    get: function() {\n        return fillLazyItemsTillLeafWithHead;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nfunction fillLazyItemsTillLeafWithHead(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n        // state tree. Ideally, they would always be the same shape, but because of\n        // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n        // partial tree. That's why this node is sometimes null. Once PPR lands,\n        // loading.js will no longer have special behavior and we can traverse the\n        // data tree instead.\n        //\n        // We should also consider merging the router state tree and the data tree\n        // in the response format, so that we don't have to send the keys twice.\n        // Then the client can convert them into separate representations.\n        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined ? cacheNodeSeedData[2][key] : null;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === 'auto' && prefetchEntry.status === _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);\n                let newCacheNode;\n                if (parallelSeedData !== null) {\n                    // New data was sent from the server.\n                    const seedNode = parallelSeedData[1];\n                    const loading = parallelSeedData[3];\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: seedNode,\n                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n                        // this path during a navigation, but until PPR is fully implemented\n                        // yet it's possible the existing node does have a non-null\n                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n                        // old behavior â€” no PPR value.\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        loading,\n                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),\n                        navigatedAt\n                    };\n                } else if (hasReusablePrefetch && existingCacheNode) {\n                    // No new data was sent from the server, but the existing cache node\n                    // was prefetched, so we should reuse that.\n                    newCacheNode = {\n                        lazyData: existingCacheNode.lazyData,\n                        rsc: existingCacheNode.rsc,\n                        // This is a PPR-only field. Unlike the previous branch, since we're\n                        // just cloning the existing cache node, we might as well keep the\n                        // PPR value, if it exists.\n                        prefetchRsc: existingCacheNode.prefetchRsc,\n                        head: existingCacheNode.head,\n                        prefetchHead: existingCacheNode.prefetchHead,\n                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n                        loading: existingCacheNode.loading\n                    };\n                } else {\n                    // No data available for this node. This will trigger a lazy fetch\n                    // during render.\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: null,\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),\n                        loading: null,\n                        navigatedAt\n                    };\n                }\n                // Overrides the cache key with the new cache node.\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                // Traverse deeper to apply the head / fill lazy items till the head.\n                fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        let newCacheNode;\n        if (parallelSeedData !== null) {\n            // New data was sent from the server.\n            const seedNode = parallelSeedData[1];\n            const loading = parallelSeedData[3];\n            newCacheNode = {\n                lazyData: null,\n                rsc: seedNode,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading,\n                navigatedAt\n            };\n        } else {\n            // No data available for this node. This will trigger a lazy fetch\n            // during render.\n            newCacheNode = {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading: null,\n                navigatedAt\n            };\n        }\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7aUVBV2dCQTs7O2VBQUFBOzs7a0RBTnFCO2dEQUk5QjtBQUVBLFNBQVNBLDhCQUNkQyxXQUFtQixFQUNuQkMsUUFBbUIsRUFDbkJDLGFBQW9DLEVBQ3BDQyxXQUE4QixFQUM5QkMsaUJBQTJDLEVBQzNDQyxJQUFxQixFQUNyQkMsYUFBNkM7SUFFN0MsTUFBTUMsZ0JBQWdCQyxPQUFPQyxJQUFJLENBQUNOLFdBQVcsQ0FBQyxFQUFFLEVBQUVPLE1BQU0sS0FBSztJQUM3RCxJQUFJSCxlQUFlO1FBQ2pCTixTQUFTSSxJQUFJLEdBQUdBO1FBQ2hCO0lBQ0Y7SUFDQSx1RkFBdUY7SUFDdkYsSUFBSyxNQUFNTSxPQUFPUixXQUFXLENBQUMsRUFBRSxDQUFFO1FBQ2hDLE1BQU1TLHFCQUFxQlQsV0FBVyxDQUFDLEVBQUUsQ0FBQ1EsSUFBSTtRQUM5QyxNQUFNRSwwQkFBMEJELGtCQUFrQixDQUFDLEVBQUU7UUFDckQsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFBQSxFQUFxQkY7UUFFdEMsNEVBQTRFO1FBQzVFLDJFQUEyRTtRQUMzRSx3RUFBd0U7UUFDeEUsd0VBQXdFO1FBQ3hFLDBFQUEwRTtRQUMxRSxxQkFBcUI7UUFDckIsRUFBRTtRQUNGLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsa0VBQWtFO1FBQ2xFLE1BQU1HLG1CQUNKWixzQkFBc0IsUUFBUUEsaUJBQWlCLENBQUMsRUFBRSxDQUFDTyxJQUFJLEtBQUtNLFlBQ3hEYixpQkFBaUIsQ0FBQyxFQUFFLENBQUNPLElBQUksR0FDekI7UUFDTixJQUFJVCxlQUFlO1lBQ2pCLE1BQU1nQixrQ0FDSmhCLGNBQWNpQixjQUFjLENBQUNDLEdBQUcsQ0FBQ1Q7WUFDbkMsSUFBSU8saUNB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NUIsU0FBU2tCLGNBQWMsQ0FBQ2lCLEdBQUcsQ0FBQ3pCLEtBQUssSUFBSWdCLElBQUk7Z0JBQUM7b0JBQUNiO29CQUFVZTtpQkFBYTthQUFDO1FBQ3JFO1FBRUE5Qiw4QkFDRUMsYUFDQTZCLGNBQ0FaLFdBQ0FMLG9CQUNBSSxrQkFDQVgsTUFDQUM7SUFFSjtBQUNGIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxmaWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgQ2FjaGVOb2RlU2VlZERhdGEsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuaW1wb3J0IHtcbiAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLFxuICB0eXBlIFByZWZldGNoQ2FjaGVFbnRyeSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICBuZXdDYWNoZTogQ2FjaGVOb2RlLFxuICBleGlzdGluZ0NhY2hlOiBDYWNoZU5vZGUgfCB1bmRlZmluZWQsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgY2FjaGVOb2RlU2VlZERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgaGVhZDogUmVhY3QuUmVhY3ROb2RlLFxuICBwcmVmZXRjaEVudHJ5OiBQcmVmZXRjaENhY2hlRW50cnkgfCB1bmRlZmluZWRcbik6IHZvaWQge1xuICBjb25zdCBpc0xhc3RTZWdtZW50ID0gT2JqZWN0LmtleXMocm91dGVyU3RhdGVbMV0pLmxlbmd0aCA9PT0gMFxuICBpZiAoaXNMYXN0U2VnbWVudCkge1xuICAgIG5ld0NhY2hlLmhlYWQgPSBoZWFkXG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gUmVtb3ZlIHNlZ21lbnQgdGhhdCB3ZSBnb3QgZGF0YSBmb3Igc28gdGhhdCBpdCBpcyBmaWxsZWQgaW4gZHVyaW5nIHJlbmRlcmluZyBvZiByc2MuXG4gIGZvciAoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZVN0YXRlID0gcm91dGVyU3RhdGVbMV1ba2V5XVxuICAgIGNvbnN0IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlID0gcGFyYWxsZWxSb3V0ZVN0YXRlWzBdXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSlcblxuICAgIC8vIFRPRE86IFdlIHNob3VsZCB0cmF2ZXJzZSB0aGUgY2FjaGVOb2RlU2VlZERhdGEgdHJlZSBpbnN0ZWFkIG9mIHRoZSByb3V0ZXJcbiAgICAvLyBzdGF0ZSB0cmVlLiBJZGVhbGx5LCB0aGV5IHdvdWxkIGFsd2F5cyBiZSB0aGUgc2FtZSBzaGFwZSwgYnV0IGJlY2F1c2Ugb2ZcbiAgICAvLyB0aGUgbG9hZGluZy5qcyBwYXR0ZXJuLCBjYWNoZU5vZGVTZWVkRGF0YSBzb21ldGltZXMgb25seSByZXByZXNlbnRzIGFcbiAgICAvLyBwYXJ0aWFsIHRyZWUuIFRoYXQncyB3aHkgdGhpcyBub2RlIGlzIHNvbWV0aW1lcyBudWxsLiBPbmNlIFBQUiBsYW5kcyxcbiAgICAvLyBsb2FkaW5nLmpzIHdpbGwgbm8gbG9uZ2VyIGhhdmUgc3BlY2lhbCBiZWhhdmlvciBhbmQgd2UgY2FuIHRyYXZlcnNlIHRoZVxuICAgIC8vIGRhdGEgdHJlZSBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gV2Ugc2hvdWxkIGFsc28gY29uc2lkZXIgbWVyZ2luZyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgYW5kIHRoZSBkYXRhIHRyZWVcbiAgICAvLyBpbiB0aGUgcmVzcG9uc2UgZm9ybWF0LCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gc2VuZCB0aGUga2V5cyB0d2ljZS5cbiAgICAvLyBUaGVuIHRoZSBjbGllbnQgY2FuIGNvbnZlcnQgdGhlbSBpbnRvIHNlcGFyYXRlIHJlcHJlc2VudGF0aW9ucy5cbiAgICBjb25zdCBwYXJhbGxlbFNlZWREYXRhID1cbiAgICAgIGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsICYmIGNhY2hlTm9kZVNlZWREYXRhWzJdW2tleV0gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGNhY2hlTm9kZVNlZWREYXRhWzJdW2tleV1cbiAgICAgICAgOiBudWxsXG4gICAgaWYgKGV4aXN0aW5nQ2FjaGUpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUgPVxuICAgICAgICBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpXG4gICAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSkge1xuICAgICAgICBjb25zdCBoYXNSZXVzYWJsZVByZWZldGNoID1cbiAgICAgICAgICBwcmVmZXRjaEVudHJ5Py5raW5kID09PSAnYXV0bycgJiZcbiAgICAgICAgICBwcmVmZXRjaEVudHJ5LnN0YXR1cyA9PT0gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnJldXNhYmxlXG5cbiAgICAgICAgbGV0IHBhcmFsbGVsUm91dGVDYWNoZU5vZGUgPSBuZXcgTWFwKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FjaGVOb2RlID0gcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5nZXQoY2FjaGVLZXkpXG4gICAgICAgIGxldCBuZXdDYWNoZU5vZGU6IENhY2hlTm9kZVxuICAgICAgICBpZiAocGFyYWxsZWxTZWVkRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIE5ldyBkYXRhIHdhcyBzZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICBjb25zdCBzZWVkTm9kZSA9IHBhcmFsbGVsU2VlZERhdGFbMV1cbiAgICAgICAgICBjb25zdCBsb2FkaW5nID0gcGFyYWxsZWxTZWVkRGF0YVszXVxuICAgICAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgcnNjOiBzZWVkTm9kZSxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBQUFItb25seSBmaWVsZC4gV2hlbiBQUFIgaXMgZW5hYmxlZCwgd2Ugc2hvdWxkbid0IGhpdFxuICAgICAgICAgICAgLy8gdGhpcyBwYXRoIGR1cmluZyBhIG5hdmlnYXRpb24sIGJ1dCB1bnRpbCBQUFIgaXMgZnVsbHkgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIC8vIHlldCBpdCdzIHBvc3NpYmxlIHRoZSBleGlzdGluZyBub2RlIGRvZXMgaGF2ZSBhIG5vbi1udWxsXG4gICAgICAgICAgICAvLyBgcHJlZmV0Y2hSc2NgLiBBcyBhbiBpbmNyZW1lbnRhbCBzdGVwLCB3ZSdsbCBqdXN0IGRlLW9wdCB0byB0aGVcbiAgICAgICAgICAgIC8vIG9sZCBiZWhhdmlvciDigJQgbm8gUFBSIHZhbHVlLlxuICAgICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICAgICAgbG9hZGluZyxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGV4aXN0aW5nQ2FjaGVOb2RlPy5wYXJhbGxlbFJvdXRlcyksXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzUmV1c2FibGVQcmVmZXRjaCAmJiBleGlzdGluZ0NhY2hlTm9kZSkge1xuICAgICAgICAgIC8vIE5vIG5ldyBkYXRhIHdhcyBzZW50IGZyb20gdGhlIHNlcnZlciwgYnV0IHRoZSBleGlzdGluZyBjYWNoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHByZWZldGNoZWQsIHNvIHdlIHNob3VsZCByZXVzZSB0aGF0LlxuICAgICAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIGxhenlEYXRhOiBleGlzdGluZ0NhY2hlTm9kZS5sYXp5RGF0YSxcbiAgICAgICAgICAgIHJzYzogZXhpc3RpbmdDYWNoZU5vZGUucnNjLFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFBQUi1vbmx5IGZpZWxkLiBVbmxpa2UgdGhlIHByZXZpb3VzIGJyYW5jaCwgc2luY2Ugd2UncmVcbiAgICAgICAgICAgIC8vIGp1c3QgY2xvbmluZyB0aGUgZXhpc3RpbmcgY2FjaGUgbm9kZSwgd2UgbWlnaHQgYXMgd2VsbCBrZWVwIHRoZVxuICAgICAgICAgICAgLy8gUFBSIHZhbHVlLCBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICBwcmVmZXRjaFJzYzogZXhpc3RpbmdDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICAgICAgICBoZWFkOiBleGlzdGluZ0NhY2hlTm9kZS5oZWFkLFxuICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBleGlzdGluZ0NhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChleGlzdGluZ0NhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcyksXG4gICAgICAgICAgICBsb2FkaW5nOiBleGlzdGluZ0NhY2hlTm9kZS5sb2FkaW5nLFxuICAgICAgICAgIH0gYXMgQ2FjaGVOb2RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZGF0YSBhdmFpbGFibGUgZm9yIHRoaXMgbm9kZS4gVGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoXG4gICAgICAgICAgLy8gZHVyaW5nIHJlbmRlci5cbiAgICAgICAgICBuZXdDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGV4aXN0aW5nQ2FjaGVOb2RlPy5wYXJhbGxlbFJvdXRlcyksXG4gICAgICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3ZlcnJpZGVzIHRoZSBjYWNoZSBrZXkgd2l0aCB0aGUgbmV3IGNhY2hlIG5vZGUuXG4gICAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuc2V0KGNhY2hlS2V5LCBuZXdDYWNoZU5vZGUpXG4gICAgICAgIC8vIFRyYXZlcnNlIGRlZXBlciB0byBhcHBseSB0aGUgaGVhZCAvIGZpbGwgbGF6eSBpdGVtcyB0aWxsIHRoZSBoZWFkLlxuICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBuZXdDYWNoZU5vZGUsXG4gICAgICAgICAgZXhpc3RpbmdDYWNoZU5vZGUsXG4gICAgICAgICAgcGFyYWxsZWxSb3V0ZVN0YXRlLFxuICAgICAgICAgIHBhcmFsbGVsU2VlZERhdGEgPyBwYXJhbGxlbFNlZWREYXRhIDogbnVsbCxcbiAgICAgICAgICBoZWFkLFxuICAgICAgICAgIHByZWZldGNoRW50cnlcbiAgICAgICAgKVxuXG4gICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5ld0NhY2hlTm9kZTogQ2FjaGVOb2RlXG4gICAgaWYgKHBhcmFsbGVsU2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIC8vIE5ldyBkYXRhIHdhcyBzZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgIGNvbnN0IHNlZWROb2RlID0gcGFyYWxsZWxTZWVkRGF0YVsxXVxuICAgICAgY29uc3QgbG9hZGluZyA9IHBhcmFsbGVsU2VlZERhdGFbM11cbiAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgIHJzYzogc2VlZE5vZGUsXG4gICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBkYXRhIGF2YWlsYWJsZSBmb3IgdGhpcyBub2RlLiBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2hcbiAgICAgIC8vIGR1cmluZyByZW5kZXIuXG4gICAgICBuZXdDYWNoZU5vZGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2M6IG51bGwsXG4gICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KVxuICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzKSB7XG4gICAgICBleGlzdGluZ1BhcmFsbGVsUm91dGVzLnNldChjYWNoZUtleSwgbmV3Q2FjaGVOb2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBuZXcgTWFwKFtbY2FjaGVLZXksIG5ld0NhY2hlTm9kZV1dKSlcbiAgICB9XG5cbiAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgbmV3Q2FjaGVOb2RlLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcGFyYWxsZWxSb3V0ZVN0YXRlLFxuICAgICAgcGFyYWxsZWxTZWVkRGF0YSxcbiAgICAgIGhlYWQsXG4gICAgICBwcmVmZXRjaEVudHJ5XG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOlsiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJuYXZpZ2F0ZWRBdCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJoZWFkIiwicHJlZmV0Y2hFbnRyeSIsImlzTGFzdFNlZ21lbnQiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwia2V5IiwicGFyYWxsZWxSb3V0ZVN0YXRlIiwic2VnbWVudEZvclBhcmFsbGVsUm91dGUiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwicGFyYWxsZWxTZWVkRGF0YSIsInVuZGVmaW5lZCIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsImhhc1JldXNhYmxlUHJlZmV0Y2giLCJraW5kIiwic3RhdHVzIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwicmV1c2FibGUiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZXhpc3RpbmdDYWNoZU5vZGUiLCJuZXdDYWNoZU5vZGUiLCJzZWVkTm9kZSIsImxvYWRpbmciLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwicHJlZmV0Y2hIZWFkIiwic2V0IiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/handle-mutable.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleMutable\", ({\n    enumerable: true,\n    get: function() {\n        return handleMutable;\n    }\n}));\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nfunction isNotUndefined(value) {\n    return typeof value !== 'undefined';\n}\nfunction handleMutable(state, mutable) {\n    var _mutable_shouldScroll;\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = (_mutable_shouldScroll = mutable.shouldScroll) != null ? _mutable_shouldScroll : true;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    var _mutable_scrollableSegments;\n    return {\n        // Set href.\n        canonicalUrl: isNotUndefined(mutable.canonicalUrl) ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable == null ? void 0 : mutable.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: mutable.onlyHashChange || false,\n            hashFragment: shouldScroll ? mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? (_mutable_scrollableSegments = mutable == null ? void 0 : mutable.scrollableSegments) != null ? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-mutable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2hhbmRsZS1tdXRhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7aURBV2dCQTs7O2VBQUFBOzs7Z0RBWG1CO0FBT25DLFNBQVNDLGVBQWtCQyxLQUFRO0lBQ2pDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVPLFNBQVNGLGNBQ2RHLEtBQTJCLEVBQzNCQyxPQUFnQjtRQUdLQTtJQURyQiwwREFBMEQ7SUFDMUQsTUFBTUMsZUFBZUQsQ0FBQUEsd0JBQUFBLFFBQVFDLFlBQUFBLEtBQVksT0FBcEJELHdCQUF3QjtJQUU3QyxJQUFJRSxVQUFVSCxNQUFNRyxPQUFPO0lBRTNCLElBQUlMLGVBQWVHLFFBQVFHLFdBQVcsR0FBRztRQUN2QyxzRUFBc0U7UUFDdEUsTUFBTUMsY0FBY0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFBQSxFQUFtQk4sTUFBTU8sSUFBSSxFQUFFTixRQUFRRyxXQUFXO1FBQ3RFLElBQUlDLGFBQWE7WUFDZixxREFBcUQ7WUFDckRGLFVBQVVFO1FBQ1osT0FBTyxJQUFJLENBQUNGLFNBQVM7WUFDbkIsNkhBQTZIO1lBQzdIQSxVQUFVSCxNQUFNUSxZQUFZO1FBQzlCO0lBQ0EsMEVBQTBFO0lBQzVFO1FBeUNRUDtJQXZDUixPQUFPO1FBQ0wsWUFBWTtRQUNaTyxjQUFjVixlQUFlRyxRQUFRTyxZQUFZLElBQzdDUCxRQUFRTyxZQUFZLEtBQUtSLE1BQU1RLFlBQVksR0FDekNSLE1BQU1RLFlBQVksR0FDbEJQLFFBQVFPLFlBQVksR0FDdEJSLE1BQU1RLFlBQVk7UUFDdEJDLFNBQVM7WUFDUEMsYUFBYVosZUFBZUcsUUFBUVMsV0FBVyxJQUMzQ1QsUUFBUVMsV0FBVyxHQUNuQlYsTUFBTVMsT0FBTyxDQUFDQyxXQUFXO1lBQzdCQyxlQUFlYixlQUFlRyxRQUFRVSxhQUFhLElBQy9DVixRQUFRVSxhQUFhLEdBQ3JCWCxNQUFNUyxPQUFPLENBQUNFLGFBQWE7WUFDL0JDLDRCQUE0QmQsZUFDMUJHLFFBQVFXLDBCQUEwQixJQUVoQ1gsUUFBUVcsMEJBQTBCLEdBQ2xDWixNQUFNUyxPQUFPLENBQUNHLDBCQUEwQjtRQUM5QztRQUNBLGtFQUFrRTtRQUNsRUMsbUJBQW1CO1lBQ2pCQyxPQUFPWixlQUNISixlQUFlRyxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTYyxrQkFBa0IsSUFDeEMsT0FDQWYsTUFBTWEsaUJBQWlCLENBQUNDLEtBQUssR0FFL0I7WUFDSkUsZ0JBQWdCZixRQUFRZSxjQUFjLElBQUk7WUFDMUNDLGNBQWNmLGVBRVYsUUFDUWUsWUFBWSxJQUFJaEIsUUFBUWdCLElBREksUUFDUSxLQUFLLEtBRS9DQyxtQkFBbUJqQixRQUFRZ0IsWUFBWSxDQUFDRSxLQUFLLENBQUMsTUFDOUNuQixNQUFNYSxpQkFBaUIsQ0FBQ0ksWUFBWSxHQUV0QztZQUNKRyxjQUFjbEIsZUFDVkQsQ0FBQUEsOEJBQUFBLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNjLGtCQUFBQSxLQUFrQixPQUEzQmQsOEJBQStCRCxNQUFNYSxpQkFBaUIsQ0FBQ08sWUFBWSxHQUVuRSxFQUFFO1FBQ1I7UUFDQSxlQUFlO1FBQ2ZDLE9BQU9wQixRQUFRb0IsS0FBSyxHQUFHcEIsUUFBUW9CLEtBQUssR0FBR3JCLE1BQU1xQixLQUFLO1FBQ2xEQyxlQUFlckIsUUFBUXFCLGFBQWEsR0FDaENyQixRQUFRcUIsYUFBYSxHQUNyQnRCLE1BQU1zQixhQUFhO1FBQ3ZCLDhCQUE4QjtRQUM5QmYsTUFBTVQsZUFBZUcsUUFBUUcsV0FBVyxJQUNwQ0gsUUFBUUcsV0FBVyxHQUNuQkosTUFBTU8sSUFBSTtRQUNkSjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXGhhbmRsZS1tdXRhYmxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXB1dGVDaGFuZ2VkUGF0aCB9IGZyb20gJy4vY29tcHV0ZS1jaGFuZ2VkLXBhdGgnXG5pbXBvcnQgdHlwZSB7XG4gIE11dGFibGUsXG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5cbmZ1bmN0aW9uIGlzTm90VW5kZWZpbmVkPFQ+KHZhbHVlOiBUKTogdmFsdWUgaXMgRXhjbHVkZTxULCB1bmRlZmluZWQ+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZU11dGFibGUoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgbXV0YWJsZTogTXV0YWJsZVxuKTogUmVkdWNlclN0YXRlIHtcbiAgLy8gc2hvdWxkU2Nyb2xsIGlzIHRydWUgYnkgZGVmYXVsdCwgY2FuIG92ZXJyaWRlIHRvIGZhbHNlLlxuICBjb25zdCBzaG91bGRTY3JvbGwgPSBtdXRhYmxlLnNob3VsZFNjcm9sbCA/PyB0cnVlXG5cbiAgbGV0IG5leHRVcmwgPSBzdGF0ZS5uZXh0VXJsXG5cbiAgaWYgKGlzTm90VW5kZWZpbmVkKG11dGFibGUucGF0Y2hlZFRyZWUpKSB7XG4gICAgLy8gSWYgd2UgcmVjZWl2ZWQgYSBwYXRjaGVkIHRyZWUsIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgY2hhbmdlZCBwYXRoLlxuICAgIGNvbnN0IGNoYW5nZWRQYXRoID0gY29tcHV0ZUNoYW5nZWRQYXRoKHN0YXRlLnRyZWUsIG11dGFibGUucGF0Y2hlZFRyZWUpXG4gICAgaWYgKGNoYW5nZWRQYXRoKSB7XG4gICAgICAvLyBJZiB0aGUgdHJlZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbmV4dFVybFxuICAgICAgbmV4dFVybCA9IGNoYW5nZWRQYXRoXG4gICAgfSBlbHNlIGlmICghbmV4dFVybCkge1xuICAgICAgLy8gaWYgdGhlIHRyZWUgZW5kcyB1cCBiZWluZyB0aGUgc2FtZSAoaWUsIG5vIGNoYW5nZWQgcGF0aCksIGFuZCB3ZSBkb24ndCBoYXZlIGEgbmV4dFVybCwgdGhlbiB3ZSBzaG91bGQgdXNlIHRoZSBjYW5vbmljYWxVcmxcbiAgICAgIG5leHRVcmwgPSBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHRoaXMgd2lsbCBiZSBhIG5vLW9wIGFuZCBjb250aW51ZSB0byB1c2UgdGhlIGV4aXN0aW5nIG5leHRVcmxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gU2V0IGhyZWYuXG4gICAgY2Fub25pY2FsVXJsOiBpc05vdFVuZGVmaW5lZChtdXRhYmxlLmNhbm9uaWNhbFVybClcbiAgICAgID8gbXV0YWJsZS5jYW5vbmljYWxVcmwgPT09IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICA/IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICA6IG11dGFibGUuY2Fub25pY2FsVXJsXG4gICAgICA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICBwdXNoUmVmOiB7XG4gICAgICBwZW5kaW5nUHVzaDogaXNOb3RVbmRlZmluZWQobXV0YWJsZS5wZW5kaW5nUHVzaClcbiAgICAgICAgPyBtdXRhYmxlLnBlbmRpbmdQdXNoXG4gICAgICAgIDogc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCxcbiAgICAgIG1wYU5hdmlnYXRpb246IGlzTm90VW5kZWZpbmVkKG11dGFibGUubXBhTmF2aWdhdGlvbilcbiAgICAgICAgPyBtdXRhYmxlLm1wYU5hdmlnYXRpb25cbiAgICAgICAgOiBzdGF0ZS5wdXNoUmVmLm1wYU5hdmlnYXRpb24sXG4gICAgICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZTogaXNOb3RVbmRlZmluZWQoXG4gICAgICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGVcbiAgICAgIClcbiAgICAgICAgPyBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlXG4gICAgICAgIDogc3RhdGUucHVzaFJlZi5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSxcbiAgICB9LFxuICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICBhcHBseTogc2hvdWxkU2Nyb2xsXG4gICAgICAgID8gaXNOb3RVbmRlZmluZWQobXV0YWJsZT8uc2Nyb2xsYWJsZVNlZ21lbnRzKVxuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHlcbiAgICAgICAgOiAvLyBJZiBzaG91bGRTY3JvbGwgaXMgZmFsc2UgdGhlbiB3ZSBzaG91bGQgbm90IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICBmYWxzZSxcbiAgICAgIG9ubHlIYXNoQ2hhbmdlOiBtdXRhYmxlLm9ubHlIYXNoQ2hhbmdlIHx8IGZhbHNlLFxuICAgICAgaGFzaEZyYWdtZW50OiBzaG91bGRTY3JvbGxcbiAgICAgICAgPyAvLyBFbXB0eSBoYXNoIHNob3VsZCB0cmlnZ2VyIGRlZmF1bHQgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIGxheW91dCBpbnRvIHZpZXcuXG4gICAgICAgICAgLy8gI3RvcCBpcyBoYW5kbGVkIGluIGxheW91dC1yb3V0ZXIuXG4gICAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgJiYgbXV0YWJsZS5oYXNoRnJhZ21lbnQgIT09ICcnXG4gICAgICAgICAgPyAvLyBSZW1vdmUgbGVhZGluZyAjIGFuZCBkZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBoYXNoZXMgd29yay5cbiAgICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChtdXRhYmxlLmhhc2hGcmFnbWVudC5zbGljZSgxKSlcbiAgICAgICAgICA6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudFxuICAgICAgICA6IC8vIElmIHNob3VsZFNjcm9sbCBpcyBmYWxzZSB0aGVuIHdlIHNob3VsZCBub3QgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgICAgICAgIG51bGwsXG4gICAgICBzZWdtZW50UGF0aHM6IHNob3VsZFNjcm9sbFxuICAgICAgICA/IG11dGFibGU/LnNjcm9sbGFibGVTZWdtZW50cyA/PyBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZi5zZWdtZW50UGF0aHNcbiAgICAgICAgOiAvLyBJZiBzaG91bGRTY3JvbGwgaXMgZmFsc2UgdGhlbiB3ZSBzaG91bGQgbm90IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICBbXSxcbiAgICB9LFxuICAgIC8vIEFwcGx5IGNhY2hlLlxuICAgIGNhY2hlOiBtdXRhYmxlLmNhY2hlID8gbXV0YWJsZS5jYWNoZSA6IHN0YXRlLmNhY2hlLFxuICAgIHByZWZldGNoQ2FjaGU6IG11dGFibGUucHJlZmV0Y2hDYWNoZVxuICAgICAgPyBtdXRhYmxlLnByZWZldGNoQ2FjaGVcbiAgICAgIDogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICB0cmVlOiBpc05vdFVuZGVmaW5lZChtdXRhYmxlLnBhdGNoZWRUcmVlKVxuICAgICAgPyBtdXRhYmxlLnBhdGNoZWRUcmVlXG4gICAgICA6IHN0YXRlLnRyZWUsXG4gICAgbmV4dFVybCxcbiAgfVxufVxuIl0sIm5hbWVzIjpbImhhbmRsZU11dGFibGUiLCJpc05vdFVuZGVmaW5lZCIsInZhbHVlIiwic3RhdGUiLCJtdXRhYmxlIiwic2hvdWxkU2Nyb2xsIiwibmV4dFVybCIsInBhdGNoZWRUcmVlIiwiY2hhbmdlZFBhdGgiLCJjb21wdXRlQ2hhbmdlZFBhdGgiLCJ0cmVlIiwiY2Fub25pY2FsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsInNjcm9sbGFibGVTZWdtZW50cyIsIm9ubHlIYXNoQ2hhbmdlIiwiaGFzaEZyYWdtZW50IiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2xpY2UiLCJzZWdtZW50UGF0aHMiLCJjYWNoZSIsInByZWZldGNoQ2FjaGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSegmentMismatch\", ({\n    enumerable: true,\n    get: function() {\n        return handleSegmentMismatch;\n    }\n}));\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nfunction handleSegmentMismatch(state, action, treePatch) {\n    if (true) {\n        console.warn('Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' + 'Reason: Segment mismatch\\n' + (\"Last Action: \" + action.type + \"\\n\\n\") + (\"Current Tree: \" + JSON.stringify(state.tree) + \"\\n\\n\") + (\"Tree Patch Payload: \" + JSON.stringify(treePatch)));\n    }\n    return (0, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, true);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-segment-mismatch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7eURBV2dCQTs7O2VBQUFBOzs7NkNBVmtCO0FBVTNCLFNBQVNBLHNCQUNkQyxLQUEyQixFQUMzQkMsTUFBc0IsRUFDdEJDLFNBQTRCO0lBRTVCLElBQUlDLElBQW9CLEVBQW9CO1FBQzFDRyxRQUFRQyxJQUFJLENBQ1Ysc0pBQ0UsK0JBQ0EsQ0FBQyxrQkFBZU4sT0FBT08sSUFBSSxHQUFDLE9BQUksSUFDaEMsbUJBQWlCQyxLQUFLQyxTQUFTLENBQUNWLE1BQU1XLElBQUksSUFBRSxPQUFJLElBQ2hELHlCQUF1QkYsS0FBS0MsU0FBUyxDQUFDUixVQUFBQSxDQUFXO0lBRXZEO0lBRUEsT0FBT1UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUFrQlosT0FBTyxDQUFDLEdBQUdBLE1BQU1hLFlBQVksRUFBRTtBQUMxRCIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyQWN0aW9ucyxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHRoZSBjbGllbnQgcm91dGVyIGF0dGVtcHRlZCB0byBwYXRjaCB0aGUgdHJlZSBidXQsIGR1ZSB0byBhIG1pc21hdGNoLCB0aGUgcGF0Y2ggZmFpbGVkLlxuICogVGhpcyB3aWxsIHBlcmZvcm0gYW4gTVBBIG5hdmlnYXRpb24gdG8gcmV0dXJuIHRoZSByb3V0ZXIgdG8gYSB2YWxpZCBzdGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlZHVjZXJBY3Rpb25zLFxuICB0cmVlUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1BlcmZvcm1pbmcgaGFyZCBuYXZpZ2F0aW9uIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBleHBlcmllbmNlZCBhbiB1bnJlY292ZXJhYmxlIGVycm9yLiBJZiB0aGlzIGtlZXBzIG9jY3VycmluZywgcGxlYXNlIGZpbGUgYSBOZXh0LmpzIGlzc3VlLlxcblxcbicgK1xuICAgICAgICAnUmVhc29uOiBTZWdtZW50IG1pc21hdGNoXFxuJyArXG4gICAgICAgIGBMYXN0IEFjdGlvbjogJHthY3Rpb24udHlwZX1cXG5cXG5gICtcbiAgICAgICAgYEN1cnJlbnQgVHJlZTogJHtKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKX1cXG5cXG5gICtcbiAgICAgICAgYFRyZWUgUGF0Y2ggUGF5bG9hZDogJHtKU09OLnN0cmluZ2lmeSh0cmVlUGF0Y2gpfWBcbiAgICApXG4gIH1cblxuICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIHt9LCBzdGF0ZS5jYW5vbmljYWxVcmwsIHRydWUpXG59XG4iXSwibmFtZXMiOlsiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwic3RhdGUiLCJhY3Rpb24iLCJ0cmVlUGF0Y2giLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwid2FybiIsInR5cGUiLCJKU09OIiwic3RyaW5naWZ5IiwidHJlZSIsImhhbmRsZUV4dGVybmFsVXJsIiwiY2Fub25pY2FsVXJsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js ***!
  \**************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"invalidateCacheBelowFlightSegmentPath\", ({\n    enumerable: true,\n    get: function() {\n        return invalidateCacheBelowFlightSegmentPath;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(ssr)/./node_modules/next/dist/client/flight-data-helpers.js\");\nfunction invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(cacheKey);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, (0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7eUVBUWdCQTs7O2VBQUFBOzs7a0RBTnFCOytDQUNJO0FBS2xDLFNBQVNBLHNDQUNkQyxRQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLGlCQUFvQztJQUVwQyxNQUFNQyxjQUFjRCxrQkFBa0JFLE1BQU0sSUFBSTtJQUNoRCxNQUFNLENBQUNDLGtCQUFrQkMsUUFBUSxHQUFHSjtJQUVwQyxNQUFNSyxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQUFBLEVBQXFCRjtJQUV0QyxNQUFNRywwQkFDSlIsY0FBY1MsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBRW5DLElBQUksQ0FBQ0kseUJBQXlCO1FBQzVCLDZFQUE2RTtRQUM3RSxzRUFBc0U7UUFDdEU7SUFDRjtJQUVBLElBQUlHLGtCQUFrQlosU0FBU1UsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBQ2xELElBQUksQ0FBQ08sbUJBQW1CQSxvQkFBb0JILHlCQUF5QjtRQUNuRUcsa0JBQWtCLElBQUlDLElBQUlKO1FBQzFCVCxTQUFTVSxjQUFjLENBQUNJLEdBQUcsQ0FBQ1Qsa0JBQWtCTztJQUNoRDtJQUVBLGlEQUFpRDtJQUNqRCxJQUFJVCxhQUFhO1FBQ2ZTLGdCQUFnQkcsTUFBTSxDQUFDUjtRQUN2QjtJQUNGO0lBRUEsTUFBTVMseUJBQXlCUCx3QkFBd0JFLEdBQUcsQ0FBQ0o7SUFDM0QsSUFBSVUsaUJBQWlCTCxnQkFBZ0JELEdBQUcsQ0FBQ0o7SUFFekMsSUFBSSxDQUFDVSxrQkFBa0IsQ0FBQ0Qsd0JBQXdCO1FBQzlDLDZFQUE2RTtRQUM3RSxzRUFBc0U7UUFDdEU7SUFDRjtJQUVBLElBQUlDLG1CQUFtQkQsd0JBQXdCO1FBQzdDQyxpQkFBaUI7WUFDZkMsVUFBVUQsZUFBZUMsUUFBUTtZQUNqQ0MsS0FBS0YsZUFBZUUsR0FBRztZQUN2QkMsYUFBYUgsZUFBZUcsV0FBVztZQUN2Q0MsTUFBTUosZUFBZUksSUFBSTtZQUN6QkMsY0FBY0wsZUFBZUssWUFBWTtZQUN6Q1osZ0JBQWdCLElBQUlHLElBQUlJLGVBQWVQLGNBQWM7UUFDdkQ7UUFDQUUsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVVVO0lBQ2hDO0lBRUFsQixzQ0FDRWtCLGdCQUNBRCx3QkFDQU8sQ0FBQUEsR0FBQUEsbUJBQUFBLHdCQUFBQSxFQUF5QnJCO0FBRTdCIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxpbnZhbGlkYXRlLWNhY2hlLWJlbG93LWZsaWdodC1zZWdtZW50cGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRTZWdtZW50UGF0aCB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuaW1wb3J0IHsgZ2V0TmV4dEZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcblxuLyoqXG4gKiBGaWxsIGNhY2hlIHVwIHRvIHRoZSBlbmQgb2YgdGhlIGZsaWdodFNlZ21lbnRQYXRoLCBpbnZhbGlkYXRpbmcgYW55dGhpbmcgYmVsb3cgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKFxuICBuZXdDYWNoZTogQ2FjaGVOb2RlLFxuICBleGlzdGluZ0NhY2hlOiBDYWNoZU5vZGUsXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxuKTogdm9pZCB7XG4gIGNvbnN0IGlzTGFzdEVudHJ5ID0gZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoIDw9IDJcbiAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0U2VnbWVudFBhdGhcblxuICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnQpXG5cbiAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPVxuICAgIGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG5cbiAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcClcbiAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKVxuICB9XG5cbiAgLy8gSW4gY2FzZSBvZiBsYXN0IGVudHJ5IGRvbid0IGNvcHkgZnVydGhlciBkb3duLlxuICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICBjaGlsZFNlZ21lbnRNYXAuZGVsZXRlKGNhY2hlS2V5KVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcbiAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcblxuICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgIGxhenlEYXRhOiBjaGlsZENhY2hlTm9kZS5sYXp5RGF0YSxcbiAgICAgIHJzYzogY2hpbGRDYWNoZU5vZGUucnNjLFxuICAgICAgcHJlZmV0Y2hSc2M6IGNoaWxkQ2FjaGVOb2RlLnByZWZldGNoUnNjLFxuICAgICAgaGVhZDogY2hpbGRDYWNoZU5vZGUuaGVhZCxcbiAgICAgIHByZWZldGNoSGVhZDogY2hpbGRDYWNoZU5vZGUucHJlZmV0Y2hIZWFkLFxuICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpLFxuICAgIH0gYXMgQ2FjaGVOb2RlXG4gICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpXG4gIH1cblxuICBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKFxuICAgIGNoaWxkQ2FjaGVOb2RlLFxuICAgIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsXG4gICAgZ2V0TmV4dEZsaWdodFNlZ21lbnRQYXRoKGZsaWdodFNlZ21lbnRQYXRoKVxuICApXG59XG4iXSwibmFtZXMiOlsiaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiaXNMYXN0RW50cnkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZGVsZXRlIiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"invalidateCacheByRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return invalidateCacheByRouterState;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-by-router-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ludmFsaWRhdGUtY2FjaGUtYnktcm91dGVyLXN0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0VBT2dCQTs7O2VBQUFBOzs7a0RBTHFCO0FBSzlCLFNBQVNBLDZCQUNkQyxRQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLFdBQThCO0lBRTlCLHVGQUF1RjtJQUN2RixJQUFLLE1BQU1DLE9BQU9ELFdBQVcsQ0FBQyxFQUFFLENBQUU7UUFDaEMsTUFBTUUsMEJBQTBCRixXQUFXLENBQUMsRUFBRSxDQUFDQyxJQUFJLENBQUMsRUFBRTtRQUN0RCxNQUFNRSxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQUFBLEVBQXFCRjtRQUN0QyxNQUFNRyxrQ0FDSk4sY0FBY08sY0FBYyxDQUFDQyxHQUFHLENBQUNOO1FBQ25DLElBQUlJLGlDQUFpQztZQUNuQyxJQUFJRyx5QkFBeUIsSUFBSUMsSUFBSUo7WUFDckNHLHVCQUF1QkUsTUFBTSxDQUFDUDtZQUM5QkwsU0FBU1EsY0FBYyxDQUFDSyxHQUFHLENBQUNWLEtBQUtPO1FBQ25DO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcaW52YWxpZGF0ZS1jYWNoZS1ieS1yb3V0ZXItc3RhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcblxuLyoqXG4gKiBJbnZhbGlkYXRlIGNhY2hlIG9uZSBsZXZlbCBkb3duIGZyb20gdGhlIHJvdXRlciBzdGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUoXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiB2b2lkIHtcbiAgLy8gUmVtb3ZlIHNlZ21lbnQgdGhhdCB3ZSBnb3QgZGF0YSBmb3Igc28gdGhhdCBpdCBpcyBmaWxsZWQgaW4gZHVyaW5nIHJlbmRlcmluZyBvZiByc2MuXG4gIGZvciAoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKSB7XG4gICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldWzBdXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSlcbiAgICBjb25zdCBleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlID1cbiAgICAgIGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSlcbiAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSkge1xuICAgICAgbGV0IHBhcmFsbGVsUm91dGVDYWNoZU5vZGUgPSBuZXcgTWFwKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpXG4gICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmRlbGV0ZShjYWNoZUtleSlcbiAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwia2V5Iiwic2VnbWVudEZvclBhcmFsbGVsUm91dGUiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwicGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSIsIk1hcCIsImRlbGV0ZSIsInNldCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isNavigatingToNewRootLayout\", ({\n    enumerable: true,\n    get: function() {\n        return isNavigatingToNewRootLayout;\n    }\n}));\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7K0RBRWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSw0QkFDZEMsV0FBOEIsRUFDOUJDLFFBQTJCO0lBRTNCLG1CQUFtQjtJQUNuQixNQUFNQyxxQkFBcUJGLFdBQVcsQ0FBQyxFQUFFO0lBQ3pDLE1BQU1HLGtCQUFrQkYsUUFBUSxDQUFDLEVBQUU7SUFFbkMsMkZBQTJGO0lBQzNGLDREQUE0RDtJQUM1RCx1SUFBdUk7SUFDdkksSUFBSUcsTUFBTUMsT0FBTyxDQUFDSCx1QkFBdUJFLE1BQU1DLE9BQU8sQ0FBQ0Ysa0JBQWtCO1FBQ3ZFLHNIQUFzSDtRQUN0SCx1R0FBdUc7UUFDdkcsSUFDRUQsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxJQUM1Q0Qsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxFQUM1QztZQUNBLE9BQU87UUFDVDtJQUNGLE9BQU8sSUFBSUQsdUJBQXVCQyxpQkFBaUI7UUFDakQsT0FBTztJQUNUO0lBRUEsaUNBQWlDO0lBQ2pDLElBQUlILFdBQVcsQ0FBQyxFQUFFLEVBQUU7UUFDbEIsNEVBQTRFO1FBQzVFLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDLEVBQUU7SUFDckI7SUFDQSxvRUFBb0U7SUFDcEUsSUFBSUEsUUFBUSxDQUFDLEVBQUUsRUFBRTtRQUNmLE9BQU87SUFDVDtJQUNBLDRHQUE0RztJQUM1RywyRkFBMkY7SUFDM0YsbURBQW1EO0lBQ25ELE1BQU1LLG1CQUFtQkMsT0FBT0MsTUFBTSxDQUFDUixXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtJQUN6RCxNQUFNUyxnQkFBZ0JGLE9BQU9DLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDbkQsSUFBSSxDQUFDSyxvQkFBb0IsQ0FBQ0csZUFBZSxPQUFPO0lBQ2hELE9BQU9WLDRCQUE0Qk8sa0JBQWtCRztBQUN2RCIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KFxuICBjdXJyZW50VHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5leHRUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogYm9vbGVhbiB7XG4gIC8vIENvbXBhcmUgc2VnbWVudHNcbiAgY29uc3QgY3VycmVudFRyZWVTZWdtZW50ID0gY3VycmVudFRyZWVbMF1cbiAgY29uc3QgbmV4dFRyZWVTZWdtZW50ID0gbmV4dFRyZWVbMF1cblxuICAvLyBJZiBhbnkgc2VnbWVudCBpcyBkaWZmZXJlbnQgYmVmb3JlIHdlIGZpbmQgdGhlIHJvb3QgbGF5b3V0LCB0aGUgcm9vdCBsYXlvdXQgaGFzIGNoYW5nZWQuXG4gIC8vIEUuZy4gL3NhbWUvKGdyb3VwMSkvbGF5b3V0LmpzIC0+IC9zYW1lLyhncm91cDIpL2xheW91dC5qc1xuICAvLyBGaXJzdCBzZWdtZW50IGlzICdzYW1lJyBmb3IgYm90aCwga2VlcCBsb29raW5nLiAoZ3JvdXAxKSBjaGFuZ2VkIHRvIChncm91cDIpIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgd2FzIGZvdW5kLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFRyZWVTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KG5leHRUcmVlU2VnbWVudCkpIHtcbiAgICAvLyBDb21wYXJlIGR5bmFtaWMgcGFyYW0gbmFtZSBhbmQgdHlwZSBidXQgaWdub3JlIHRoZSB2YWx1ZSwgZGlmZmVyZW50IHZhbHVlcyB3b3VsZCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHJvb3QgbGF5b3V0XG4gICAgLy8gL1tuYW1lXSAtIC9zbHVnMSBhbmQgL3NsdWcyLCBib3RoIHZhbHVlcyAoc2x1ZzEgJiBzbHVnMikgc3RpbGwgaGFzIHRoZSBzYW1lIGxheW91dCAvW25hbWVdL2xheW91dC5qc1xuICAgIGlmIChcbiAgICAgIGN1cnJlbnRUcmVlU2VnbWVudFswXSAhPT0gbmV4dFRyZWVTZWdtZW50WzBdIHx8XG4gICAgICBjdXJyZW50VHJlZVNlZ21lbnRbMl0gIT09IG5leHRUcmVlU2VnbWVudFsyXVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudFRyZWVTZWdtZW50ICE9PSBuZXh0VHJlZVNlZ21lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gQ3VycmVudCB0cmVlIHJvb3QgbGF5b3V0IGZvdW5kXG4gIGlmIChjdXJyZW50VHJlZVs0XSkge1xuICAgIC8vIElmIHRoZSBuZXh0IHRyZWUgZG9lc24ndCBoYXZlIHRoZSByb290IGxheW91dCBmbGFnLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICByZXR1cm4gIW5leHRUcmVlWzRdXG4gIH1cbiAgLy8gQ3VycmVudCB0cmVlIGRpZG4ndCBoYXZlIGl0cyByb290IGxheW91dCBoZXJlLCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgaWYgKG5leHRUcmVlWzRdKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICAvLyBXZSBjYW4ndCBhc3N1bWUgaXQncyBgcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW5gIGhlcmUgaW4gY2FzZSB0aGUgcm9vdCBsYXlvdXQgaXMgYGFwcC9Ac29tZXRoaW5nL2xheW91dC5qc2BcbiAgLy8gQnV0IGl0J3Mgbm90IHBvc3NpYmxlIHRvIGJlIG1vcmUgdGhhbiBvbmUgcGFyYWxsZWxSb3V0ZXMgYmVmb3JlIHRoZSByb290IGxheW91dCBpcyBmb3VuZFxuICAvLyBUT0RPLUFQUDogY2hhbmdlIHRvIHRyYXZlcnNlIGFsbCBwYXJhbGxlbCByb3V0ZXNcbiAgY29uc3QgY3VycmVudFRyZWVDaGlsZCA9IE9iamVjdC52YWx1ZXMoY3VycmVudFRyZWVbMV0pWzBdXG4gIGNvbnN0IG5leHRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKG5leHRUcmVlWzFdKVswXVxuICBpZiAoIWN1cnJlbnRUcmVlQ2hpbGQgfHwgIW5leHRUcmVlQ2hpbGQpIHJldHVybiB0cnVlXG4gIHJldHVybiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWVDaGlsZCwgbmV4dFRyZWVDaGlsZClcbn1cbiJdLCJuYW1lcyI6WyJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjdXJyZW50VHJlZSIsIm5leHRUcmVlIiwiY3VycmVudFRyZWVTZWdtZW50IiwibmV4dFRyZWVTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiY3VycmVudFRyZWVDaGlsZCIsIk9iamVjdCIsInZhbHVlcyIsIm5leHRUcmVlQ2hpbGQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(ssr)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ./is-navigating-to-new-root-layout */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst MPA_NAVIGATION_TASK = {\n    route: null,\n    node: null,\n    dynamicRequestTree: null,\n    children: null\n};\nfunction startPPRNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {\n    const segmentPath = [];\n    return updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);\n}\nfunction updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    if (!didFindRootLayout) {\n        // We're currently traversing the part of the tree that was also part of\n        // the previous route. If we discover a root layout, then we don't need to\n        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n        const isRootLayout = newRouterState[4] === true;\n        if (isRootLayout) {\n            // Found a matching root layout.\n            didFindRootLayout = true;\n        }\n    }\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server â€” for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let needsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n    // end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            newSegmentChild\n        ]);\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment â€” a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation â€” but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else if (isSamePageNavigation && // Check if this is a page segment.\n        // TODO: We're not consistent about how we do this check. Some places\n        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n        // check if there any any children, which is why I'm doing it here. We\n        // should probably encode an empty children set as `null` though. Either\n        // way, we should update all the checks to be consistent.\n        Object.keys(newRouterStateChild[1]).length === 0) {\n            // We special case navigations to the exact same URL as the current\n            // location. It's a common UI pattern for apps to refresh when you click a\n            // link to the current page. So when this happens, we refresh the dynamic\n            // data in the page segments.\n            //\n            // Note that this does not apply if the any part of the hash or search\n            // query has changed. This might feel a bit weird but it makes more sense\n            // when you consider that the way to trigger this behavior is to click\n            // the same link multiple times.\n            //\n            // TODO: We should probably refresh the *entire* route when this case\n            // occurs, not just the page segments. Essentially treating it the same as\n            // a refresh() triggered by an action, which is the more explicit way of\n            // modeling the UI pattern described above.\n            //\n            // Also note that this only refreshes the dynamic data, not static/\n            // cached data. If the page segment is fully static and prefetched, the\n            // request is skipped. (This is also how refresh() works.)\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees. Recursively update\n                // the children.\n                taskChild = updateCacheNodeOnNavigation(navigatedAt, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);\n            } else {\n                // There's no existing Cache Node for this segment. Switch to the\n                // \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        }\n        if (taskChild !== null) {\n            // Recursively propagate up the child tasks.\n            if (taskChild.route === null) {\n                // One of the child tasks discovered a change to the root layout.\n                // Immediately unwind from this recursive traversal.\n                return MPA_NAVIGATION_TASK;\n            }\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            const taskChildRoute = taskChild.route;\n            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n            }\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        navigatedAt\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction beginRenderingNewRouteTree(navigatedAt, oldRouterState, newRouterState, existingCacheNode, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    if (!didFindRootLayout) {\n        // The route tree changed before we reached a layout. (The highest-level\n        // layout in a route tree is referred to as the \"root\" layout.) This could\n        // mean that we're navigating between two different root layouts. When this\n        // happens, we perform a full-page (MPA-style) navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just because\n        // we're re-rendering a segment outside of the root layout does not mean we\n        // should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments are\n        // considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is unchanged.\n        // In the common case, this branch is skipped completely.\n        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {\n            // The root layout changed. Perform a full-page navigation.\n            return MPA_NAVIGATION_TASK;\n        }\n    }\n    return createCacheNodeOnNavigation(navigatedAt, newRouterState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n}\nfunction createCacheNodeOnNavigation(navigatedAt, routerState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Same traversal as updateCacheNodeNavigation, but we switch to this path\n    // once we reach the part of the tree that was not in the previous route. We\n    // don't need to diff against the old tree, we just need to create a new one.\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const routerStateChildren = routerState[1];\n    const isLeafSegment = Object.keys(routerStateChildren).length === 0;\n    // Even we're rendering inside the \"new\" part of the target tree, we may have\n    // a locally cached segment that we can reuse. This may come from either 1)\n    // the CacheNode tree, which lives in React state and is populated by previous\n    // navigations; or 2) the prefetch cache, which is a separate cache that is\n    // populated by prefetches.\n    let rsc;\n    let loading;\n    let head;\n    let cacheNodeNavigatedAt;\n    if (existingCacheNode !== undefined && // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + _prefetchcacheutils.DYNAMIC_STALETIME_MS > navigatedAt) {\n        // We have an existing CacheNode for this segment, and it's not stale. We\n        // should reuse it rather than request a new one.\n        rsc = existingCacheNode.rsc;\n        loading = existingCacheNode.loading;\n        head = existingCacheNode.head;\n        // Don't update the navigatedAt timestamp, since we're reusing stale data.\n        cacheNodeNavigatedAt = existingCacheNode.navigatedAt;\n    } else if (prefetchData !== null) {\n        // There's no existing CacheNode for this segment, but we do have prefetch\n        // data. If the prefetch data is fully static (i.e. does not contain any\n        // dynamic holes), we don't need to request it from the server.\n        rsc = prefetchData[1];\n        loading = prefetchData[3];\n        head = isLeafSegment ? possiblyPartialPrefetchHead : null;\n        // Even though we're accessing the data from the prefetch cache, this is\n        // conceptually a new segment, not a reused one. So we should update the\n        // navigatedAt timestamp.\n        cacheNodeNavigatedAt = navigatedAt;\n        const isPrefetchRscPartial = prefetchData[4];\n        if (isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)\n        isPrefetchHeadPartial && isLeafSegment) {\n            // We only have partial data from this segment. Like missing segments, we\n            // must request the full data from the server.\n            return spawnPendingTask(navigatedAt, routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n        } else {\n        // The prefetch data is fully static, so we can omit it from the\n        // navigation request.\n        }\n    } else {\n        // There's no prefetch for this segment. Everything from this point will be\n        // requested from the server, even if there are static children below it.\n        // Create a terminal task node that will later be fulfilled by\n        // server response.\n        return spawnPendingTask(navigatedAt, routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    // We already have a full segment we can render, so we don't need to request a\n    // new one from the server. Keep traversing down the tree until we reach\n    // something that requires a dynamic request.\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    const taskChildren = new Map();\n    const existingCacheNodeChildren = existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null;\n    const cacheNodeChildren = new Map(existingCacheNodeChildren);\n    let dynamicRequestTreeChildren = {};\n    let needsDynamicRequest = false;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    } else {\n        for(let parallelRouteKey in routerStateChildren){\n            const routerStateChild = routerStateChildren[parallelRouteKey];\n            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n            const existingSegmentMapChild = existingCacheNodeChildren !== null ? existingCacheNodeChildren.get(parallelRouteKey) : undefined;\n            const segmentChild = routerStateChild[0];\n            const segmentPathChild = segmentPath.concat([\n                parallelRouteKey,\n                segmentChild\n            ]);\n            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n            const existingCacheNodeChild = existingSegmentMapChild !== undefined ? existingSegmentMapChild.get(segmentKeyChild) : undefined;\n            const taskChild = createCacheNodeOnNavigation(navigatedAt, routerStateChild, existingCacheNodeChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n            taskChildren.set(parallelRouteKey, taskChild);\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;\n            }\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map();\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    return {\n        // Since we're inside a new route tree, unlike the\n        // `updateCacheNodeOnNavigation` path, the router state on the children\n        // tasks is always the same as the router state we pass in. So we don't need\n        // to clone/modify it.\n        route: routerState,\n        node: {\n            lazyData: null,\n            // Since this segment is already full, we don't need to use the\n            // `prefetchRsc` field.\n            rsc,\n            prefetchRsc: null,\n            head,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: cacheNodeChildren,\n            navigatedAt: cacheNodeNavigatedAt\n        },\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Create a task that will later be fulfilled by data from the server.\n    // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n    // this to the server so it knows where to start rendering.\n    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);\n    dynamicRequestTree[3] = 'refetch';\n    const newTask = {\n        route: routerState,\n        // Corresponds to the part of the route that will be rendered on the server.\n        node: createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),\n        // Because this is non-null, and it gets propagated up through the parent\n        // tasks, the root task will know that it needs to perform a server request.\n        dynamicRequestTree,\n        children: null\n    };\n    return newTask;\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        dynamicRequestTree: null,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((param)=>{\n        let { flightData } = param;\n        if (typeof flightData === 'string') {\n            // Happens when navigating to page in `pages` from `app`. We shouldn't\n            // get here because should have already handled this during\n            // the prefetch.\n            return;\n        }\n        for (const normalizedFlightData of flightData){\n            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;\n            if (!dynamicData) {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    if (task.dynamicRequestTree === null) {\n        // Everything in this subtree is already complete. Bail out.\n        return;\n    }\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Set this to null to indicate that this task is now complete.\n            task.dynamicRequestTree = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[2];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            segmentChild\n        ]);\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(navigatedAt, routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    }\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : [\n            null,\n            null\n        ],\n        // TODO: Technically, a loading boundary could contain dynamic data. We must\n        // have separate `loading` and `prefetchLoading` fields to handle this, like\n        // we do for the segment data and head.\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        navigatedAt\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety â€” it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[2];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[1];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Set this to null to indicate that this task is now complete.\n    task.dynamicRequestTree = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [\n            null,\n            null\n        ],\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: oldCacheNode.loading,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        navigatedAt: oldCacheNode.navigatedAt\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Bwci1uYXZpZ2F0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUEwa0NnQkEsU0FBUztlQUFUQTs7SUExVkFDLHVCQUF1QjtlQUF2QkE7O0lBdnBCQUMsa0JBQWtCO2VBQWxCQTs7SUE2akNBQyxvQ0FBb0M7ZUFBcENBOzs7cUNBem9Db0I7MkNBQ1A7a0RBQ1E7eURBRU87Z0RBQ1A7QUFpQ3JDLE1BQU1DLHNCQUF5QztJQUM3Q0MsT0FBTztJQUNQQyxNQUFNO0lBQ05DLG9CQUFvQjtJQUNwQkMsVUFBVTtBQUNaO0FBaUNPLFNBQVNOLG1CQUNkTyxXQUFtQixFQUNuQkMsWUFBdUIsRUFDdkJDLGNBQWlDLEVBQ2pDQyxjQUFpQyxFQUNqQ0MsWUFBc0MsRUFDdENDLFlBQTZCLEVBQzdCQyxxQkFBOEIsRUFDOUJDLG9CQUE2QixFQUM3QkMsd0JBQWtEO0lBRWxELE1BQU1DLGNBQXdDLEVBQUU7SUFDaEQsT0FBT0MsNEJBQ0xWLGFBQ0FDLGNBQ0FDLGdCQUNBQyxnQkFDQSxPQUNBQyxjQUNBQyxjQUNBQyx1QkFDQUMsc0JBQ0FFLGFBQ0FEO0FBRUo7QUFFQSxTQUFTRSw0QkFDUFYsV0FBbUIsRUFDbkJDLFlBQXVCLEVBQ3ZCQyxjQUFpQyxFQUNqQ0MsY0FBaUMsRUFDakNRLGlCQUEwQixFQUMxQlAsWUFBc0MsRUFDdENDLFlBQTZCLEVBQzdCQyxxQkFBOEIsRUFDOUJDLG9CQUE2QixFQUM3QkUsV0FBOEIsRUFDOUJELHdCQUFrRDtJQUVsRCwwREFBMEQ7SUFDMUQsTUFBTUkseUJBQXlCVixjQUFjLENBQUMsRUFBRTtJQUNoRCxNQUFNVyx5QkFBeUJWLGNBQWMsQ0FBQyxFQUFFO0lBQ2hELE1BQU1XLHVCQUF1QlYsaUJBQWlCLE9BQU9BLFlBQVksQ0FBQyxFQUFFLEdBQUc7SUFFdkUsSUFBSSxDQUFDTyxtQkFBbUI7UUFDdEIsd0VBQXdFO1FB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OEgsb0JBQW9CbEksYUFBYUksWUFBWSxHQUFHO1lBQUM7WUFBTTtTQUFLO1FBQzFFaUQsYUFBYTZFLG9CQUFvQmxJLGFBQWFxRCxXQUFXLEdBQUc7UUFDNURFLFNBQVN2RCxhQUFhdUQsT0FBTztRQUU3QixrREFBa0Q7UUFDbER2QyxnQkFBZ0JpSDtRQUVoQmxJLGFBQWFDLGFBQWFELFdBQVc7SUFDdkM7QUFDRjtBQUVBLE1BQU1xSSxXQUFXQztBQThCakIsOEVBQThFO0FBQzlFLGdGQUFnRjtBQUNoRiw4RUFBOEU7QUFDOUUsbUVBQW1FO0FBQ25FLFNBQVNSLGNBQWNTLEtBQVU7SUFDL0IsT0FBT0EsU0FBU0EsTUFBTUMsR0FBRyxLQUFLSDtBQUNoQztBQUVBLFNBQVN2QjtJQUNQLElBQUlpQjtJQUNKLElBQUlFO0lBQ0osTUFBTVEsYUFBYSxJQUFJQyxRQUF5QixDQUFDQyxLQUFLQztRQUNwRGIsVUFBVVk7UUFDVlYsU0FBU1c7SUFDWDtJQUNBSCxXQUFXTCxNQUFNLEdBQUc7SUFDcEJLLFdBQVdWLE9BQU8sR0FBRyxDQUFDUTtRQUNwQixJQUFJRSxXQUFXTCxNQUFNLEtBQUssV0FBVztZQUNuQyxNQUFNUyxlQUFxQ0o7WUFDM0NJLGFBQWFULE1BQU0sR0FBRztZQUN0QlMsYUFBYU4sS0FBSyxHQUFHQTtZQUNyQlIsUUFBUVE7UUFDVjtJQUNGO0lBQ0FFLFdBQVdSLE1BQU0sR0FBRyxDQUFDbEM7UUFDbkIsSUFBSTBDLFdBQVdMLE1BQU0sS0FBSyxXQUFXO1lBQ25DLE1BQU1VLGNBQW1DTDtZQUN6Q0ssWUFBWVYsTUFBTSxHQUFHO1lBQ3JCVSxZQUFZQyxNQUFNLEdBQUdoRDtZQUNyQmtDLE9BQU9sQztRQUNUO0lBQ0Y7SUFDQTBDLFdBQVdELEdBQUcsR0FBR0g7SUFDakIsT0FBT0k7QUFDVCIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccHByLW5hdmlnYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgQ2FjaGVOb2RlU2VlZERhdGEsXG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIENhY2hlTm9kZSxcbiAgQ2hpbGRTZWdtZW50TWFwLFxuICBIZWFkRGF0YSxcbiAgTG9hZGluZ01vZHVsZURhdGEsXG4gIFJlYWR5Q2FjaGVOb2RlLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBtYXRjaFNlZ21lbnQgfSBmcm9tICcuLi9tYXRjaC1zZWdtZW50cydcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB0eXBlIHsgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB7IERZTkFNSUNfU1RBTEVUSU1FX01TIH0gZnJvbSAnLi9wcmVmZXRjaC1jYWNoZS11dGlscydcblxuLy8gVGhpcyBpcyB5ZXQgYW5vdGhlciB0cmVlIHR5cGUgdGhhdCBpcyB1c2VkIHRvIHRyYWNrIHBlbmRpbmcgcHJvbWlzZXMgdGhhdFxuLy8gbmVlZCB0byBiZSBmdWxmaWxsZWQgb25jZSB0aGUgZHluYW1pYyBkYXRhIGlzIHJlY2VpdmVkLiBUaGUgdGVybWluYWwgbm9kZXMgb2Zcbi8vIHRoaXMgdHJlZSByZXByZXNlbnQgdGhlIG5ldyBDYWNoZSBOb2RlIHRyZWVzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyB0aGlzXG4vLyByZXF1ZXN0LiBXZSBjYW4ndCB1c2UgdGhlIENhY2hlIE5vZGUgdHJlZSBvciBSb3V0ZSBTdGF0ZSB0cmVlIGRpcmVjdGx5XG4vLyBiZWNhdXNlIHRob3NlIGluY2x1ZGUgcmV1c2VkIG5vZGVzLCB0b28uIFRoaXMgdHJlZSBpcyBkaXNjYXJkZWQgYXMgc29vbiBhc1xuLy8gdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UgaXMgcmVjZWl2ZWQuXG50eXBlIFNQQU5hdmlnYXRpb25UYXNrID0ge1xuICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRyZWUgdGhhdCB0aGlzIFRhc2sgcmVwcmVzZW50cy5cbiAgcm91dGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIC8vIFRoZSBDYWNoZU5vZGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgdHJlZSB0aGF0IHRoaXMgVGFzayByZXByZXNlbnRzLiBJZlxuICAvLyBgY2hpbGRyZW5gIGlzIG51bGwgKGkuZS4gaWYgdGhpcyBpcyBhIHRlcm1pbmFsIHRhc2sgbm9kZSksIHRoZW4gYG5vZGVgXG4gIC8vIHJlcHJlc2VudHMgYSBicmFuZCBuZXcgQ2FjaGUgTm9kZSB0cmVlLCB3aGljaCB3YXkgb3IgbWF5IG5vdCBuZWVkIHRvIGJlXG4gIC8vIGZpbGxlZCB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gIG5vZGU6IENhY2hlTm9kZSB8IG51bGxcbiAgLy8gVGhlIHRyZWUgc2VudCB0byB0aGUgc2VydmVyIGR1cmluZyB0aGUgZHluYW1pYyByZXF1ZXN0LiBUaGlzIGlzIHRoZVxuICAvLyBzYW1lIGFzIGByb3V0ZWAsIGV4Y2VwdCB3aXRoIHRoZSBgcmVmZXRjaGAgbWFya2VyIHNldCBvbiBkeW5hbWljIHNlZ21lbnRzLlxuICAvLyBJZiBhbGwgdGhlIHNlZ21lbnRzIGFyZSBzdGF0aWMsIHRoZW4gdGhpcyB3aWxsIGJlIG51bGwsIGFuZCBubyBzZXJ2ZXJcbiAgLy8gcmVxdWVzdCBpcyByZXF1aXJlZC5cbiAgZHluYW1pY1JlcXVlc3RUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IG51bGxcbiAgY2hpbGRyZW46IE1hcDxzdHJpbmcsIFNQQU5hdmlnYXRpb25UYXNrPiB8IG51bGxcbn1cblxuLy8gQSBzcGVjaWFsIHR5cGUgdXNlZCB0byBiYWlsIG91dCBhbmQgdHJpZ2dlciBhIGZ1bGwtcGFnZSBuYXZpZ2F0aW9uLlxudHlwZSBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgLy8gTVBBIHRhc2tzIGFyZSBkaXN0aW5ndWlzZWQgZnJvbSBTUEEgdGFza3MgYnkgaGF2aW5nIGEgbnVsbCBgcm91dGVgLlxuICByb3V0ZTogbnVsbFxuICBub2RlOiBudWxsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbFxuICBjaGlsZHJlbjogbnVsbFxufVxuXG5jb25zdCBNUEFfTkFWSUdBVElPTl9UQVNLOiBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgcm91dGU6IG51bGwsXG4gIG5vZGU6IG51bGwsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgY2hpbGRyZW46IG51bGwsXG59XG5cbmV4cG9ydCB0eXBlIFRhc2sgPSBTUEFOYXZpZ2F0aW9uVGFzayB8IE1QQU5hdmlnYXRpb25UYXNrXG5cbi8vIENyZWF0ZXMgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIChpLmUuIGNvcHktb24td3JpdGUpIHRoYXQgcmVwcmVzZW50cyB0aGVcbi8vIG9wdGltaXN0aWMgcmVzdWx0IG9mIGEgbmF2aWdhdGlvbiwgdXNpbmcgYm90aCB0aGUgY3VycmVudCBDYWNoZSBOb2RlIHRyZWUgYW5kXG4vLyBkYXRhIHRoYXQgd2FzIHByZWZldGNoZWQgcHJpb3IgdG8gbmF2aWdhdGlvbi5cbi8vXG4vLyBBdCB0aGUgbW9tZW50IHdlIGNhbGwgdGhpcyBmdW5jdGlvbiwgd2UgaGF2ZW4ndCB5ZXQgcmVjZWl2ZWQgdGhlIG5hdmlnYXRpb25cbi8vIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci4gSXQgY291bGQgc2VuZCBiYWNrIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudFxuLy8gZnJvbSB0aGUgdHJlZSB0aGF0IHdhcyBwcmVmZXRjaGVkIOKAlCBkdWUgdG8gcmV3cml0ZXMsIGRlZmF1bHQgcm91dGVzLCBwYXJhbGxlbFxuLy8gcm91dGVzLCBldGMuXG4vL1xuLy8gQnV0IGluIG1vc3QgY2FzZXMsIGl0IHdpbGwgcmV0dXJuIHRoZSBzYW1lIHRyZWUgdGhhdCB3ZSBwcmVmZXRjaGVkLCBqdXN0IHdpdGhcbi8vIHRoZSBkeW5hbWljIGhvbGVzIGZpbGxlZCBpbi4gU28gd2Ugb3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoaXMgd2lsbCBoYXBwZW4sXG4vLyBhbmQgYWNjZXB0IHRoYXQgdGhlIHJlYWwgcmVzdWx0IGNvdWxkIGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudC5cbi8vXG4vLyBXZSdsbCByZXVzZSBhbnl0aGluZyB0aGF0IHdhcyBhbHJlYWR5IGluIHRoZSBwcmV2aW91cyB0cmVlLCBzaW5jZSB0aGF0J3Mgd2hhdFxuLy8gdGhlIHNlcnZlciBkb2VzLlxuLy9cbi8vIE5ldyBzZWdtZW50cyAob25lcyB0aGF0IGRvbid0IGFwcGVhciBpbiB0aGUgb2xkIHRyZWUpIGFyZSBhc3NpZ25lZCBhblxuLy8gdW5yZXNvbHZlZCBwcm9taXNlLiBUaGUgZGF0YSBmb3IgdGhlc2UgcHJvbWlzZXMgd2lsbCBiZSBmdWxmaWxsZWQgbGF0ZXIsIHdoZW5cbi8vIHRoZSBuYXZpZ2F0aW9uIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuLy9cbi8vIFRoZSB0cmVlIGNhbiBiZSByZW5kZXJlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyBjcmVhdGVkICh0aGF0J3Mgd2h5IHRoaXMgaXNcbi8vIGEgc3luY2hyb25vdXMgZnVuY3Rpb24pLiBBbnkgbmV3IHRyZWVzIHRoYXQgZG8gbm90IGhhdmUgcHJlZmV0Y2ggZGF0YSB3aWxsXG4vLyBzdXNwZW5kIGR1cmluZyByZW5kZXJpbmcsIHVudGlsIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtcyBpbi5cbi8vXG4vLyBSZXR1cm5zIGEgVGFzayBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGJvdGggdGhlIHVwZGF0ZWQgQ2FjaGUgTm9kZSBhbmQgYSBwYXRoXG4vLyB0byB0aGUgcGVuZGluZyBzdWJ0cmVlcyB0aGF0IG5lZWQgdG8gYmUgcmVzb2x2ZWQgYnkgdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UuXG4vL1xuLy8gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRoZXJlIHdlcmUgbm8gY2hhbmdlcywgYW5kIHRoZSBwcmV2aW91cyB0cmVlXG4vLyBjYW4gYmUgcmV1c2VkIHdpdGhvdXQgaW5pdGlhdGluZyBhIHNlcnZlciByZXF1ZXN0LlxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UFBSTmF2aWdhdGlvbihcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgb2xkQ2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgbmV3Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgaXNTYW1lUGFnZU5hdmlnYXRpb246IGJvb2xlYW4sXG4gIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+XG4pOiBUYXNrIHwgbnVsbCB7XG4gIGNvbnN0IHNlZ21lbnRQYXRoOiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD4gPSBbXVxuICByZXR1cm4gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgIG5hdmlnYXRlZEF0LFxuICAgIG9sZENhY2hlTm9kZSxcbiAgICBvbGRSb3V0ZXJTdGF0ZSxcbiAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICBmYWxzZSxcbiAgICBwcmVmZXRjaERhdGEsXG4gICAgcHJlZmV0Y2hIZWFkLFxuICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICBpc1NhbWVQYWdlTmF2aWdhdGlvbixcbiAgICBzZWdtZW50UGF0aCxcbiAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICBvbGRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZGlkRmluZFJvb3RMYXlvdXQ6IGJvb2xlYW4sXG4gIHByZWZldGNoRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBwcmVmZXRjaEhlYWQ6IEhlYWREYXRhIHwgbnVsbCxcbiAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsOiBib29sZWFuLFxuICBpc1NhbWVQYWdlTmF2aWdhdGlvbjogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB8IG51bGwge1xuICAvLyBEaWZmIHRoZSBvbGQgYW5kIG5ldyB0cmVlcyB0byByZXVzZSB0aGUgc2hhcmVkIGxheW91dHMuXG4gIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSBvbGRSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gbmV3Um91dGVyU3RhdGVbMV1cbiAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsXG5cbiAgaWYgKCFkaWRGaW5kUm9vdExheW91dCkge1xuICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB0cmF2ZXJzaW5nIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIGFsc28gcGFydCBvZlxuICAgIC8vIHRoZSBwcmV2aW91cyByb3V0ZS4gSWYgd2UgZGlzY292ZXIgYSByb290IGxheW91dCwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi4gU2VlIGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlIGZvciBjb250ZXh0LlxuICAgIGNvbnN0IGlzUm9vdExheW91dCA9IG5ld1JvdXRlclN0YXRlWzRdID09PSB0cnVlXG4gICAgaWYgKGlzUm9vdExheW91dCkge1xuICAgICAgLy8gRm91bmQgYSBtYXRjaGluZyByb290IGxheW91dC5cbiAgICAgIGRpZEZpbmRSb290TGF5b3V0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9sZFBhcmFsbGVsUm91dGVzID0gb2xkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG5cbiAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgc2V0IG9mIHNlZ21lbnQgY2hpbGRyZW4sIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWN0aXZlIGluXG4gIC8vIHRoZSBuZXcgdHJlZS5cbiAgLy8gVE9ETzogV2UgY3VycmVudGx5IHJldGFpbiBhbGwgdGhlIGluYWN0aXZlIHNlZ21lbnRzIGluZGVmaW5pdGVseSwgdW50aWxcbiAgLy8gdGhlcmUncyBhbiBleHBsaWNpdCByZWZyZXNoLCBvciBhIHBhcmVudCBsYXlvdXQgaXMgbGF6aWx5IHJlZnJlc2hlZC4gV2VcbiAgLy8gcmVseSBvbiB0aGlzIGZvciBwb3BzdGF0ZSBuYXZpZ2F0aW9ucywgd2hpY2ggdXBkYXRlIHRoZSBSb3V0ZXIgU3RhdGUgVHJlZVxuICAvLyBidXQgZG8gbm90IGVhZ2VybHkgcGVyZm9ybSBhIGRhdGEgZmV0Y2gsIGJlY2F1c2UgdGhleSBleHBlY3QgdGhlIHNlZ21lbnRcbiAgLy8gZGF0YSB0byBhbHJlYWR5IGJlIGluIHRoZSBDYWNoZSBOb2RlIHRyZWUuIEZvciBoaWdobHkgc3RhdGljIHNpdGVzIHRoYXRcbiAgLy8gYXJlIG1vc3RseSByZWFkLW9ubHksIHRoaXMgbWF5IGhhcHBlbiBvbmx5IHJhcmVseSwgY2F1c2luZyBtZW1vcnkgdG9cbiAgLy8gbGVhay4gV2Ugc2hvdWxkIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgbW9kZWwgZm9yIHRoZSBsaWZldGltZSBvZiBpbmFjdGl2ZVxuICAvLyBzZWdtZW50cywgc28gd2UgY2FuIG1haW50YWluIGluc3RhbnQgYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdpdGhvdXRcbiAgLy8gbGVha2luZyBtZW1vcnkgaW5kZWZpbml0ZWx5LlxuICBjb25zdCBwcmVmZXRjaFBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChvbGRQYXJhbGxlbFJvdXRlcylcblxuICAvLyBBcyB3ZSBkaWZmIHRoZSB0cmVlcywgd2UgbWF5IHNvbWV0aW1lcyBtb2RpZnkgKGNvcHktb24td3JpdGUsIG5vdCBtdXRhdGUpXG4gIC8vIHRoZSBSb3V0ZSBUcmVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIg4oCUIGZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAvLyBvZiBkZWZhdWx0IHBhcmFsbGVsIHJvdXRlcywgd2UgcHJlc2VydmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudC4gVG9cbiAgLy8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIHRyZWUsIHdlIGNsb25lIHRoZSByb3V0ZXIgc3RhdGUgY2hpbGRyZW4gYWxvbmdcbiAgLy8gdGhlIHJldHVybiBwYXRoLlxuICBsZXQgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG4gIGxldCB0YXNrQ2hpbGRyZW4gPSBudWxsXG5cbiAgLy8gTW9zdCBuYXZpZ2F0aW9ucyByZXF1aXJlIGEgcmVxdWVzdCB0byBmZXRjaCBhZGRpdGlvbmFsIGRhdGEgZnJvbSB0aGVcbiAgLy8gc2VydmVyLCBlaXRoZXIgYmVjYXVzZSB0aGUgZGF0YSB3YXMgbm90IGFscmVhZHkgcHJlZmV0Y2hlZCwgb3IgYmVjYXVzZSB0aGVcbiAgLy8gdGFyZ2V0IHJvdXRlIGNvbnRhaW5zIGR5bmFtaWMgZGF0YSB0aGF0IGNhbm5vdCBiZSBwcmVmZXRjaGVkLlxuICAvL1xuICAvLyBIb3dldmVyLCBpZiB0aGUgdGFyZ2V0IHJvdXRlIGlzIGZ1bGx5IHN0YXRpYywgYW5kIGl0J3MgYWxyZWFkeSBjb21wbGV0ZWx5XG4gIC8vIGxvYWRlZCBpbnRvIHRoZSBzZWdtZW50IGNhY2hlLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBzZXJ2ZXIgcmVxdWVzdC5cbiAgLy9cbiAgLy8gVGhpcyBzdGFydHMgb2ZmIGFzIGBmYWxzZWAsIGFuZCBpcyBzZXQgdG8gYHRydWVgIGlmIGFueSBvZiB0aGUgY2hpbGRcbiAgLy8gcm91dGVzIHJlcXVpcmVzIGEgZHluYW1pYyByZXF1ZXN0LlxuICBsZXQgbmVlZHNEeW5hbWljUmVxdWVzdCA9IGZhbHNlXG4gIC8vIEFzIHdlIHRyYXZlcnNlIHRoZSBjaGlsZHJlbiwgd2UnbGwgY29uc3RydWN0IGEgRmxpZ2h0Um91dGVyU3RhdGUgdGhhdCBjYW5cbiAgLy8gYmUgc2VudCB0byB0aGUgc2VydmVyIHRvIHJlcXVlc3QgdGhlIGR5bmFtaWMgZGF0YS4gSWYgaXQgdHVybnMgb3V0IHRoYXRcbiAgLy8gbm90aGluZyBpbiB0aGUgc3VidHJlZSBpcyBkeW5hbWljIChpLmUuIG5lZWRzRHluYW1pY1JlcXVlc3QgaXMgZmFsc2UgYXQgdGhlXG4gIC8vIGVuZCksIHRoZW4gdGhpcyB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IG9wdGltaXplIHRoZSBmb3JtYXQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSB0byBvbmx5XG4gIC8vIGluY2x1ZGUgcGF0aHMgdGhhdCBhcmUgZHluYW1pYy4gSW5zdGVhZCBvZiByZXVzaW5nIHRoZVxuICAvLyBGbGlnaHRSb3V0ZXJTdGF0ZSB0eXBlLlxuICBsZXQgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG5cbiAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgbmV3Um91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlIHwgdm9pZCA9XG4gICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgb2xkU2VnbWVudE1hcENoaWxkID0gb2xkUGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgdm9pZCB8IG51bGwgPVxuICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICA6IG51bGxcblxuICAgIGNvbnN0IG5ld1NlZ21lbnRDaGlsZCA9IG5ld1JvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCBuZXdTZWdtZW50UGF0aENoaWxkID0gc2VnbWVudFBhdGguY29uY2F0KFtcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBuZXdTZWdtZW50Q2hpbGQsXG4gICAgXSlcbiAgICBjb25zdCBuZXdTZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShuZXdTZWdtZW50Q2hpbGQpXG5cbiAgICBjb25zdCBvbGRTZWdtZW50Q2hpbGQgPVxuICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkID8gb2xkUm91dGVyU3RhdGVDaGlsZFswXSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPVxuICAgICAgb2xkU2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KG5ld1NlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIGxldCB0YXNrQ2hpbGQ6IFRhc2sgfCBudWxsXG4gICAgaWYgKG5ld1NlZ21lbnRDaGlsZCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSkge1xuICAgICAgLy8gVGhpcyBpcyBhbm90aGVyIGtpbmQgb2YgbGVhZiBzZWdtZW50IOKAlCBhIGRlZmF1bHQgcm91dGUuXG4gICAgICAvL1xuICAgICAgLy8gRGVmYXVsdCByb3V0ZXMgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yLiBXaGVuIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgLy8gZm9yIGEgcGFyYWxsZWwgcm91dGUsIE5leHQuanMgcHJlc2VydmVzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnRcbiAgICAgIC8vIGR1cmluZyBhIGNsaWVudCBuYXZpZ2F0aW9uIOKAlCBidXQgbm90IGZvciBpbml0aWFsIHJlbmRlci4gVGhlIHNlcnZlclxuICAgICAgLy8gbGVhdmVzIGl0IHRvIHRoZSBjbGllbnQgdG8gYWNjb3VudCBmb3IgdGhpcy4gU28gd2UgbmVlZCB0byBoYW5kbGVcbiAgICAgIC8vIGl0IGhlcmUuXG4gICAgICBpZiAob2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFJldXNlIHRoZSBleGlzdGluZyBSb3V0ZXIgU3RhdGUgZm9yIHRoaXMgc2VnbWVudC4gV2Ugc3Bhd24gYSBcInRhc2tcIlxuICAgICAgICAvLyBqdXN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgcm91dGVyIHN0YXRlOyB1bmxpa2UgbW9zdCwgaXQnc1xuICAgICAgICAvLyBhbHJlYWR5IGZ1bGZpbGxlZCBhbmQgd29uJ3QgYmUgYWZmZWN0ZWQgYnkgdGhlIGR5bmFtaWMgcmVzcG9uc2UuXG4gICAgICAgIHRhc2tDaGlsZCA9IHNwYXduUmV1c2VkVGFzayhvbGRSb3V0ZXJTdGF0ZUNoaWxkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnQuIFN3aXRjaCB0byB0aGUgXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNTYW1lUGFnZU5hdmlnYXRpb24gJiZcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwYWdlIHNlZ21lbnQuXG4gICAgICAvLyBUT0RPOiBXZSdyZSBub3QgY29uc2lzdGVudCBhYm91dCBob3cgd2UgZG8gdGhpcyBjaGVjay4gU29tZSBwbGFjZXNcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWdtZW50IHN0YXJ0cyB3aXRoIFBBR0VfU0VHTUVOVF9LRVksIGJ1dCBtb3N0IHNlZW0gdG9cbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFueSBhbnkgY2hpbGRyZW4sIHdoaWNoIGlzIHdoeSBJJ20gZG9pbmcgaXQgaGVyZS4gV2VcbiAgICAgIC8vIHNob3VsZCBwcm9iYWJseSBlbmNvZGUgYW4gZW1wdHkgY2hpbGRyZW4gc2V0IGFzIGBudWxsYCB0aG91Z2guIEVpdGhlclxuICAgICAgLy8gd2F5LCB3ZSBzaG91bGQgdXBkYXRlIGFsbCB0aGUgY2hlY2tzIHRvIGJlIGNvbnNpc3RlbnQuXG4gICAgICBPYmplY3Qua2V5cyhuZXdSb3V0ZXJTdGF0ZUNoaWxkWzFdKS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBuYXZpZ2F0aW9ucyB0byB0aGUgZXhhY3Qgc2FtZSBVUkwgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGxvY2F0aW9uLiBJdCdzIGEgY29tbW9uIFVJIHBhdHRlcm4gZm9yIGFwcHMgdG8gcmVmcmVzaCB3aGVuIHlvdSBjbGljayBhXG4gICAgICAvLyBsaW5rIHRvIHRoZSBjdXJyZW50IHBhZ2UuIFNvIHdoZW4gdGhpcyBoYXBwZW5zLCB3ZSByZWZyZXNoIHRoZSBkeW5hbWljXG4gICAgICAvLyBkYXRhIGluIHRoZSBwYWdlIHNlZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFwcGx5IGlmIHRoZSBhbnkgcGFydCBvZiB0aGUgaGFzaCBvciBzZWFyY2hcbiAgICAgIC8vIHF1ZXJ5IGhhcyBjaGFuZ2VkLiBUaGlzIG1pZ2h0IGZlZWwgYSBiaXQgd2VpcmQgYnV0IGl0IG1ha2VzIG1vcmUgc2Vuc2VcbiAgICAgIC8vIHdoZW4geW91IGNvbnNpZGVyIHRoYXQgdGhlIHdheSB0byB0cmlnZ2VyIHRoaXMgYmVoYXZpb3IgaXMgdG8gY2xpY2tcbiAgICAgIC8vIHRoZSBzYW1lIGxpbmsgbXVsdGlwbGUgdGltZXMuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IHJlZnJlc2ggdGhlICplbnRpcmUqIHJvdXRlIHdoZW4gdGhpcyBjYXNlXG4gICAgICAvLyBvY2N1cnMsIG5vdCBqdXN0IHRoZSBwYWdlIHNlZ21lbnRzLiBFc3NlbnRpYWxseSB0cmVhdGluZyBpdCB0aGUgc2FtZSBhc1xuICAgICAgLy8gYSByZWZyZXNoKCkgdHJpZ2dlcmVkIGJ5IGFuIGFjdGlvbiwgd2hpY2ggaXMgdGhlIG1vcmUgZXhwbGljaXQgd2F5IG9mXG4gICAgICAvLyBtb2RlbGluZyB0aGUgVUkgcGF0dGVybiBkZXNjcmliZWQgYWJvdmUuXG4gICAgICAvL1xuICAgICAgLy8gQWxzbyBub3RlIHRoYXQgdGhpcyBvbmx5IHJlZnJlc2hlcyB0aGUgZHluYW1pYyBkYXRhLCBub3Qgc3RhdGljL1xuICAgICAgLy8gY2FjaGVkIGRhdGEuIElmIHRoZSBwYWdlIHNlZ21lbnQgaXMgZnVsbHkgc3RhdGljIGFuZCBwcmVmZXRjaGVkLCB0aGVcbiAgICAgIC8vIHJlcXVlc3QgaXMgc2tpcHBlZC4gKFRoaXMgaXMgYWxzbyBob3cgcmVmcmVzaCgpIHdvcmtzLilcbiAgICAgIHRhc2tDaGlsZCA9IGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkID8gcHJlZmV0Y2hEYXRhQ2hpbGQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgb2xkU2VnbWVudENoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG1hdGNoU2VnbWVudChuZXdTZWdtZW50Q2hpbGQsIG9sZFNlZ21lbnRDaGlsZClcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICAvLyBUaGlzIHNlZ21lbnQgZXhpc3RzIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHRyZWVzLiBSZWN1cnNpdmVseSB1cGRhdGVcbiAgICAgICAgLy8gdGhlIGNoaWxkcmVuLlxuICAgICAgICB0YXNrQ2hpbGQgPSB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBuZXdSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICAgIHByZWZldGNoRGF0YUNoaWxkLFxuICAgICAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgICAgaXNTYW1lUGFnZU5hdmlnYXRpb24sXG4gICAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBleGlzdGluZyBDYWNoZSBOb2RlIGZvciB0aGlzIHNlZ21lbnQuIFN3aXRjaCB0byB0aGVcbiAgICAgICAgLy8gXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyB0cmVlLiBTd2l0Y2ggdG8gdGhlIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgIHRhc2tDaGlsZCA9IGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkID8gcHJlZmV0Y2hEYXRhQ2hpbGQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRhc2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvcGFnYXRlIHVwIHRoZSBjaGlsZCB0YXNrcy5cblxuICAgICAgaWYgKHRhc2tDaGlsZC5yb3V0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBPbmUgb2YgdGhlIGNoaWxkIHRhc2tzIGRpc2NvdmVyZWQgYSBjaGFuZ2UgdG8gdGhlIHJvb3QgbGF5b3V0LlxuICAgICAgICAvLyBJbW1lZGlhdGVseSB1bndpbmQgZnJvbSB0aGlzIHJlY3Vyc2l2ZSB0cmF2ZXJzYWwuXG4gICAgICAgIHJldHVybiBNUEFfTkFWSUdBVElPTl9UQVNLXG4gICAgICB9XG5cbiAgICAgIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgdGFza0NoaWxkcmVuID0gbmV3IE1hcCgpXG4gICAgICB9XG4gICAgICB0YXNrQ2hpbGRyZW4uc2V0KHBhcmFsbGVsUm91dGVLZXksIHRhc2tDaGlsZClcbiAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdGFza0NoaWxkLm5vZGVcbiAgICAgIGlmIChuZXdDYWNoZU5vZGVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQ6IENoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKVxuICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KG5ld1NlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgICAgIHByZWZldGNoUGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNoaWxkIHRyZWUncyByb3V0ZSBzdGF0ZSBtYXkgYmUgZGlmZmVyZW50IGZyb20gdGhlIHByZWZldGNoZWRcbiAgICAgIC8vIHJvdXRlIHNlbnQgYnkgdGhlIHNlcnZlci4gV2UgbmVlZCB0byBjbG9uZSBpdCBhcyB3ZSB0cmF2ZXJzZSBiYWNrIHVwXG4gICAgICAvLyB0aGUgdHJlZS5cbiAgICAgIGNvbnN0IHRhc2tDaGlsZFJvdXRlID0gdGFza0NoaWxkLnJvdXRlXG4gICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHRhc2tDaGlsZFJvdXRlXG5cbiAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkID0gdGFza0NoaWxkLmR5bmFtaWNSZXF1ZXN0VHJlZVxuICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgY2hpbGQgdHJlZSBpcyBkeW5hbWljLlxuICAgICAgICBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gdHJ1ZVxuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHRhc2tDaGlsZFJvdXRlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjaGlsZCBkaWRuJ3QgY2hhbmdlLiBXZSBjYW4gdXNlIHRoZSBwcmVmZXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gbmV3Um91dGVyU3RhdGVDaGlsZFxuICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIE5vIG5ldyB0YXNrcyB3ZXJlIHNwYXduZWQuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IG5ld0NhY2hlTm9kZTogUmVhZHlDYWNoZU5vZGUgPSB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjOiBvbGRDYWNoZU5vZGUucnNjLFxuICAgIC8vIFdlIGludGVudGlvbmFsbHkgYXJlbid0IHVwZGF0aW5nIHRoZSBwcmVmZXRjaFJzYyBmaWVsZCwgc2luY2UgdGhpcyBub2RlXG4gICAgLy8gaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBjdXJyZW50IHRyZWUsIGJlY2F1c2UgaXQgd291bGQgYmUgd2VpcmQgZm9yXG4gICAgLy8gcHJlZmV0Y2ggZGF0YSB0byBiZSBuZXdlciB0aGFuIHRoZSBmaW5hbCBkYXRhLiBJdCBwcm9iYWJseSB3b24ndCBldmVyIGJlXG4gICAgLy8gb2JzZXJ2YWJsZSBhbnl3YXksIGJ1dCBpdCBjb3VsZCBoYXBwZW4gaWYgdGhlIHNlZ21lbnQgaXMgdW5tb3VudGVkIHRoZW5cbiAgICAvLyBtb3VudGVkIGFnYWluLCBiZWNhdXNlIExheW91dFJvdXRlciB3aWxsIG1vbWVudGFyaWx5IHN3aXRjaCB0byByZW5kZXJpbmdcbiAgICAvLyBwcmVmZXRjaFJzYywgdmlhIHVzZURlZmVycmVkVmFsdWUuXG4gICAgcHJlZmV0Y2hSc2M6IG9sZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICBoZWFkOiBvbGRDYWNoZU5vZGUuaGVhZCxcbiAgICBwcmVmZXRjaEhlYWQ6IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgbG9hZGluZzogb2xkQ2FjaGVOb2RlLmxvYWRpbmcsXG5cbiAgICAvLyBFdmVyeXRoaW5nIGlzIGNsb25lZCBleGNlcHQgZm9yIHRoZSBjaGlsZHJlbiwgd2hpY2ggd2UgY29tcHV0ZWQgYWJvdmUuXG4gICAgcGFyYWxsZWxSb3V0ZXM6IHByZWZldGNoUGFyYWxsZWxSb3V0ZXMsXG5cbiAgICBuYXZpZ2F0ZWRBdCxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gUmV0dXJuIGEgY2xvbmVkIGNvcHkgb2YgdGhlIHJvdXRlciBzdGF0ZSB3aXRoIHVwZGF0ZWQgY2hpbGRyZW4uXG4gICAgcm91dGU6IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuXG4gICAgKSxcbiAgICBub2RlOiBuZXdDYWNoZU5vZGUsXG4gICAgZHluYW1pY1JlcXVlc3RUcmVlOiBuZWVkc0R5bmFtaWNSZXF1ZXN0XG4gICAgICA/IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICAgICAgbmV3Um91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5cbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICAgIGNoaWxkcmVuOiB0YXNrQ2hpbGRyZW4sXG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZXhpc3RpbmdDYWNoZU5vZGU6IENhY2hlTm9kZSB8IHZvaWQsXG4gIGRpZEZpbmRSb290TGF5b3V0OiBib29sZWFuLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB7XG4gIGlmICghZGlkRmluZFJvb3RMYXlvdXQpIHtcbiAgICAvLyBUaGUgcm91dGUgdHJlZSBjaGFuZ2VkIGJlZm9yZSB3ZSByZWFjaGVkIGEgbGF5b3V0LiAoVGhlIGhpZ2hlc3QtbGV2ZWxcbiAgICAvLyBsYXlvdXQgaW4gYSByb3V0ZSB0cmVlIGlzIHJlZmVycmVkIHRvIGFzIHRoZSBcInJvb3RcIiBsYXlvdXQuKSBUaGlzIGNvdWxkXG4gICAgLy8gbWVhbiB0aGF0IHdlJ3JlIG5hdmlnYXRpbmcgYmV0d2VlbiB0d28gZGlmZmVyZW50IHJvb3QgbGF5b3V0cy4gV2hlbiB0aGlzXG4gICAgLy8gaGFwcGVucywgd2UgcGVyZm9ybSBhIGZ1bGwtcGFnZSAoTVBBLXN0eWxlKSBuYXZpZ2F0aW9uLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgdGhlIGFsZ29yaXRobSBmb3IgZGVjaWRpbmcgd2hlcmUgdG8gc3RhcnQgcmVuZGVyaW5nIGEgcm91dGVcbiAgICAvLyAoaS5lLiB0aGUgb25lIHBlcmZvcm1lZCBpbiBvcmRlciB0byByZWFjaCB0aGlzIGZ1bmN0aW9uKSBpcyBzdHJpY3RlclxuICAgIC8vIHRoYW4gdGhlIG9uZSB1c2VkIHRvIGRldGVjdCBhIGNoYW5nZSBpbiB0aGUgcm9vdCBsYXlvdXQuIFNvIGp1c3QgYmVjYXVzZVxuICAgIC8vIHdlJ3JlIHJlLXJlbmRlcmluZyBhIHNlZ21lbnQgb3V0c2lkZSBvZiB0aGUgcm9vdCBsYXlvdXQgZG9lcyBub3QgbWVhbiB3ZVxuICAgIC8vIHNob3VsZCB0cmlnZ2VyIGEgZnVsbC1wYWdlIG5hdmlnYXRpb24uXG4gICAgLy9cbiAgICAvLyBTcGVjaWZpY2FsbHksIHdlIGhhbmRsZSBkeW5hbWljIHBhcmFtZXRlcnMgZGlmZmVyZW50bHk6IHR3byBzZWdtZW50cyBhcmVcbiAgICAvLyBjb25zaWRlcmVkIHRoZSBzYW1lIGV2ZW4gaWYgdGhlaXIgcGFyYW1ldGVyIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICAgIC8vXG4gICAgLy8gUmVmZXIgdG8gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IGZvciBkZXRhaWxzLlxuICAgIC8vXG4gICAgLy8gTm90ZSB0aGF0IHdlIG9ubHkgaGF2ZSB0byBwZXJmb3JtIHRoaXMgZXh0cmEgdHJhdmVyc2FsIGlmIHdlIGRpZG4ndFxuICAgIC8vIGFscmVhZHkgZGlzY292ZXIgYSByb290IGxheW91dCBpbiB0aGUgcGFydCBvZiB0aGUgdHJlZSB0aGF0IGlzIHVuY2hhbmdlZC5cbiAgICAvLyBJbiB0aGUgY29tbW9uIGNhc2UsIHRoaXMgYnJhbmNoIGlzIHNraXBwZWQgY29tcGxldGVseS5cbiAgICBpZiAoXG4gICAgICBvbGRSb3V0ZXJTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQob2xkUm91dGVyU3RhdGUsIG5ld1JvdXRlclN0YXRlKVxuICAgICkge1xuICAgICAgLy8gVGhlIHJvb3QgbGF5b3V0IGNoYW5nZWQuIFBlcmZvcm0gYSBmdWxsLXBhZ2UgbmF2aWdhdGlvbi5cbiAgICAgIHJldHVybiBNUEFfTkFWSUdBVElPTl9UQVNLXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgbmF2aWdhdGVkQXQsXG4gICAgbmV3Um91dGVyU3RhdGUsXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUsXG4gICAgcHJlZmV0Y2hEYXRhLFxuICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgc2VnbWVudFBhdGgsXG4gICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGV4aXN0aW5nQ2FjaGVOb2RlOiBDYWNoZU5vZGUgfCB2b2lkLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogU1BBTmF2aWdhdGlvblRhc2sge1xuICAvLyBTYW1lIHRyYXZlcnNhbCBhcyB1cGRhdGVDYWNoZU5vZGVOYXZpZ2F0aW9uLCBidXQgd2Ugc3dpdGNoIHRvIHRoaXMgcGF0aFxuICAvLyBvbmNlIHdlIHJlYWNoIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIG5vdCBpbiB0aGUgcHJldmlvdXMgcm91dGUuIFdlXG4gIC8vIGRvbid0IG5lZWQgdG8gZGlmZiBhZ2FpbnN0IHRoZSBvbGQgdHJlZSwgd2UganVzdCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG5cbiAgLy8gVGhlIGhlYWQgaXMgYXNzaWduZWQgdG8gZXZlcnkgbGVhZiBzZWdtZW50IGRlbGl2ZXJlZCBieSB0aGUgc2VydmVyLiBCYXNlZFxuICAvLyBvbiBjb3JyZXNwb25kaW5nIGxvZ2ljIGluIGZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBpc0xlYWZTZWdtZW50ID0gT2JqZWN0LmtleXMocm91dGVyU3RhdGVDaGlsZHJlbikubGVuZ3RoID09PSAwXG5cbiAgLy8gRXZlbiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIHRoZSBcIm5ld1wiIHBhcnQgb2YgdGhlIHRhcmdldCB0cmVlLCB3ZSBtYXkgaGF2ZVxuICAvLyBhIGxvY2FsbHkgY2FjaGVkIHNlZ21lbnQgdGhhdCB3ZSBjYW4gcmV1c2UuIFRoaXMgbWF5IGNvbWUgZnJvbSBlaXRoZXIgMSlcbiAgLy8gdGhlIENhY2hlTm9kZSB0cmVlLCB3aGljaCBsaXZlcyBpbiBSZWFjdCBzdGF0ZSBhbmQgaXMgcG9wdWxhdGVkIGJ5IHByZXZpb3VzXG4gIC8vIG5hdmlnYXRpb25zOyBvciAyKSB0aGUgcHJlZmV0Y2ggY2FjaGUsIHdoaWNoIGlzIGEgc2VwYXJhdGUgY2FjaGUgdGhhdCBpc1xuICAvLyBwb3B1bGF0ZWQgYnkgcHJlZmV0Y2hlcy5cbiAgbGV0IHJzYzogUmVhY3QuUmVhY3ROb2RlXG4gIGxldCBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+XG4gIGxldCBoZWFkOiBIZWFkRGF0YSB8IG51bGxcbiAgbGV0IGNhY2hlTm9kZU5hdmlnYXRlZEF0OiBudW1iZXJcbiAgaWYgKFxuICAgIGV4aXN0aW5nQ2FjaGVOb2RlICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBEWU5BTUlDX1NUQUxFVElNRV9NUyBkZWZhdWx0cyB0byAwLCBidXQgaXQgY2FuIGJlIGluY3JlYXNlZCB1c2luZ1xuICAgIC8vIHRoZSBleHBlcmltZW50YWwuc3RhbGVUaW1lcy5keW5hbWljIGNvbmZpZy4gV2hlbiBzZXQsIHdlJ2xsIGF2b2lkXG4gICAgLy8gcmVmZXRjaGluZyBkeW5hbWljIGRhdGEgaWYgaXQgd2FzIGZldGNoZWQgd2l0aGluIHRoZSBnaXZlbiB0aHJlc2hvbGQuXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUubmF2aWdhdGVkQXQgKyBEWU5BTUlDX1NUQUxFVElNRV9NUyA+IG5hdmlnYXRlZEF0XG4gICkge1xuICAgIC8vIFdlIGhhdmUgYW4gZXhpc3RpbmcgQ2FjaGVOb2RlIGZvciB0aGlzIHNlZ21lbnQsIGFuZCBpdCdzIG5vdCBzdGFsZS4gV2VcbiAgICAvLyBzaG91bGQgcmV1c2UgaXQgcmF0aGVyIHRoYW4gcmVxdWVzdCBhIG5ldyBvbmUuXG4gICAgcnNjID0gZXhpc3RpbmdDYWNoZU5vZGUucnNjXG4gICAgbG9hZGluZyA9IGV4aXN0aW5nQ2FjaGVOb2RlLmxvYWRpbmdcbiAgICBoZWFkID0gZXhpc3RpbmdDYWNoZU5vZGUuaGVhZFxuXG4gICAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBuYXZpZ2F0ZWRBdCB0aW1lc3RhbXAsIHNpbmNlIHdlJ3JlIHJldXNpbmcgc3RhbGUgZGF0YS5cbiAgICBjYWNoZU5vZGVOYXZpZ2F0ZWRBdCA9IGV4aXN0aW5nQ2FjaGVOb2RlLm5hdmlnYXRlZEF0XG4gIH0gZWxzZSBpZiAocHJlZmV0Y2hEYXRhICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyBleGlzdGluZyBDYWNoZU5vZGUgZm9yIHRoaXMgc2VnbWVudCwgYnV0IHdlIGRvIGhhdmUgcHJlZmV0Y2hcbiAgICAvLyBkYXRhLiBJZiB0aGUgcHJlZmV0Y2ggZGF0YSBpcyBmdWxseSBzdGF0aWMgKGkuZS4gZG9lcyBub3QgY29udGFpbiBhbnlcbiAgICAvLyBkeW5hbWljIGhvbGVzKSwgd2UgZG9uJ3QgbmVlZCB0byByZXF1ZXN0IGl0IGZyb20gdGhlIHNlcnZlci5cbiAgICByc2MgPSBwcmVmZXRjaERhdGFbMV1cbiAgICBsb2FkaW5nID0gcHJlZmV0Y2hEYXRhWzNdXG4gICAgaGVhZCA9IGlzTGVhZlNlZ21lbnQgPyBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQgOiBudWxsXG4gICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgYWNjZXNzaW5nIHRoZSBkYXRhIGZyb20gdGhlIHByZWZldGNoIGNhY2hlLCB0aGlzIGlzXG4gICAgLy8gY29uY2VwdHVhbGx5IGEgbmV3IHNlZ21lbnQsIG5vdCBhIHJldXNlZCBvbmUuIFNvIHdlIHNob3VsZCB1cGRhdGUgdGhlXG4gICAgLy8gbmF2aWdhdGVkQXQgdGltZXN0YW1wLlxuICAgIGNhY2hlTm9kZU5hdmlnYXRlZEF0ID0gbmF2aWdhdGVkQXRcbiAgICBjb25zdCBpc1ByZWZldGNoUnNjUGFydGlhbCA9IHByZWZldGNoRGF0YVs0XVxuICAgIGlmIChcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50IGRhdGEgaXMgcGFydGlhbFxuICAgICAgaXNQcmVmZXRjaFJzY1BhcnRpYWwgfHxcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBoZWFkIGlzIHBhcnRpYWwgKG9ubHkgcmVsZXZhbnQgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudClcbiAgICAgIChpc1ByZWZldGNoSGVhZFBhcnRpYWwgJiYgaXNMZWFmU2VnbWVudClcbiAgICApIHtcbiAgICAgIC8vIFdlIG9ubHkgaGF2ZSBwYXJ0aWFsIGRhdGEgZnJvbSB0aGlzIHNlZ21lbnQuIExpa2UgbWlzc2luZyBzZWdtZW50cywgd2VcbiAgICAgIC8vIG11c3QgcmVxdWVzdCB0aGUgZnVsbCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgIHJldHVybiBzcGF3blBlbmRpbmdUYXNrKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgcm91dGVyU3RhdGUsXG4gICAgICAgIHByZWZldGNoRGF0YSxcbiAgICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHByZWZldGNoIGRhdGEgaXMgZnVsbHkgc3RhdGljLCBzbyB3ZSBjYW4gb21pdCBpdCBmcm9tIHRoZVxuICAgICAgLy8gbmF2aWdhdGlvbiByZXF1ZXN0LlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSdzIG5vIHByZWZldGNoIGZvciB0aGlzIHNlZ21lbnQuIEV2ZXJ5dGhpbmcgZnJvbSB0aGlzIHBvaW50IHdpbGwgYmVcbiAgICAvLyByZXF1ZXN0ZWQgZnJvbSB0aGUgc2VydmVyLCBldmVuIGlmIHRoZXJlIGFyZSBzdGF0aWMgY2hpbGRyZW4gYmVsb3cgaXQuXG4gICAgLy8gQ3JlYXRlIGEgdGVybWluYWwgdGFzayBub2RlIHRoYXQgd2lsbCBsYXRlciBiZSBmdWxmaWxsZWQgYnlcbiAgICAvLyBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgcmV0dXJuIHNwYXduUGVuZGluZ1Rhc2soXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIHJvdXRlclN0YXRlLFxuICAgICAgbnVsbCxcbiAgICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKVxuICB9XG5cbiAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgZnVsbCBzZWdtZW50IHdlIGNhbiByZW5kZXIsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVxdWVzdCBhXG4gIC8vIG5ldyBvbmUgZnJvbSB0aGUgc2VydmVyLiBLZWVwIHRyYXZlcnNpbmcgZG93biB0aGUgdHJlZSB1bnRpbCB3ZSByZWFjaFxuICAvLyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBhIGR5bmFtaWMgcmVxdWVzdC5cbiAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IG5ldyBNYXAoKVxuICBjb25zdCBleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuID1cbiAgICBleGlzdGluZ0NhY2hlTm9kZSAhPT0gdW5kZWZpbmVkID8gZXhpc3RpbmdDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMgOiBudWxsXG4gIGNvbnN0IGNhY2hlTm9kZUNoaWxkcmVuID0gbmV3IE1hcChleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuKVxuICBsZXQgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG4gIGxldCBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gZmFsc2VcbiAgaWYgKGlzTGVhZlNlZ21lbnQpIHtcbiAgICAvLyBUaGUgc2VnbWVudCBwYXRoIG9mIGV2ZXJ5IGxlYWYgc2VnbWVudCAoaS5lLiBwYWdlKSBpcyBjb2xsZWN0ZWQgaW50b1xuICAgIC8vIGEgcmVzdWx0IGFycmF5LiBUaGlzIGlzIHVzZWQgYnkgdGhlIExheW91dFJvdXRlciB0byBzY3JvbGwgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBuZXcgcGFnZXMgYXJlIHZpc2libGUgYWZ0ZXIgYSBuYXZpZ2F0aW9uLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCB1c2UgYSBzdHJpbmcgdG8gcmVwcmVzZW50IHRoZSBzZWdtZW50IHBhdGggaW5zdGVhZCBvZlxuICAgIC8vIGFuIGFycmF5LiBXZSBhbHJlYWR5IHVzZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHBhdGggd2hlblxuICAgIC8vIGFjY2Vzc2luZyB0aGUgU2VnbWVudCBDYWNoZSwgc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBvbmUuXG4gICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0LnB1c2goc2VnbWVudFBhdGgpXG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkOiBDYWNoZU5vZGVTZWVkRGF0YSB8IHZvaWQgfCBudWxsID1cbiAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgICA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgICAgOiBudWxsXG4gICAgICBjb25zdCBleGlzdGluZ1NlZ21lbnRNYXBDaGlsZCA9XG4gICAgICAgIGV4aXN0aW5nQ2FjaGVOb2RlQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgICA/IGV4aXN0aW5nQ2FjaGVOb2RlQ2hpbGRyZW4uZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICAgIGNvbnN0IHNlZ21lbnRQYXRoQ2hpbGQgPSBzZWdtZW50UGF0aC5jb25jYXQoW1xuICAgICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgICBzZWdtZW50Q2hpbGQsXG4gICAgICBdKVxuICAgICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuXG4gICAgICBjb25zdCBleGlzdGluZ0NhY2hlTm9kZUNoaWxkID1cbiAgICAgICAgZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICBjb25zdCB0YXNrQ2hpbGQgPSBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICByb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICBleGlzdGluZ0NhY2hlTm9kZUNoaWxkLFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCxcbiAgICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIHNlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgKVxuICAgICAgdGFza0NoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCB0YXNrQ2hpbGQpXG4gICAgICBjb25zdCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCA9IHRhc2tDaGlsZC5keW5hbWljUmVxdWVzdFRyZWVcbiAgICAgIGlmIChkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIGNoaWxkIHRyZWUgaXMgZHluYW1pYy5cbiAgICAgICAgbmVlZHNEeW5hbWljUmVxdWVzdCA9IHRydWVcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSByb3V0ZXJTdGF0ZUNoaWxkXG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IHRhc2tDaGlsZC5ub2RlXG4gICAgICBpZiAobmV3Q2FjaGVOb2RlQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkOiBDaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgICAgICBjYWNoZU5vZGVDaGlsZHJlbi5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmV3IHJvdXRlIHRyZWUsIHVubGlrZSB0aGVcbiAgICAvLyBgdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uYCBwYXRoLCB0aGUgcm91dGVyIHN0YXRlIG9uIHRoZSBjaGlsZHJlblxuICAgIC8vIHRhc2tzIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyB0aGUgcm91dGVyIHN0YXRlIHdlIHBhc3MgaW4uIFNvIHdlIGRvbid0IG5lZWRcbiAgICAvLyB0byBjbG9uZS9tb2RpZnkgaXQuXG4gICAgcm91dGU6IHJvdXRlclN0YXRlLFxuICAgIG5vZGU6IHtcbiAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgLy8gU2luY2UgdGhpcyBzZWdtZW50IGlzIGFscmVhZHkgZnVsbCwgd2UgZG9uJ3QgbmVlZCB0byB1c2UgdGhlXG4gICAgICAvLyBgcHJlZmV0Y2hSc2NgIGZpZWxkLlxuICAgICAgcnNjLFxuICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICBoZWFkLFxuICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgbG9hZGluZyxcbiAgICAgIHBhcmFsbGVsUm91dGVzOiBjYWNoZU5vZGVDaGlsZHJlbixcbiAgICAgIG5hdmlnYXRlZEF0OiBjYWNoZU5vZGVOYXZpZ2F0ZWRBdCxcbiAgICB9LFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbmVlZHNEeW5hbWljUmVxdWVzdFxuICAgICAgPyBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKHJvdXRlclN0YXRlLCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbilcbiAgICAgIDogbnVsbCxcbiAgICBjaGlsZHJlbjogdGFza0NoaWxkcmVuLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gIGJhc2VSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld0NoaWxkcmVuOiB7IFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBGbGlnaHRSb3V0ZXJTdGF0ZSB9XG4pOiBGbGlnaHRSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IGNsb25lOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IFtiYXNlUm91dGVyU3RhdGVbMF0sIG5ld0NoaWxkcmVuXVxuICAvLyBCYXNlZCBvbiBlcXVpdmFsZW50IGxvZ2ljIGluIGFwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLCBidXQgc2hvdWxkXG4gIC8vIGNvbmZpcm0gd2hldGhlciB3ZSBuZWVkIHRvIGNvcHkgYWxsIG9mIHRoZXNlIGZpZWxkcy4gTm90IHN1cmUgdGhlIHNlcnZlclxuICAvLyBldmVyIHNlbmRzLCBlLmcuIHRoZSByZWZldGNoIG1hcmtlci5cbiAgaWYgKDIgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgY2xvbmVbMl0gPSBiYXNlUm91dGVyU3RhdGVbMl1cbiAgfVxuICBpZiAoMyBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICBjbG9uZVszXSA9IGJhc2VSb3V0ZXJTdGF0ZVszXVxuICB9XG4gIGlmICg0IGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgIGNsb25lWzRdID0gYmFzZVJvdXRlclN0YXRlWzRdXG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIHNwYXduUGVuZGluZ1Rhc2soXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFNQQU5hdmlnYXRpb25UYXNrIHtcbiAgLy8gQ3JlYXRlIGEgdGFzayB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuXG4gIC8vIENsb25lIHRoZSBwcmVmZXRjaGVkIHJvdXRlIHRyZWUgYW5kIHRoZSBgcmVmZXRjaGAgbWFya2VyIHRvIGl0LiBXZSdsbCBzZW5kXG4gIC8vIHRoaXMgdG8gdGhlIHNlcnZlciBzbyBpdCBrbm93cyB3aGVyZSB0byBzdGFydCByZW5kZXJpbmcuXG4gIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZSA9IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgcm91dGVyU3RhdGUsXG4gICAgcm91dGVyU3RhdGVbMV1cbiAgKVxuICBkeW5hbWljUmVxdWVzdFRyZWVbM10gPSAncmVmZXRjaCdcblxuICBjb25zdCBuZXdUYXNrOiBUYXNrID0ge1xuICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcblxuICAgIC8vIENvcnJlc3BvbmRzIHRvIHRoZSBwYXJ0IG9mIHRoZSByb3V0ZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgICBub2RlOiBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICByb3V0ZXJTdGF0ZSxcbiAgICAgIHByZWZldGNoRGF0YSxcbiAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKSxcbiAgICAvLyBCZWNhdXNlIHRoaXMgaXMgbm9uLW51bGwsIGFuZCBpdCBnZXRzIHByb3BhZ2F0ZWQgdXAgdGhyb3VnaCB0aGUgcGFyZW50XG4gICAgLy8gdGFza3MsIHRoZSByb290IHRhc2sgd2lsbCBrbm93IHRoYXQgaXQgbmVlZHMgdG8gcGVyZm9ybSBhIHNlcnZlciByZXF1ZXN0LlxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZSxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxuICByZXR1cm4gbmV3VGFza1xufVxuXG5mdW5jdGlvbiBzcGF3blJldXNlZFRhc2socmV1c2VkUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlKTogVGFzayB7XG4gIC8vIENyZWF0ZSBhIHRhc2sgdGhhdCByZXVzZXMgYW4gZXhpc3Rpbmcgc2VnbWVudCwgZS5nLiB3aGVuIHJldXNpbmdcbiAgLy8gdGhlIGN1cnJlbnQgYWN0aXZlIHNlZ21lbnQgaW4gcGxhY2Ugb2YgYSBkZWZhdWx0IHJvdXRlLlxuICByZXR1cm4ge1xuICAgIHJvdXRlOiByZXVzZWRSb3V0ZXJTdGF0ZSxcbiAgICBub2RlOiBudWxsLFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxufVxuXG4vLyBXcml0ZXMgYSBkeW5hbWljIHNlcnZlciByZXNwb25zZSBpbnRvIHRoZSB0cmVlIGNyZWF0ZWQgYnlcbi8vIHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbi4gQWxsIHBlbmRpbmcgcHJvbWlzZXMgdGhhdCB3ZXJlIHNwYXduZWQgYnkgdGhlXG4vLyBuYXZpZ2F0aW9uIHdpbGwgYmUgcmVzb2x2ZWQsIGVpdGhlciB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIG9yXG4vLyBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZGF0YSBpcyBtaXNzaW5nLlxuLy9cbi8vIEEgYG51bGxgIHZhbHVlIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlciwgd2hpY2ggd2lsbCB0aGVuIHBhdGNoXG4vLyB1cCB0aGUgdHJlZSB1c2luZyB0aGUgc2FtZSBtZWNoYW5pc20gYXMgdGhlIG5vbi1QUFIgaW1wbGVtZW50YXRpb25cbi8vIChzZXJ2ZXJQYXRjaFJlZHVjZXIpLlxuLy9cbi8vIFVzdWFsbHksIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggZXhhY3RseSB0aGUgc3Vic2V0IG9mIGRhdGEgdGhhdCB3ZSdyZVxuLy8gd2FpdGluZyBmb3Ig4oCUIGV2ZXJ5dGhpbmcgYmVsb3cgdGhlIG5lYXJlc3Qgc2hhcmVkIGxheW91dC4gQnV0IHRlY2huaWNhbGx5LFxuLy8gdGhlIHNlcnZlciBjYW4gcmV0dXJuIGFueXRoaW5nIGl0IHdhbnRzLlxuLy9cbi8vIFRoaXMgZG9lcyBfbm90XyBjcmVhdGUgYSBuZXcgdHJlZTsgaXQgbW9kaWZpZXMgdGhlIGV4aXN0aW5nIG9uZSBpbiBwbGFjZS5cbi8vIFdoaWNoIG1lYW5zIGl0IG11c3QgZm9sbG93IHRoZSBTdXNwZW5zZSBydWxlcyBvZiBjYWNoZSBzYWZldHkuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QoXG4gIHRhc2s6IFNQQU5hdmlnYXRpb25UYXNrLFxuICByZXNwb25zZVByb21pc2U6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD5cbikge1xuICByZXNwb25zZVByb21pc2UudGhlbihcbiAgICAoeyBmbGlnaHREYXRhIH06IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSGFwcGVucyB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGAuIFdlIHNob3VsZG4ndFxuICAgICAgICAvLyBnZXQgaGVyZSBiZWNhdXNlIHNob3VsZCBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGlzIGR1cmluZ1xuICAgICAgICAvLyB0aGUgcHJlZmV0Y2guXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWdtZW50UGF0aCxcbiAgICAgICAgICB0cmVlOiBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgICBzZWVkRGF0YTogZHluYW1pY0RhdGEsXG4gICAgICAgICAgaGVhZDogZHluYW1pY0hlYWQsXG4gICAgICAgIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgICAgIGlmICghZHluYW1pY0RhdGEpIHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4uIFBQUiBzaG91bGQgYWx3YXlzIHNlbmQgYmFjayBhIHJlc3BvbnNlLlxuICAgICAgICAgIC8vIEhvd2V2ZXIsIGBGbGlnaHREYXRhUGF0aGAgaXMgYSBzaGFyZWQgdHlwZSBhbmQgdGhlIHByZS1QUFIgaGFuZGxpbmcgb2ZcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IHJldHVybiBudWxsLlxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgc2VnbWVudFBhdGgsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgICAgZHluYW1pY0hlYWRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBleGhhdXN0ZWQgYWxsIHRoZSBkYXRhIHdlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciwgaWZcbiAgICAgIC8vIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nIHBlbmRpbmcgdGFza3MgaW4gdGhlIHRyZWUsIGFib3J0IHRoZW0gbm93LlxuICAgICAgLy8gSWYgdGhlcmUncyBhbnkgbWlzc2luZyBkYXRhLCBpdCB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoLlxuICAgICAgYWJvcnRUYXNrKHRhc2ssIG51bGwpXG4gICAgfSxcbiAgICAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgZHVyaW5nIHJlbmRlclxuICAgICAgYWJvcnRUYXNrKHRhc2ssIGVycm9yKVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICByb290VGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2VydmVyUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBkeW5hbWljRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEsXG4gIGR5bmFtaWNIZWFkOiBIZWFkRGF0YVxuKSB7XG4gIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlIG5lZWRcbiAgLy8gdG8gZmluZCB0aGUgcGFydCBvZiB0aGUgdGFzayB0cmVlIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIHJlc3BvbnNlLCBhbmRcbiAgLy8gZnVsZmlsbCBpdCB1c2luZyB0aGUgZHluYW1pYyBkYXRhLlxuICAvL1xuICAvLyBzZWdtZW50UGF0aCByZXByZXNlbnRzIHRoZSBwYXJlbnQgcGF0aCBvZiBzdWJ0cmVlLiBJdCdzIGEgcmVwZWF0aW5nIHBhdHRlcm5cbiAgLy8gb2YgcGFyYWxsZWwgcm91dGUga2V5IGFuZCBzZWdtZW50OlxuICAvL1xuICAvLyAgIFtzdHJpbmcsIFNlZ21lbnQsIHN0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCAuLi5dXG4gIC8vXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGF0aCBhbmQgZmluaXNoIGFueSB0YXNrcyB0aGF0IG1hdGNoIHRoaXMgcGF5bG9hZC5cbiAgbGV0IHRhc2sgPSByb290VGFza1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gc2VnbWVudFBhdGhbaV1cbiAgICBjb25zdCBzZWdtZW50OiBTZWdtZW50ID0gc2VnbWVudFBhdGhbaSArIDFdXG4gICAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlblxuICAgIGlmICh0YXNrQ2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRhc2tDaGlsZCA9IHRhc2tDaGlsZHJlbi5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YXNrU2VnbWVudCA9IHRhc2tDaGlsZC5yb3V0ZVswXVxuICAgICAgICBpZiAobWF0Y2hTZWdtZW50KHNlZ21lbnQsIHRhc2tTZWdtZW50KSkge1xuICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgICB0YXNrID0gdGFza0NoaWxkXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIGNoaWxkIHRhc2sgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgZGF0YS4gRXhpdC4gV2Ugd29uJ3RcbiAgICAvLyBhYm9ydCB0aGUgdGFzaywgdGhvdWdoLCBiZWNhdXNlIGEgZGlmZmVyZW50IEZsaWdodERhdGFQYXRoIG1heSBiZSBhYmxlIHRvXG4gICAgLy8gZnVsZmlsbCBpdCAoc2VlIGxvb3AgaW4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QpLiBXZSBvbmx5IGFib3J0IHRhc2tzXG4gICAgLy8gb25jZSB3ZSd2ZSBydW4gb3V0IG9mIGRhdGEuXG4gICAgcmV0dXJuXG4gIH1cblxuICBmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQoXG4gICAgdGFzayxcbiAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICBkeW5hbWljRGF0YSxcbiAgICBkeW5hbWljSGVhZFxuICApXG59XG5cbmZ1bmN0aW9uIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgdGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlcnZlclJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZHluYW1pY0RhdGE6IENhY2hlTm9kZVNlZWREYXRhLFxuICBkeW5hbWljSGVhZDogSGVhZERhdGFcbikge1xuICBpZiAodGFzay5keW5hbWljUmVxdWVzdFRyZWUgPT09IG51bGwpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGluIHRoaXMgc3VidHJlZSBpcyBhbHJlYWR5IGNvbXBsZXRlLiBCYWlsIG91dC5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGR5bmFtaWNEYXRhIG1heSByZXByZXNlbnQgYSBsYXJnZXIgc3VidHJlZSB0aGFuIHRoZSB0YXNrLiBCZWZvcmUgd2UgY2FuXG4gIC8vIGZpbmlzaCB0aGUgdGFzaywgd2UgbmVlZCB0byBsaW5lIHRoZW0gdXAuXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW5cbiAgY29uc3QgdGFza05vZGUgPSB0YXNrLm5vZGVcbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGxlYWYgbm9kZSBvZiB0aGUgcGVuZGluZyB0YXNrLiBUaGUgc2VydmVyIGRhdGEgdHJlZVxuICAgIC8vIGxpbmVzIHVwIHRoZSBwZW5kaW5nIENhY2hlIE5vZGUgdHJlZS4gV2UgY2FuIG5vdyBzd2l0Y2ggdG8gdGhlXG4gICAgLy8gbm9ybWFsIGFsZ29yaXRobS5cbiAgICBpZiAodGFza05vZGUgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICAgIHRhc2tOb2RlLFxuICAgICAgICB0YXNrLnJvdXRlLFxuICAgICAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICApXG4gICAgICAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoYXQgdGhpcyB0YXNrIGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICAvLyBUaGUgc2VydmVyIHJldHVybmVkIG1vcmUgZGF0YSB0aGFuIHdlIG5lZWQgdG8gZmluaXNoIHRoZSB0YXNrLiBTa2lwIG92ZXJcbiAgLy8gdGhlIGV4dHJhIHNlZ21lbnRzIHVudGlsIHdlIHJlYWNoIHRoZSBsZWFmIHRhc2sgbm9kZS5cbiAgY29uc3Qgc2VydmVyQ2hpbGRyZW4gPSBzZXJ2ZXJSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBkeW5hbWljRGF0YUNoaWxkcmVuID0gZHluYW1pY0RhdGFbMl1cblxuICBmb3IgKGNvbnN0IHBhcmFsbGVsUm91dGVLZXkgaW4gc2VydmVyUm91dGVyU3RhdGUpIHtcbiAgICBjb25zdCBzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICBzZXJ2ZXJDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGR5bmFtaWNEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgZHluYW1pY0RhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuXG4gICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGFza1NlZ21lbnQgPSB0YXNrQ2hpbGQucm91dGVbMF1cbiAgICAgIGlmIChcbiAgICAgICAgbWF0Y2hTZWdtZW50KHNlcnZlclJvdXRlclN0YXRlQ2hpbGRbMF0sIHRhc2tTZWdtZW50KSAmJlxuICAgICAgICBkeW5hbWljRGF0YUNoaWxkICE9PSBudWxsICYmXG4gICAgICAgIGR5bmFtaWNEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgcmV0dXJuIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgICAgICAgICB0YXNrQ2hpbGQsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBkeW5hbWljRGF0YUNoaWxkLFxuICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZGlkbid0IGZpbmQgYSBjaGlsZCB0YXNrIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIGRhdGEuIFdlIHdvbid0IGFib3J0XG4gICAgLy8gdGhlIHRhc2ssIHRob3VnaCwgYmVjYXVzZSBhIGRpZmZlcmVudCBGbGlnaHREYXRhUGF0aCBtYXkgYmUgYWJsZSB0b1xuICAgIC8vIGZ1bGZpbGwgaXQgKHNlZSBsb29wIGluIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KS4gV2Ugb25seSBhYm9ydCB0YXNrc1xuICAgIC8vIG9uY2Ugd2UndmUgcnVuIG91dCBvZiBkYXRhLlxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFJlYWR5Q2FjaGVOb2RlIHtcbiAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdXG4gIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkcmVuID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzJdIDogbnVsbFxuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gbmV3IE1hcCgpXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsIHwgdm9pZCA9XG4gICAgICBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbFxuICAgICAgICA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgIDogbnVsbFxuXG4gICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHNlZ21lbnRQYXRoQ2hpbGQgPSBzZWdtZW50UGF0aC5jb25jYXQoW1xuICAgICAgcGFyYWxsZWxSb3V0ZUtleSxcbiAgICAgIHNlZ21lbnRDaGlsZCxcbiAgICBdKVxuICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRDaGlsZClcblxuICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gY3JlYXRlUGVuZGluZ0NhY2hlTm9kZShcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgcm91dGVyU3RhdGVDaGlsZCxcbiAgICAgIHByZWZldGNoRGF0YUNoaWxkID09PSB1bmRlZmluZWQgPyBudWxsIDogcHJlZmV0Y2hEYXRhQ2hpbGQsXG4gICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICBzZWdtZW50UGF0aENoaWxkLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKVxuXG4gICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkOiBDaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKClcbiAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KHNlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgcGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgfVxuXG4gIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgLy8gb24gY29ycmVzcG9uZGluZyBsb2dpYyBpbiBmaWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC50c1xuICBjb25zdCBpc0xlYWZTZWdtZW50ID0gcGFyYWxsZWxSb3V0ZXMuc2l6ZSA9PT0gMFxuXG4gIGlmIChpc0xlYWZTZWdtZW50KSB7XG4gICAgLy8gVGhlIHNlZ21lbnQgcGF0aCBvZiBldmVyeSBsZWFmIHNlZ21lbnQgKGkuZS4gcGFnZSkgaXMgY29sbGVjdGVkIGludG9cbiAgICAvLyBhIHJlc3VsdCBhcnJheS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBMYXlvdXRSb3V0ZXIgdG8gc2Nyb2xsIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gbmV3IHBhZ2VzIGFyZSB2aXNpYmxlIGFmdGVyIGEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgdXNlIGEgc3RyaW5nIHRvIHJlcHJlc2VudCB0aGUgc2VnbWVudCBwYXRoIGluc3RlYWQgb2ZcbiAgICAvLyBhbiBhcnJheS4gV2UgYWxyZWFkeSB1c2UgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwYXRoIHdoZW5cbiAgICAvLyBhY2Nlc3NpbmcgdGhlIFNlZ21lbnQgQ2FjaGUsIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgb25lLlxuICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdC5wdXNoKHNlZ21lbnRQYXRoKVxuICB9XG5cbiAgY29uc3QgbWF5YmVQcmVmZXRjaFJzYyA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsxXSA6IG51bGxcbiAgY29uc3QgbWF5YmVQcmVmZXRjaExvYWRpbmcgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbM10gOiBudWxsXG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcGFyYWxsZWxSb3V0ZXM6IHBhcmFsbGVsUm91dGVzLFxuXG4gICAgcHJlZmV0Y2hSc2M6IG1heWJlUHJlZmV0Y2hSc2MgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hSc2MgOiBudWxsLFxuICAgIHByZWZldGNoSGVhZDogaXNMZWFmU2VnbWVudCA/IHByZWZldGNoSGVhZCA6IFtudWxsLCBudWxsXSxcblxuICAgIC8vIFRPRE86IFRlY2huaWNhbGx5LCBhIGxvYWRpbmcgYm91bmRhcnkgY291bGQgY29udGFpbiBkeW5hbWljIGRhdGEuIFdlIG11c3RcbiAgICAvLyBoYXZlIHNlcGFyYXRlIGBsb2FkaW5nYCBhbmQgYHByZWZldGNoTG9hZGluZ2AgZmllbGRzIHRvIGhhbmRsZSB0aGlzLCBsaWtlXG4gICAgLy8gd2UgZG8gZm9yIHRoZSBzZWdtZW50IGRhdGEgYW5kIGhlYWQuXG4gICAgbG9hZGluZzogbWF5YmVQcmVmZXRjaExvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hMb2FkaW5nIDogbnVsbCxcblxuICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIHByb21pc2UuIFRoaXMgd2lsbCBiZSBmdWxmaWxsZWQgb25jZSB0aGUgZHluYW1pY1xuICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICByc2M6IGNyZWF0ZURlZmVycmVkUnNjKCkgYXMgUmVhY3QuUmVhY3ROb2RlLFxuICAgIGhlYWQ6IGlzTGVhZlNlZ21lbnQgPyAoY3JlYXRlRGVmZXJyZWRSc2MoKSBhcyBSZWFjdC5SZWFjdE5vZGUpIDogbnVsbCxcblxuICAgIG5hdmlnYXRlZEF0LFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gIGNhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICB0YXNrU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBzZXJ2ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGR5bmFtaWNEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgZHluYW1pY0hlYWQ6IEhlYWREYXRhXG4pOiB2b2lkIHtcbiAgLy8gV3JpdGVzIGEgZHluYW1pYyByZXNwb25zZSBpbnRvIGFuIGV4aXN0aW5nIENhY2hlIE5vZGUgdHJlZS4gVGhpcyBkb2VzIF9ub3RfXG4gIC8vIGNyZWF0ZSBhIG5ldyB0cmVlLCBpdCB1cGRhdGVzIHRoZSBleGlzdGluZyB0cmVlIGluLXBsYWNlLiBTbyBpdCBtdXN0IGZvbGxvd1xuICAvLyB0aGUgU3VzcGVuc2UgcnVsZXMgb2YgY2FjaGUgc2FmZXR5IOKAlCBpdCBjYW4gcmVzb2x2ZSBwZW5kaW5nIHByb21pc2VzLCBidXRcbiAgLy8gaXQgY2Fubm90IG92ZXJ3cml0ZSBleGlzdGluZyBkYXRhLiBJdCBjYW4gYWRkIHNlZ21lbnRzIHRvIHRoZSB0cmVlIChiZWNhdXNlXG4gIC8vIGEgbWlzc2luZyBzZWdtZW50IHdpbGwgY2F1c2UgdGhlIGxheW91dCByb3V0ZXIgdG8gc3VzcGVuZCkuXG4gIC8vIGJ1dCBpdCBjYW5ub3QgZGVsZXRlIHRoZW0uXG4gIC8vXG4gIC8vIFdlIG11c3QgcmVzb2x2ZSBldmVyeSBwcm9taXNlIGluIHRoZSB0cmVlLCBvciBlbHNlIGl0IHdpbGwgc3VzcGVuZFxuICAvLyBpbmRlZmluaXRlbHkuIElmIHdlIGRpZCBub3QgcmVjZWl2ZSBkYXRhIGZvciBhIHNlZ21lbnQsIHdlIHdpbGwgcmVzb2x2ZSBpdHNcbiAgLy8gZGF0YSBwcm9taXNlIHRvIGBudWxsYCB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICBjb25zdCB0YXNrU3RhdGVDaGlsZHJlbiA9IHRhc2tTdGF0ZVsxXVxuICBjb25zdCBzZXJ2ZXJTdGF0ZUNoaWxkcmVuID0gc2VydmVyU3RhdGVbMV1cbiAgY29uc3QgZGF0YUNoaWxkcmVuID0gZHluYW1pY0RhdGFbMl1cblxuICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgd2UgdHJhdmVyc2UgdGhlIHRyZWUgd2l0aCAodGFza1N0YXRlKSBpcyB0aGUgc2FtZSBvbmVcbiAgLy8gdGhhdCB3ZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcGVuZGluZyBDYWNoZSBOb2RlIHRyZWUuIFRoYXQgd2F5IHdlJ3JlIHN1cmVcbiAgLy8gdG8gcmVzb2x2ZSBhbGwgdGhlIHBlbmRpbmcgcHJvbWlzZXMuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gY2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gdGFza1N0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0YXNrU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgdGFza1N0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBzZXJ2ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQgPVxuICAgICAgc2VydmVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGRhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsIHwgdm9pZCA9XG4gICAgICBkYXRhQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cblxuICAgIGNvbnN0IHNlZ21lbnRNYXBDaGlsZCA9IHBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGNvbnN0IHRhc2tTZWdtZW50Q2hpbGQgPSB0YXNrU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHRhc2tTZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleSh0YXNrU2VnbWVudENoaWxkKVxuXG4gICAgY29uc3QgY2FjaGVOb2RlQ2hpbGQgPVxuICAgICAgc2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzZWdtZW50TWFwQ2hpbGQuZ2V0KHRhc2tTZWdtZW50S2V5Q2hpbGQpXG4gICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBpZiAoY2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKFxuICAgICAgICBzZXJ2ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbWF0Y2hTZWdtZW50KHRhc2tTZWdtZW50Q2hpbGQsIHNlcnZlclN0YXRlQ2hpbGRbMF0pXG4gICAgICApIHtcbiAgICAgICAgaWYgKGRhdGFDaGlsZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGhhcHB5IHBhdGguIFJlY3Vyc2l2ZWx5IHVwZGF0ZSBhbGwgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICAgICAgICBjYWNoZU5vZGVDaGlsZCxcbiAgICAgICAgICAgIHRhc2tTdGF0ZUNoaWxkLFxuICAgICAgICAgICAgc2VydmVyU3RhdGVDaGlsZCxcbiAgICAgICAgICAgIGRhdGFDaGlsZCxcbiAgICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgbmV2ZXIgcmV0dXJuZWQgZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUcmlnZ2VyIGEgbGF6eVxuICAgICAgICAgIC8vIGZldGNoIGR1cmluZyByZW5kZXIuIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoZSBSb3V0ZSBUcmVlXG4gICAgICAgICAgLy8gYW5kIHRoZSBTZWVkIERhdGEgdHJlZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgc2FtZVxuICAgICAgICAgIC8vIHNoYXBlIHdoZW4gcGFydCBvZiB0aGUgc2FtZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2tTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBuZXZlciByZXR1cm5lZCBkYXRhIGZvciB0aGlzIHNlZ21lbnQuIFRyaWdnZXIgYSBsYXp5XG4gICAgICAgIC8vIGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrU3RhdGVDaGlsZCwgY2FjaGVOb2RlQ2hpbGQsIG51bGwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBzZXJ2ZXIgcmVzcG9uc2UgbWF0Y2hlcyB3aGF0IHdhcyBleHBlY3RlZCB0byByZWNlaXZlLCBidXQgdGhlcmUnc1xuICAgICAgLy8gbm8gbWF0Y2hpbmcgQ2FjaGUgTm9kZSBpbiB0aGUgdGFzayB0cmVlLiBUaGlzIGlzIGEgYnVnIGluIHRoZVxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBjcmVhdGVkIGEgbm9kZSBmb3IgZXZlcnlcbiAgICAgIC8vIHNlZ21lbnQgaW4gdGhlIHRyZWUgdGhhdCdzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRhc2suXG4gICAgfVxuICB9XG5cbiAgLy8gVXNlIHRoZSBkeW5hbWljIGRhdGEgZnJvbSB0aGUgc2VydmVyIHRvIGZ1bGZpbGwgdGhlIGRlZmVycmVkIFJTQyBwcm9taXNlXG4gIC8vIG9uIHRoZSBDYWNoZSBOb2RlLlxuICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjXG4gIGNvbnN0IGR5bmFtaWNTZWdtZW50RGF0YSA9IGR5bmFtaWNEYXRhWzFdXG4gIGlmIChyc2MgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgbGF6eSBjYWNoZSBub2RlLiBXZSBjYW4gb3ZlcndyaXRlIGl0LiBUaGlzIGlzIG9ubHkgc2FmZVxuICAgIC8vIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHRoZSBMYXlvdXRSb3V0ZXIgc3VzcGVuZHMgaWYgYHJzY2AgaXMgYG51bGxgLlxuICAgIGNhY2hlTm9kZS5yc2MgPSBkeW5hbWljU2VnbWVudERhdGFcbiAgfSBlbHNlIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVmZXJyZWQgUlNDIHByb21pc2UuIFdlIGNhbiBmdWxmaWxsIGl0IHdpdGggdGhlIGRhdGEgd2UganVzdFxuICAgIC8vIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gSWYgaXQgd2FzIGFscmVhZHkgcmVzb2x2ZWQgYnkgYSBkaWZmZXJlbnRcbiAgICAvLyBuYXZpZ2F0aW9uLCB0aGVuIHRoaXMgZG9lcyBub3RoaW5nIGJlY2F1c2Ugd2UgY2FuJ3Qgb3ZlcndyaXRlIGRhdGEuXG4gICAgcnNjLnJlc29sdmUoZHluYW1pY1NlZ21lbnREYXRhKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbm90IGEgZGVmZXJyZWQgUlNDIHByb21pc2UsIG5vciBpcyBpdCBlbXB0eSwgc28gaXQgbXVzdCBoYXZlXG4gICAgLy8gYmVlbiBwb3B1bGF0ZWQgYnkgYSBkaWZmZXJlbnQgbmF2aWdhdGlvbi4gV2UgbXVzdCBub3Qgb3ZlcndyaXRlIGl0LlxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudC4gSWYgc28sIGl0IHdpbGwgaGF2ZSBhIGBoZWFkYCBwcm9wZXJ0eSB3aXRoXG4gIC8vIGEgcGVuZGluZyBwcm9taXNlIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZHluYW1pYyBoZWFkIGZyb21cbiAgLy8gdGhlIHNlcnZlci5cbiAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkXG4gIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgaGVhZC5yZXNvbHZlKGR5bmFtaWNIZWFkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydFRhc2sodGFzazogU1BBTmF2aWdhdGlvblRhc2ssIGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgY29uc3QgY2FjaGVOb2RlID0gdGFzay5ub2RlXG4gIGlmIChjYWNoZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGluZGljYXRlcyB0aGUgdGFzayBpcyBhbHJlYWR5IGNvbXBsZXRlLlxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlblxuICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgLy8gUmVhY2hlZCB0aGUgbGVhZiB0YXNrIG5vZGUuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSBwZW5kaW5nIGNhY2hlXG4gICAgLy8gbm9kZSB0cmVlLlxuICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrLnJvdXRlLCBjYWNoZU5vZGUsIGVycm9yKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXRlIHRhc2sgbm9kZS4gS2VlcCB0cmF2ZXJzaW5nIHVudGlsIHdlIHJlYWNoIGFcbiAgICAvLyB0YXNrIG5vZGUgd2l0aCBubyBjaGlsZHJlbi4gVGhhdCB3aWxsIGJlIHRoZSByb290IG9mIHRoZSBjYWNoZSBub2RlIHRyZWVcbiAgICAvLyB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkLlxuICAgIGZvciAoY29uc3QgdGFza0NoaWxkIG9mIHRhc2tDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgYWJvcnRUYXNrKHRhc2tDaGlsZCwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgdGFzayBpcyBub3cgY29tcGxldGUuXG4gIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbFxufVxuXG5mdW5jdGlvbiBhYm9ydFBlbmRpbmdDYWNoZU5vZGUoXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgY2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIGVycm9yOiBhbnlcbik6IHZvaWQge1xuICAvLyBGb3IgZXZlcnkgcGVuZGluZyBzZWdtZW50IGluIHRoZSB0cmVlLCByZXNvbHZlIGl0cyBgcnNjYCBwcm9taXNlIHRvIGBudWxsYFxuICAvLyB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAvL1xuICAvLyBPciwgaWYgYW4gZXJyb3Igb2JqZWN0IGlzIHByb3ZpZGVkLCBpdCB3aWxsIGVycm9yIGluc3RlYWQuXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IGNhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgc2VnbWVudE1hcENoaWxkID0gcGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgaWYgKHNlZ21lbnRNYXBDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB3ZSdyZSB0cmF2ZXJzaW5nIHRoZSBzYW1lIHRyZWUgdGhhdCB3YXNcbiAgICAgIC8vIHVzZWQgdG8gY29uc3RydWN0IHRoZSBjYWNoZSBub2RlcyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuICAgIGNvbnN0IGNhY2hlTm9kZUNoaWxkID0gc2VnbWVudE1hcENoaWxkLmdldChzZWdtZW50S2V5Q2hpbGQpXG4gICAgaWYgKGNhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZShyb3V0ZXJTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHdlJ3JlIHRyYXZlcnNpbmcgdGhlIHNhbWUgdHJlZSB0aGF0IHdhc1xuICAgICAgLy8gdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNhY2hlIG5vZGVzIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICB9XG4gIH1cbiAgY29uc3QgcnNjID0gY2FjaGVOb2RlLnJzY1xuICBpZiAoaXNEZWZlcnJlZFJzYyhyc2MpKSB7XG4gICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgIHJzYy5yZXNvbHZlKG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGR1cmluZyByZW5kZXJpbmcuXG4gICAgICByc2MucmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQuIElmIHNvLCBpdCB3aWxsIGhhdmUgYSBgaGVhZGAgcHJvcGVydHkgd2l0aFxuICAvLyBhIHBlbmRpbmcgcHJvbWlzZSB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkLiBJZiBhbiBlcnJvciB3YXMgcHJvdmlkZWQsIHdlXG4gIC8vIHdpbGwgbm90IHJlc29sdmUgaXQgd2l0aCBhbiBlcnJvciwgc2luY2UgdGhpcyBpcyByZW5kZXJlZCBhdCB0aGUgcm9vdCBvZlxuICAvLyB0aGUgYXBwLiBXZSB3YW50IHRoZSBzZWdtZW50IHRvIGVycm9yLCBub3QgdGhlIGVudGlyZSBhcHAuXG4gIGNvbnN0IGhlYWQgPSBjYWNoZU5vZGUuaGVhZFxuICBpZiAoaXNEZWZlcnJlZFJzYyhoZWFkKSkge1xuICAgIGhlYWQucmVzb2x2ZShudWxsKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24oXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IFJlYWR5Q2FjaGVOb2RlIHtcbiAgLy8gQSBwb3BzdGF0ZSBuYXZpZ2F0aW9uIHJlYWRzIGRhdGEgZnJvbSB0aGUgbG9jYWwgY2FjaGUuIEl0IGRvZXMgbm90IGlzc3VlXG4gIC8vIG5ldyBuZXR3b3JrIHJlcXVlc3RzICh1bmxlc3MgdGhlIGNhY2hlIGVudHJpZXMgaGF2ZSBiZWVuIGV2aWN0ZWQpLiBTbywgd2VcbiAgLy8gdXBkYXRlIHRoZSBjYWNoZSB0byBkcm9wIHRoZSBwcmVmZXRjaCBkYXRhIGZvciBhbnkgc2VnbWVudCB3aG9zZSBkeW5hbWljXG4gIC8vIGRhdGEgd2FzIGFscmVhZHkgcmVjZWl2ZWQuIFRoaXMgcHJldmVudHMgYW4gdW5uZWNlc3NhcnkgZmxhc2ggYmFjayB0byBQUFJcbiAgLy8gc3RhdGUgZHVyaW5nIGEgYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gIC8vXG4gIC8vIFRoaXMgZnVuY3Rpb24gY2xvbmVzIHRoZSBlbnRpcmUgY2FjaGUgbm9kZSB0cmVlIGFuZCBzZXRzIHRoZSBgcHJlZmV0Y2hSc2NgXG4gIC8vIGZpZWxkIHRvIGBudWxsYCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQuIFdlIGNhbid0IG11dGF0ZSB0aGUgbm9kZVxuICAvLyBpbiBwbGFjZSBiZWNhdXNlIHRoaXMgaXMgYSBjb25jdXJyZW50IGRhdGEgc3RydWN0dXJlLlxuXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBvbGRQYXJhbGxlbFJvdXRlcyA9IG9sZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBjb25zdCBuZXdQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuICAgIGNvbnN0IG9sZFNlZ21lbnRNYXBDaGlsZCA9IG9sZFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmIChvbGRTZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPSBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZClcbiAgICAgIGlmIChvbGRDYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uKFxuICAgICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgIHJvdXRlclN0YXRlQ2hpbGRcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQgPSBuZXcgTWFwKG9sZFNlZ21lbnRNYXBDaGlsZClcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgICAgICBuZXdQYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgc2hvdyBwcmVmZXRjaGVkIGRhdGEgaWYgdGhlIGR5bmFtaWMgZGF0YSBpcyBzdGlsbCBwZW5kaW5nLlxuICAvL1xuICAvLyBUZWhuaWNhbGx5LCB3aGF0IHdlJ3JlIGFjdHVhbGx5IGNoZWNraW5nIGlzIHdoZXRoZXIgdGhlIGR5bmFtaWMgbmV0d29ya1xuICAvLyByZXNwb25zZSB3YXMgcmVjZWl2ZWQuIEJ1dCBzaW5jZSBpdCdzIGEgc3RyZWFtaW5nIHJlc3BvbnNlLCB0aGlzIGRvZXMgbm90XG4gIC8vIG1lYW4gdGhhdCBhbGwgdGhlIGR5bmFtaWMgZGF0YSBoYXMgZnVsbHkgc3RyZWFtZWQgaW4uIEl0IGp1c3QgbWVhbnMgdGhhdFxuICAvLyBfc29tZV8gb2YgdGhlIGR5bmFtaWMgZGF0YSB3YXMgcmVjZWl2ZWQuIEJ1dCBhcyBhIGhldXJpc3RpYywgd2UgYXNzdW1lIHRoYXRcbiAgLy8gdGhlIHJlc3QgZHluYW1pYyBkYXRhIHdpbGwgc3RyZWFtIGluIHF1aWNrbHksIHNvIGl0J3Mgc3RpbGwgYmV0dGVyIHRvIHNraXBcbiAgLy8gdGhlIHByZWZldGNoIHN0YXRlLlxuICBjb25zdCByc2MgPSBvbGRDYWNoZU5vZGUucnNjXG4gIGNvbnN0IHNob3VsZFVzZVByZWZldGNoID0gaXNEZWZlcnJlZFJzYyhyc2MpICYmIHJzYy5zdGF0dXMgPT09ICdwZW5kaW5nJ1xuXG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjLFxuICAgIGhlYWQ6IG9sZENhY2hlTm9kZS5oZWFkLFxuXG4gICAgcHJlZmV0Y2hIZWFkOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQgOiBbbnVsbCwgbnVsbF0sXG4gICAgcHJlZmV0Y2hSc2M6IHNob3VsZFVzZVByZWZldGNoID8gb2xkQ2FjaGVOb2RlLnByZWZldGNoUnNjIDogbnVsbCxcbiAgICBsb2FkaW5nOiBvbGRDYWNoZU5vZGUubG9hZGluZyxcblxuICAgIC8vIFRoZXNlIGFyZSB0aGUgY2xvbmVkIGNoaWxkcmVuIHdlIGNvbXB1dGVkIGFib3ZlXG4gICAgcGFyYWxsZWxSb3V0ZXM6IG5ld1BhcmFsbGVsUm91dGVzLFxuXG4gICAgbmF2aWdhdGVkQXQ6IG9sZENhY2hlTm9kZS5uYXZpZ2F0ZWRBdCxcbiAgfVxufVxuXG5jb25zdCBERUZFUlJFRCA9IFN5bWJvbCgpXG5cbnR5cGUgUGVuZGluZ0RlZmVycmVkUnNjID0gUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+ICYge1xuICBzdGF0dXM6ICdwZW5kaW5nJ1xuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgRnVsZmlsbGVkRGVmZXJyZWRSc2MgPSBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4gJiB7XG4gIHN0YXR1czogJ2Z1bGZpbGxlZCdcbiAgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZVxuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgUmVqZWN0ZWREZWZlcnJlZFJzYyA9IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPiAmIHtcbiAgc3RhdHVzOiAncmVqZWN0ZWQnXG4gIHJlYXNvbjogYW55XG4gIHJlc29sdmU6ICh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSA9PiB2b2lkXG4gIHJlamVjdDogKGVycm9yOiBhbnkpID0+IHZvaWRcbiAgdGFnOiBTeW1ib2xcbn1cblxudHlwZSBEZWZlcnJlZFJzYyA9XG4gIHwgUGVuZGluZ0RlZmVycmVkUnNjXG4gIHwgRnVsZmlsbGVkRGVmZXJyZWRSc2NcbiAgfCBSZWplY3RlZERlZmVycmVkUnNjXG5cbi8vIFRoaXMgdHlwZSBleGlzdHMgdG8gZGlzdGluZ3Vpc2ggYSBEZWZlcnJlZFJzYyBmcm9tIGEgRmxpZ2h0IHByb21pc2UuIEl0J3MgYVxuLy8gY29tcHJvbWlzZSB0byBhdm9pZCBhZGRpbmcgYW4gZXh0cmEgZmllbGQgb24gZXZlcnkgQ2FjaGUgTm9kZSwgd2hpY2ggd291bGQgYmVcbi8vIGF3a3dhcmQgYmVjYXVzZSB0aGUgcHJlLVBQUiBwYXJ0cyBvZiBjb2RlYmFzZSB3b3VsZCBuZWVkIHRvIGFjY291bnQgZm9yIGl0LFxuLy8gdG9vLiBXZSBjYW4gcmVtb3ZlIGl0IG9uY2UgdHlwZSBDYWNoZSBOb2RlIHR5cGUgaXMgbW9yZSBzZXR0bGVkLlxuZnVuY3Rpb24gaXNEZWZlcnJlZFJzYyh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGVmZXJyZWRSc2Mge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudGFnID09PSBERUZFUlJFRFxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZFJzYygpOiBQZW5kaW5nRGVmZXJyZWRSc2Mge1xuICBsZXQgcmVzb2x2ZTogYW55XG4gIGxldCByZWplY3Q6IGFueVxuICBjb25zdCBwZW5kaW5nUnNjID0gbmV3IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzXG4gICAgcmVqZWN0ID0gcmVqXG4gIH0pIGFzIFBlbmRpbmdEZWZlcnJlZFJzY1xuICBwZW5kaW5nUnNjLnN0YXR1cyA9ICdwZW5kaW5nJ1xuICBwZW5kaW5nUnNjLnJlc29sdmUgPSAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4ge1xuICAgIGlmIChwZW5kaW5nUnNjLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICBjb25zdCBmdWxmaWxsZWRSc2M6IEZ1bGZpbGxlZERlZmVycmVkUnNjID0gcGVuZGluZ1JzYyBhcyBhbnlcbiAgICAgIGZ1bGZpbGxlZFJzYy5zdGF0dXMgPSAnZnVsZmlsbGVkJ1xuICAgICAgZnVsZmlsbGVkUnNjLnZhbHVlID0gdmFsdWVcbiAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgfVxuICB9XG4gIHBlbmRpbmdSc2MucmVqZWN0ID0gKGVycm9yOiBhbnkpID0+IHtcbiAgICBpZiAocGVuZGluZ1JzYy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgY29uc3QgcmVqZWN0ZWRSc2M6IFJlamVjdGVkRGVmZXJyZWRSc2MgPSBwZW5kaW5nUnNjIGFzIGFueVxuICAgICAgcmVqZWN0ZWRSc2Muc3RhdHVzID0gJ3JlamVjdGVkJ1xuICAgICAgcmVqZWN0ZWRSc2MucmVhc29uID0gZXJyb3JcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9XG4gIH1cbiAgcGVuZGluZ1JzYy50YWcgPSBERUZFUlJFRFxuICByZXR1cm4gcGVuZGluZ1JzY1xufVxuIl0sIm5hbWVzIjpbImFib3J0VGFzayIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0Iiwic3RhcnRQUFJOYXZpZ2F0aW9uIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiTVBBX05BVklHQVRJT05fVEFTSyIsInJvdXRlIiwibm9kZSIsImR5bmFtaWNSZXF1ZXN0VHJlZSIsImNoaWxkcmVuIiwibmF2aWdhdGVkQXQiLCJvbGRDYWNoZU5vZGUiLCJvbGRSb3V0ZXJTdGF0ZSIsIm5ld1JvdXRlclN0YXRlIiwicHJlZmV0Y2hEYXRhIiwicHJlZmV0Y2hIZWFkIiwiaXNQcmVmZXRjaEhlYWRQYXJ0aWFsIiwiaXNTYW1lUGFnZU5hdmlnYXRpb24iLCJzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQiLCJzZWdtZW50UGF0aCIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsImRpZEZpbmRSb290TGF5b3V0Iiwib2xkUm91dGVyU3RhdGVDaGlsZHJlbiIsIm5ld1JvdXRlclN0YXRlQ2hpbGRyZW4iLCJwcmVmZXRjaERhdGFDaGlsZHJlbiIsImlzUm9vdExheW91dCIsIm9sZFBhcmFsbGVsUm91dGVzIiwicGFyYWxsZWxSb3V0ZXMiLCJwcmVmZXRjaFBhcmFsbGVsUm91dGVzIiwiTWFwIiwicGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4iLCJ0YXNrQ2hpbGRyZW4iLCJuZWVkc0R5bmFtaWNSZXF1ZXN0IiwiZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW4iLCJwYXJhbGxlbFJvdXRlS2V5IiwibmV3Um91dGVyU3RhdGVDaGlsZCIsIm9sZFJvdXRlclN0YXRlQ2hpbGQiLCJvbGRTZWdtZW50TWFwQ2hpbGQiLCJnZXQiLCJwcmVmZXRjaERhdGFDaGlsZCIsIm5ld1NlZ21lbnRDaGlsZCIsIm5ld1NlZ21lbnRQYXRoQ2hpbGQiLCJjb25jYXQiLCJuZXdTZWdtZW50S2V5Q2hpbGQiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsIm9sZFNlZ21lbnRDaGlsZCIsInVuZGVmaW5lZCIsIm9sZENhY2hlTm9kZUNoaWxkIiwidGFza0NoaWxkIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInNwYXduUmV1c2VkVGFzayIsImJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsInNldCIsIm5ld0NhY2hlTm9kZUNoaWxkIiwibmV3U2VnbWVudE1hcENoaWxkIiwidGFza0NoaWxkUm91dGUiLCJkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCIsIm5ld0NhY2hlTm9kZSIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwibG9hZGluZyIsInBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4iLCJleGlzdGluZ0NhY2hlTm9kZSIsInBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNyZWF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsInJvdXRlclN0YXRlIiwicm91dGVyU3RhdGVDaGlsZHJlbiIsImlzTGVhZlNlZ21lbnQiLCJjYWNoZU5vZGVOYXZpZ2F0ZWRBdCIsIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiaXNQcmVmZXRjaFJzY1BhcnRpYWwiLCJzcGF3blBlbmRpbmdUYXNrIiwiZXhpc3RpbmdDYWNoZU5vZGVDaGlsZHJlbiIsImNhY2hlTm9kZUNoaWxkcmVuIiwicHVzaCIsInJvdXRlclN0YXRlQ2hpbGQiLCJleGlzdGluZ1NlZ21lbnRNYXBDaGlsZCIsInNlZ21lbnRDaGlsZCIsInNlZ21lbnRQYXRoQ2hpbGQiLCJzZWdtZW50S2V5Q2hpbGQiLCJleGlzdGluZ0NhY2hlTm9kZUNoaWxkIiwiYmFzZVJvdXRlclN0YXRlIiwibmV3Q2hpbGRyZW4iLCJjbG9uZSIsIm5ld1Rhc2siLCJjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlIiwicmV1c2VkUm91dGVyU3RhdGUiLCJ0YXNrIiwicmVzcG9uc2VQcm9taXNlIiwidGhlbiIsImZsaWdodERhdGEiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWUiLCJzZXJ2ZXJSb3V0ZXJTdGF0ZSIsInNlZWREYXRhIiwiZHluYW1pY0RhdGEiLCJkeW5hbWljSGVhZCIsIndyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2siLCJlcnJvciIsInJvb3RUYXNrIiwiaSIsInNlZ21lbnQiLCJ0YXNrU2VnbWVudCIsImZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCIsInRhc2tOb2RlIiwiZmluaXNoUGVuZGluZ0NhY2hlTm9kZSIsInNlcnZlckNoaWxkcmVuIiwiZHluYW1pY0RhdGFDaGlsZHJlbiIsInNlcnZlclJvdXRlclN0YXRlQ2hpbGQiLCJkeW5hbWljRGF0YUNoaWxkIiwic2l6ZSIsIm1heWJlUHJlZmV0Y2hSc2MiLCJtYXliZVByZWZldGNoTG9hZGluZyIsImNyZWF0ZURlZmVycmVkUnNjIiwiY2FjaGVOb2RlIiwidGFza1N0YXRlIiwic2VydmVyU3RhdGUiLCJ0YXNrU3RhdGVDaGlsZHJlbiIsInNlcnZlclN0YXRlQ2hpbGRyZW4iLCJkYXRhQ2hpbGRyZW4iLCJ0YXNrU3RhdGVDaGlsZCIsInNlcnZlclN0YXRlQ2hpbGQiLCJkYXRhQ2hpbGQiLCJzZWdtZW50TWFwQ2hpbGQiLCJ0YXNrU2VnbWVudENoaWxkIiwidGFza1NlZ21lbnRLZXlDaGlsZCIsImNhY2hlTm9kZUNoaWxkIiwiYWJvcnRQZW5kaW5nQ2FjaGVOb2RlIiwiZHluYW1pY1NlZ21lbnREYXRhIiwiaXNEZWZlcnJlZFJzYyIsInJlc29sdmUiLCJ2YWx1ZXMiLCJyZWplY3QiLCJuZXdQYXJhbGxlbFJvdXRlcyIsInNob3VsZFVzZVByZWZldGNoIiwic3RhdHVzIiwiREVGRVJSRUQiLCJTeW1ib2wiLCJ2YWx1ZSIsInRhZyIsInBlbmRpbmdSc2MiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiZnVsZmlsbGVkUnNjIiwicmVqZWN0ZWRSc2MiLCJyZWFzb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime, staleTime } = param;\n    if (staleTime !== -1) {\n        // `staleTime` is the value sent by the server during static generation.\n        // When this is available, it takes precedence over any of the heuristics\n        // that follow.\n        //\n        // TODO: When PPR is enabled, the server will *always* return a stale time\n        // when prefetching. We should never use a prefetch entry that hasn't yet\n        // received data from the server. So the only two cases should be 1) we use\n        // the server-generated stale time 2) the unresolved entry is discarded.\n        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;\n    }\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTRZYUEsb0JBQW9CO2VBQXBCQTs7SUFHQUMsbUJBQW1CO2VBQW5CQTs7SUFuSUdDLDhCQUE4QjtlQUE5QkE7O0lBOUdBQyw2QkFBNkI7ZUFBN0JBOztJQStOQUMsa0JBQWtCO2VBQWxCQTs7O2lEQTFYVDtnREFNQTs2Q0FDdUI7QUFFOUIsTUFBTUMsZ0NBQWdDO0FBVXRDOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLDJCQUNQQyxHQUFRLEVBQ1JDLG1CQUE0QixFQUM1QkMsTUFBc0I7SUFFdEIsZ0ZBQWdGO0lBQ2hGLGdGQUFnRjtJQUNoRixrQkFBa0I7SUFDbEIsSUFBSUMsa0JBQWtCSCxJQUFJSSxRQUFRO0lBRWxDLDRGQUE0RjtJQUM1Riw4REFBOEQ7SUFDOUQscUZBQXFGO0lBQ3JGLGdGQUFnRjtJQUNoRixxREFBcUQ7SUFDckQsSUFBSUgscUJBQXFCO1FBQ3ZCLDBFQUEwRTtRQUMxRSxrRkFBa0Y7UUFDbEYsNENBQTRDO1FBQzVDRSxtQkFBbUJILElBQUlLLE1BQU07SUFDL0I7SUFFQSxJQUFJSCxRQUFRO1FBQ1YsT0FBUSxLQUFFQSxTQUFTSixnQ0FBZ0NLO0lBQ3JEO0lBRUEsT0FBT0E7QUFDVDtBQUVBLFNBQVNHLHVCQUNQTixHQUFRLEVBQ1JPLElBQThCLEVBQzlCQyxPQUF1QjtJQUV2QixPQUFPVCwyQkFBMkJDLEtBQUtPLFNBQVNFLG9CQUFBQSxZQUFZLENBQUNDLElBQUksRUFBRUY7QUFDckU7QUFFQSxTQUFTRyxzQkFDUFgsR0FBUSxFQUNSTyxJQUEyQyxFQUMzQ0MsT0FBc0IsRUFDdEJJLGFBQThDLEVBQzlDQyxhQUFzQjtJQUh0Qk4sSUFBQUEsU0FBQUEsS0FBQUEsR0FBQUEsT0FBcUJFLG9CQUFBQSxZQUFZLENBQUNLLFNBQVM7SUFLM0MsOEVB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SUFBSTFELFNBQVNFLG9CQUFBQSxZQUFZLENBQUN1RSxJQUFJLEVBQUU7UUFDOUIsSUFBSXBCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZWpFLHFCQUFxQjtZQUNuRCxPQUFPc0Usb0JBQUFBLHdCQUF3QixDQUFDYyxLQUFLO1FBQ3ZDO0lBQ0Y7SUFFQSxpR0FBaUc7SUFDakcsSUFBSXZFLFNBQVNFLG9CQUFBQSxZQUFZLENBQUNDLElBQUksRUFBRTtRQUM5QixJQUFJa0QsS0FBS0MsR0FBRyxLQUFLRixlQUFlakUscUJBQXFCO1lBQ25ELE9BQU9zRSxvQkFBQUEsd0JBQXdCLENBQUNlLFFBQVE7UUFDMUM7SUFDRjtJQUVBLE9BQU9mLG9CQUFBQSx3QkFBd0IsQ0FBQ1UsT0FBTztBQUN6QyIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccHJlZmV0Y2gtY2FjaGUtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZmV0Y2hTZXJ2ZXJSZXNwb25zZSxcbiAgdHlwZSBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0LFxufSBmcm9tICcuL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7XG4gIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyxcbiAgdHlwZSBQcmVmZXRjaENhY2hlRW50cnksXG4gIFByZWZldGNoS2luZCxcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IHByZWZldGNoUXVldWUgfSBmcm9tICcuL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXInXG5cbmNvbnN0IElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSID0gJyUnXG5cbmV4cG9ydCB0eXBlIEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgPSBQcmVmZXRjaENhY2hlRW50cnkgJiB7XG4gIC8qKiBUaGlzIGlzIGEgc3BlY2lhbCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyBhIHByZWZldGNoIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCBhIGRpZmZlcmVudCBVUkxcbiAgICogd2FzIHJldHVybmVkIHJhdGhlciB0aGFuIHRoZSByZXF1ZXN0ZWQgVVJMLiBUaGlzIHNpZ25hbHMgdG8gdGhlIHJvdXRlciB0aGF0IGl0IHNob3VsZCBvbmx5XG4gICAqIGFwcGx5IHRoZSBwYXJ0IHRoYXQgZG9lc24ndCBkZXBlbmQgb24gc2VhcmNoUGFyYW1zIChzcGVjaWZpY2FsbHkgdGhlIGxvYWRpbmcgc3RhdGUpLlxuICAgKi9cbiAgYWxpYXNlZD86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2FjaGUga2V5IGZvciB0aGUgcm91dGVyIHByZWZldGNoIGNhY2hlXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYmVpbmcgbmF2aWdhdGVkIHRvXG4gKiBAcGFyYW0gbmV4dFVybCAtIGFuIGludGVybmFsIFVSTCwgcHJpbWFyaWx5IHVzZWQgZm9yIGhhbmRsaW5nIHJld3JpdGVzLiBEZWZhdWx0cyB0byAnLycuXG4gKiBAcmV0dXJuIFRoZSBnZW5lcmF0ZWQgcHJlZmV0Y2ggY2FjaGUga2V5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgdXJsOiBVUkwsXG4gIGluY2x1ZGVTZWFyY2hQYXJhbXM6IGJvb2xlYW4sXG4gIHByZWZpeD86IHN0cmluZyB8IG51bGxcbikge1xuICAvLyBJbml0aWFsbHkgd2Ugb25seSB1c2UgdGhlIHBhdGhuYW1lIGFzIHRoZSBjYWNoZSBrZXkuIFdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZVxuICAvLyBzZWFyY2ggcGFyYW1zIHNvIHRoYXQgbXVsdGlwbGUgVVJMcyB3aXRoIHRoZSBzYW1lIHNlYXJjaCBwYXJhbWV0ZXIgY2FuIHJlLXVzZVxuICAvLyBsb2FkaW5nIHN0YXRlcy5cbiAgbGV0IHBhdGhuYW1lRnJvbVVybCA9IHVybC5wYXRobmFtZVxuXG4gIC8vIFJTQyByZXNwb25zZXMgY2FuIGRpZmZlciBiYXNlZCBvbiBzZWFyY2ggcGFyYW1zLCBzcGVjaWZpY2FsbHkgaW4gdGhlIGNhc2Ugd2hlcmUgd2UgYXJlbid0XG4gIC8vIHJldHVybmluZyBhIHBhcnRpYWwgcmVzcG9uc2UgKGllIHdpdGggYFByZWZldGNoS2luZC5BVVRPYCkuXG4gIC8vIEluIHRoZSBhdXRvIGNhc2UsIHNpbmNlIGxvYWRpbmcuanMgJiBsYXlvdXQuanMgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gc2VhcmNoIHBhcmFtcyxcbiAgLy8gd2UgY2FuIHNhZmVseSByZS11c2UgdGhhdCBjYWNoZSBlbnRyeS4gQnV0IGZvciBmdWxsIHByZWZldGNoZXMsIHdlIHNob3VsZCBub3RcbiAgLy8gcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBhcyB0aGUgcmVzcG9uc2UgbWF5IGRpZmZlci5cbiAgaWYgKGluY2x1ZGVTZWFyY2hQYXJhbXMpIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIGluY2x1ZGUgdGhlIHNlYXJjaCBwYXJhbSBpbiB0aGUga2V5LFxuICAgIC8vIGFzIHdlJ2xsIGJlIGdldHRpbmcgYmFjayBhIGZ1bGwgcmVzcG9uc2UuIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSByZWFkIHRoZSBzZWFyY2hcbiAgICAvLyBwYXJhbXMgd2hlbiBnZW5lcmF0aW5nIHRoZSBmdWxsIHJlc3BvbnNlLlxuICAgIHBhdGhuYW1lRnJvbVVybCArPSB1cmwuc2VhcmNoXG4gIH1cblxuICBpZiAocHJlZml4KSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke0lOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSfSR7cGF0aG5hbWVGcm9tVXJsfWBcbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZUZyb21Vcmxcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCB8IHVuZGVmaW5lZCxcbiAgbmV4dFVybD86IHN0cmluZyB8IG51bGxcbikge1xuICByZXR1cm4gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwodXJsLCBraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCwgbmV4dFVybClcbn1cblxuZnVuY3Rpb24gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICB1cmw6IFVSTCxcbiAga2luZDogUHJlZmV0Y2hLaW5kID0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgcHJlZmV0Y2hDYWNoZTogTWFwPHN0cmluZywgUHJlZmV0Y2hDYWNoZUVudHJ5PixcbiAgYWxsb3dBbGlhc2luZzogYm9vbGVhblxuKTogQWxpYXNlZFByZWZldGNoQ2FjaGVFbnRyeSB8IHVuZGVmaW5lZCB7XG4gIC8vIFdlIGZpcnN0IGNoZWNrIGlmIHRoZXJlJ3MgYSBtb3JlIHNwZWNpZmljIGludGVyY2VwdGlvbiByb3V0ZSBwcmVmZXRjaCBlbnRyeVxuICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2hlbiB3ZSBkZXRlY3QgYSBwcmVmZXRjaCB0aGF0IGNvcnJlc3BvbmRzIHdpdGggYW4gaW50ZXJjZXB0aW9uIHJvdXRlLCB3ZSBwcmVmaXggaXQgd2l0aCBuZXh0VXJsIChzZWUgYGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlgKVxuICAvLyB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBvdGhlciBwYWdlcyB0aGF0IG1heSBoYXZlIHRoZSBzYW1lIFVSTCBidXQgcmVuZGVyIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBgTmV4dC1VUkxgIGhlYWRlci5cbiAgZm9yIChjb25zdCBtYXliZU5leHRVcmwgb2YgW25leHRVcmwsIG51bGxdKSB7XG4gICAgY29uc3QgY2FjaGVLZXlXaXRoUGFyYW1zID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gICAgICB1cmwsXG4gICAgICB0cnVlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuICAgIGNvbnN0IGNhY2hlS2V5V2l0aG91dFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgZmFsc2UsXG4gICAgICBtYXliZU5leHRVcmxcbiAgICApXG5cbiAgICAvLyBGaXJzdCwgd2UgY2hlY2sgaWYgd2UgaGF2ZSBhIGNhY2hlIGVudHJ5IHRoYXQgZXhhY3RseSBtYXRjaGVzIHRoZSBVUkxcbiAgICBjb25zdCBjYWNoZUtleVRvVXNlID0gdXJsLnNlYXJjaFxuICAgICAgPyBjYWNoZUtleVdpdGhQYXJhbXNcbiAgICAgIDogY2FjaGVLZXlXaXRob3V0UGFyYW1zXG5cbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlUb1VzZSlcbiAgICBpZiAoZXhpc3RpbmdFbnRyeSAmJiBhbGxvd0FsaWFzaW5nKSB7XG4gICAgICAvLyBXZSBrbm93IHdlJ3JlIHJldHVybmluZyBhbiBhbGlhc2VkIGVudHJ5IHdoZW4gdGhlIHBhdGhuYW1lIG1hdGNoZXMgYnV0IHRoZSBzZWFyY2ggcGFyYW1zIGRvbid0LFxuICAgICAgY29uc3QgaXNBbGlhc2VkID1cbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwucGF0aG5hbWUgPT09IHVybC5wYXRobmFtZSAmJlxuICAgICAgICBleGlzdGluZ0VudHJ5LnVybC5zZWFyY2ggIT09IHVybC5zZWFyY2hcblxuICAgICAgaWYgKGlzQWxpYXNlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nRW50cnksXG4gICAgICAgICAgYWxpYXNlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXF1ZXN0IGNvbnRhaW5zIHNlYXJjaCBwYXJhbXMsIGFuZCB3ZSdyZSBub3QgZG9pbmcgYSBmdWxsIHByZWZldGNoLCB3ZSBjYW4gcmV0dXJuIHRoZVxuICAgIC8vIHBhcmFtLWxlc3MgZW50cnkgaWYgaXQgZXhpc3RzLlxuICAgIC8vIFRoaXMgaXMgdGVjaG5pY2FsbHkgY292ZXJlZCBieSB0aGUgY2hlY2sgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZ1bmN0aW9uLCB3aGljaCBpdGVyYXRlcyBvdmVyIGNhY2hlIGVudHJpZXMsXG4gICAgLy8gYnV0IGxldHMgdXMgYXJyaXZlIHRoZXJlIHF1aWNrZXIgaW4gdGhlIHBhcmFtLWZ1bGwgY2FzZS5cbiAgICBjb25zdCBlbnRyeVdpdGhvdXRQYXJhbXMgPSBwcmVmZXRjaENhY2hlLmdldChjYWNoZUtleVdpdGhvdXRQYXJhbXMpXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIGFsbG93QWxpYXNpbmcgJiZcbiAgICAgIHVybC5zZWFyY2ggJiZcbiAgICAgIGtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgICBlbnRyeVdpdGhvdXRQYXJhbXMgJiZcbiAgICAgIC8vIFdlIHNob3VsZG4ndCByZXR1cm4gdGhlIGFsaWFzZWQgZW50cnkgaWYgaXQgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBjYWNoZSBrZXkuXG4gICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICFlbnRyeVdpdGhvdXRQYXJhbXMua2V5LmluY2x1ZGVzKElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSKVxuICAgICkge1xuICAgICAgcmV0dXJuIHsgLi4uZW50cnlXaXRob3V0UGFyYW1zLCBhbGlhc2VkOiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgd2UgZGlkbid0IGZpbmQgYSBzcGVjaWZpYyBjYWNoZSBlbnRyeSB0aGF0IG1hdGNoZWRcbiAgLy8gdGhlIHJlcXVlc3QgVVJMLlxuICAvLyBXZSBhdHRlbXB0IGEgcGFydGlhbCBtYXRjaCBieSBjaGVja2luZyBpZiB0aGVyZSdzIGEgY2FjaGUgZW50cnkgd2l0aCB0aGUgc2FtZSBwYXRobmFtZS5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGF0IHdlIGZpbmQsIHNpbmNlIGl0IGRvZXNuJ3QgY29ycmVzcG9uZCB3aXRoIHRoZSByZXF1ZXN0ZWQgVVJMLCB3ZSdsbCBtYXJrIGl0IFwiYWxpYXNlZFwiLlxuICAvLyBUaGlzIHdpbGwgc2lnbmFsIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seSBhcHBseSB0aGUgbG9hZGluZyBzdGF0ZSBvbiB0aGUgcHJlZmV0Y2hlZCBkYXRhLlxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgIGFsbG93QWxpYXNpbmdcbiAgKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZUVudHJ5IG9mIHByZWZldGNoQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgY2FjaGVFbnRyeS51cmwucGF0aG5hbWUgPT09IHVybC5wYXRobmFtZSAmJlxuICAgICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgIWNhY2hlRW50cnkua2V5LmluY2x1ZGVzKElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7IC4uLmNhY2hlRW50cnksIGFsaWFzZWQ6IHRydWUgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZmV0Y2ggY2FjaGUgZW50cnkgaWYgb25lIGV4aXN0cy4gT3RoZXJ3aXNlIGNyZWF0ZXMgYSBuZXcgb25lIGFuZCBlbnF1ZXVlcyBhIGZldGNoIHJlcXVlc3RcbiAqIHRvIHJldHJpZXZlIHRoZSBwcmVmZXRjaCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgdXJsLFxuICBuZXh0VXJsLFxuICB0cmVlLFxuICBwcmVmZXRjaENhY2hlLFxuICBraW5kLFxuICBhbGxvd0FsaWFzaW5nID0gdHJ1ZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICdwcmVmZXRjaENhY2hlJyB8ICd0cmVlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ/OiBQcmVmZXRjaEtpbmRcbiAgYWxsb3dBbGlhc2luZzogYm9vbGVhblxufSk6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkge1xuICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBnZXRFeGlzdGluZ0NhY2hlRW50cnkoXG4gICAgdXJsLFxuICAgIGtpbmQsXG4gICAgbmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlLFxuICAgIGFsbG93QWxpYXNpbmdcbiAgKVxuXG4gIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBHcmFiIHRoZSBsYXRlc3Qgc3RhdHVzIG9mIHRoZSBjYWNoZSBlbnRyeSBhbmQgdXBkYXRlIGl0XG4gICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YXR1cyA9IGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhleGlzdGluZ0NhY2hlRW50cnkpXG5cbiAgICAvLyB3aGVuIGBraW5kYCBpcyBwcm92aWRlZCwgYW4gZXhwbGljaXQgcHJlZmV0Y2ggd2FzIHJlcXVlc3RlZC5cbiAgICAvLyBpZiB0aGUgcmVxdWVzdGVkIHByZWZldGNoIGlzIFwiZnVsbFwiIGFuZCB0aGUgY3VycmVudCBjYWNoZSBlbnRyeSB3YXNuJ3QsIHdlIHdhbnQgdG8gcmUtcHJlZmV0Y2ggd2l0aCB0aGUgbmV3IGludGVudFxuICAgIGNvbnN0IHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2ggPVxuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgICBraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTFxuXG4gICAgaWYgKHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2gpIHtcbiAgICAgIC8vIElmIHdlIHN3aXRjaGVkIHRvIGEgZnVsbCBwcmVmZXRjaCwgdmFsaWRhdGUgdGhhdCB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgY29udGFpbmVkIHBhcnRpYWwgZGF0YS5cbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgY2FjaGUgZW50cnkgd2FzIHNlZWRlZCB3aXRoIGZ1bGwgZGF0YSBidXQgaGFzIGEgY2FjaGUgdHlwZSBvZiBcImF1dG9cIiAoaWUgd2hlbiBjYWNoZSBlbnRyaWVzXG4gICAgICAvLyBhcmUgc2VlZGVkIGJ1dCB3aXRob3V0IGEgcHJlZmV0Y2ggaW50ZW50KVxuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmRhdGEudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCBpc0Z1bGxQcmVmZXRjaCA9XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShwcmVmZXRjaFJlc3BvbnNlLmZsaWdodERhdGEpICYmXG4gICAgICAgICAgcHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhLnNvbWUoKGZsaWdodERhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIGZyb20gdGhlIHJvb3QgYW5kIHdlIHJldHVybmVkIFJTQyBkYXRhIChzZWVkRGF0YSksIHdlIGFscmVhZHkgaGFkIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgICAgICAgIHJldHVybiBmbGlnaHREYXRhLmlzUm9vdFJlbmRlciAmJiBmbGlnaHREYXRhLnNlZWREYXRhICE9PSBudWxsXG4gICAgICAgICAgfSlcblxuICAgICAgICBpZiAoIWlzRnVsbFByZWZldGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW4gZXhwbGljaXQgcHJlZmV0Y2gga2luZCwgd2Ugd2FudCB0byBzZXQgYSB0ZW1wb3Jhcnkga2luZFxuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYXNzdW1pbmcgdGhlIHNhbWUgaW50ZW50IGFzIHRoZSBwcmV2aW91cyBlbnRyeSwgdG8gYmUgY29uc2lzdGVudCB3aXRoIGhvdyB3ZVxuICAgICAgICAgICAgLy8gbGF6aWx5IGNyZWF0ZSBwcmVmZXRjaCBlbnRyaWVzIHdoZW4gaW50ZW50IGlzIGxlZnQgdW5zcGVjaWZpZWQuXG4gICAgICAgICAgICBraW5kOiBraW5kID8/IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgd2FzIG1hcmtlZCBhcyB0ZW1wb3JhcnksIGl0IG1lYW5zIGl0IHdhcyBsYXppbHkgY3JlYXRlZCB3aGVuIGF0dGVtcHRpbmcgdG8gZ2V0IGFuIGVudHJ5LFxuICAgIC8vIHdoZXJlIHdlIGRpZG4ndCBoYXZlIHRoZSBwcmVmZXRjaCBpbnRlbnQuIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGludGVudCAoaW4gYGtpbmRgKSwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGVudHJ5IHRvIHRoZSBtb3JlIGFjY3VyYXRlIGtpbmQuXG4gICAgaWYgKGtpbmQgJiYgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPT09IFByZWZldGNoS2luZC5URU1QT1JBUlkpIHtcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0ga2luZFxuICAgIH1cblxuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCB0aGUgZXhpc3RpbmcgZW50cnkgd2UgZm91bmQgaXMgc3RpbGwgdmFsaWQsIHNvIHdlIHJldHVybiBpdC5cbiAgICByZXR1cm4gZXhpc3RpbmdDYWNoZUVudHJ5XG4gIH1cblxuICAvLyBJZiB3ZSBkaWRuJ3QgcmV0dXJuIGFuIGVudHJ5LCBjcmVhdGUgYSBuZXcgb25lLlxuICByZXR1cm4gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICAgIHRyZWUsXG4gICAgdXJsLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBraW5kOiBraW5kIHx8IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIH0pXG59XG5cbi8qXG4gKiBVc2VkIHRvIHRha2UgYW4gZXhpc3RpbmcgY2FjaGUgZW50cnkgYW5kIHByZWZpeCBpdCB3aXRoIHRoZSBuZXh0VXJsLCBpZiBpdCBleGlzdHMuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBoYXZlIGNvbmZsaWN0aW5nIGNhY2hlIGVudHJpZXMgZm9yIHRoZSBzYW1lIFVSTCAoYXMgaXMgdGhlIGNhc2Ugd2l0aCByb3V0ZSBpbnRlcmNlcHRpb24pLlxuICovXG5mdW5jdGlvbiBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAgZXhpc3RpbmdDYWNoZUtleSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGV4aXN0aW5nQ2FjaGVLZXk6IHN0cmluZ1xufSkge1xuICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChleGlzdGluZ0NhY2hlS2V5KVxuICBpZiAoIWV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgIC8vIG5vLW9wIC0tIHRoZXJlIHdhc24ndCBhbiBlbnRyeSB0byBtb3ZlXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBuZXdDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gICAgdXJsLFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kLFxuICAgIG5leHRVcmxcbiAgKVxuICBwcmVmZXRjaENhY2hlLnNldChuZXdDYWNoZUtleSwgeyAuLi5leGlzdGluZ0NhY2hlRW50cnksIGtleTogbmV3Q2FjaGVLZXkgfSlcbiAgcHJlZmV0Y2hDYWNoZS5kZWxldGUoZXhpc3RpbmdDYWNoZUtleSlcblxuICByZXR1cm4gbmV3Q2FjaGVLZXlcbn1cblxuLyoqXG4gKiBVc2UgdG8gc2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGUgd2l0aCBkYXRhIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBmZXRjaGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAgdXJsLFxuICBkYXRhLFxuICBraW5kLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3RyZWUnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAgZGF0YTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuICBraW5kOiBQcmVmZXRjaEtpbmRcbn0pIHtcbiAgLy8gVGhlIGluaXRpYWwgY2FjaGUgZW50cnkgdGVjaG5pY2FsbHkgaW5jbHVkZXMgZnVsbCBkYXRhLCBidXQgaXQgaXNuJ3QgZXhwbGljaXRseSBwcmVmZXRjaGVkIC0tIHdlIGp1c3Qgc2VlZCB0aGVcbiAgLy8gcHJlZmV0Y2ggY2FjaGUgc28gdGhhdCB3ZSBjYW4gc2tpcCBhbiBleHRyYSBwcmVmZXRjaCByZXF1ZXN0IGxhdGVyLCBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgdGhlIGRhdGEuXG4gIC8vIGlmIHRoZSBwcmVmZXRjaCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgdXNlIHRoZSBuZXh0VXJsIHRvIHByZWZpeCB0aGUgY2FjaGUga2V5XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBkYXRhLmNvdWxkQmVJbnRlcmNlcHRlZFxuICAgID8gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQsIG5leHRVcmwpXG4gICAgOiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGE6IFByb21pc2UucmVzb2x2ZShkYXRhKSxcbiAgICBraW5kLFxuICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0VXNlZFRpbWU6IERhdGUubm93KCksXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgc3RhdHVzOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2gsXG4gICAgdXJsLFxuICB9IHNhdGlzZmllcyBQcmVmZXRjaENhY2hlRW50cnlcblxuICBwcmVmZXRjaENhY2hlLnNldChwcmVmZXRjaENhY2hlS2V5LCBwcmVmZXRjaEVudHJ5KVxuXG4gIHJldHVybiBwcmVmZXRjaEVudHJ5XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByZWZldGNoIGVudHJ5IGVudHJ5IGFuZCBlbnF1ZXVlcyBhIGZldGNoIHJlcXVlc3QgdG8gcmV0cmlldmUgdGhlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgdXJsLFxuICBraW5kLFxuICB0cmVlLFxuICBuZXh0VXJsLFxuICBwcmVmZXRjaENhY2hlLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3RyZWUnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KTogUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgcHJlZmV0Y2hDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kKVxuXG4gIC8vIGluaXRpYXRlcyB0aGUgZmV0Y2ggcmVxdWVzdCBmb3IgdGhlIHByZWZldGNoIGFuZCBhdHRhY2hlcyBhIGxpc3RlbmVyXG4gIC8vIHRvIHRoZSBwcm9taXNlIHRvIHVwZGF0ZSB0aGUgcHJlZmV0Y2ggY2FjaGUgZW50cnkgd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcyAoaWYgbmVjZXNzYXJ5KVxuICBjb25zdCBkYXRhID0gcHJlZmV0Y2hRdWV1ZS5lbnF1ZXVlKCgpID0+XG4gICAgZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIHtcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlOiB0cmVlLFxuICAgICAgbmV4dFVybCxcbiAgICAgIHByZWZldGNoS2luZDoga2luZCxcbiAgICB9KS50aGVuKChwcmVmZXRjaFJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyBUT0RPOiBgZmV0Y2hTZXJ2ZXJSZXNwb25zZWAgc2hvdWxkIGJlIG1vcmUgdGlnaGx5IGNvdXBsZWQgdG8gdGhlc2UgcHJlZmV0Y2ggY2FjaGUgb3BlcmF0aW9uc1xuICAgICAgLy8gdG8gYXZvaWQgZHJpZnQgYmV0d2VlbiB0aGlzIGNhY2hlIGtleSBwcmVmaXhpbmcgbG9naWNcbiAgICAgIC8vICh3aGljaCBpcyBjdXJyZW50bHkgZGlyZWN0bHkgaW5mbHVlbmNlZCBieSB0aGUgc2VydmVyIHJlc3BvbnNlKVxuICAgICAgbGV0IG5ld0NhY2hlS2V5XG5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLmNvdWxkQmVJbnRlcmNlcHRlZCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBwcmVmaXggdGhlIGNhY2hlIGtleSB3aXRoIHRoZSBuZXh0VXJsXG4gICAgICAgIG5ld0NhY2hlS2V5ID0gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBleGlzdGluZ0NhY2hlS2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHByZWZldGNoIHdhcyBhIGNhY2hlIGhpdCwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHRvIHJlZmxlY3QgdGhhdCBpdCB3YXMgYSBmdWxsIHByZWZldGNoLlxuICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGtub3cgdGhhdCBhIHN0YXRpYyByZXNwb25zZSB3aWxsIGNvbnRhaW4gdGhlIGZ1bGwgUlNDIHBheWxvYWQsIGFuZCBjYW4gYmUgdXBkYXRlZCB0byByZXNwZWN0IHRoZSBgc3RhdGljYFxuICAgICAgLy8gc3RhbGVUaW1lLlxuICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2UucHJlcmVuZGVyZWQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoXG4gICAgICAgICAgLy8gaWYgd2UgcHJlZml4ZWQgdGhlIGNhY2hlIGtleSBkdWUgdG8gcm91dGUgaW50ZXJjZXB0aW9uLCB3ZSB3YW50IHRvIHVzZSB0aGUgbmV3IGtleS4gT3RoZXJ3aXNlIHdlIHVzZSB0aGUgb3JpZ2luYWwga2V5XG4gICAgICAgICAgbmV3Q2FjaGVLZXkgPz8gcHJlZmV0Y2hDYWNoZUtleVxuICAgICAgICApXG4gICAgICAgIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAgICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IFByZWZldGNoS2luZC5GVUxMXG4gICAgICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3RhbGUgdGltZSB0aGF0IHdhcyBjb2xsZWN0ZWQgYnkgdGhlIHNlcnZlciBkdXJpbmdcbiAgICAgICAgICAgIC8vIHN0YXRpYyBnZW5lcmF0aW9uLiBVc2UgdGhpcyBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBzdGFsZSB0aW1lLlxuICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YWxlVGltZSA9IHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVmZXRjaFJlc3BvbnNlXG4gICAgfSlcbiAgKVxuXG4gIGNvbnN0IHByZWZldGNoRW50cnkgPSB7XG4gICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgZGF0YSxcbiAgICBraW5kLFxuICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0VXNlZFRpbWU6IG51bGwsXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgc3RhdHVzOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2gsXG4gICAgdXJsLFxuICB9XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJ1bmVQcmVmZXRjaENhY2hlKFxuICBwcmVmZXRjaENhY2hlOiBSZWFkb25seVJlZHVjZXJTdGF0ZVsncHJlZmV0Y2hDYWNoZSddXG4pIHtcbiAgZm9yIChjb25zdCBbaHJlZiwgcHJlZmV0Y2hDYWNoZUVudHJ5XSBvZiBwcmVmZXRjaENhY2hlKSB7XG4gICAgaWYgKFxuICAgICAgZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHByZWZldGNoQ2FjaGVFbnRyeSkgPT09XG4gICAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZXhwaXJlZFxuICAgICkge1xuICAgICAgcHJlZmV0Y2hDYWNoZS5kZWxldGUoaHJlZilcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlc2UgdmFsdWVzIGFyZSBzZXQgYnkgYGRlZmluZS1lbnYtcGx1Z2luYCAoYmFzZWQgb24gYG5leHRDb25maWcuZXhwZXJpbWVudGFsLnN0YWxlVGltZXNgKVxuLy8gYW5kIGRlZmF1bHQgdG8gNSBtaW51dGVzIChzdGF0aWMpIC8gMCBzZWNvbmRzIChkeW5hbWljKVxuZXhwb3J0IGNvbnN0IERZTkFNSUNfU1RBTEVUSU1FX01TID1cbiAgTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FKSAqIDEwMDBcblxuZXhwb3J0IGNvbnN0IFNUQVRJQ19TVEFMRVRJTUVfTVMgPVxuICBOdW1iZXIocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSkgKiAxMDAwXG5cbmZ1bmN0aW9uIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyh7XG4gIGtpbmQsXG4gIHByZWZldGNoVGltZSxcbiAgbGFzdFVzZWRUaW1lLFxuICBzdGFsZVRpbWUsXG59OiBQcmVmZXRjaENhY2hlRW50cnkpOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMge1xuICBpZiAoc3RhbGVUaW1lICE9PSAtMSkge1xuICAgIC8vIGBzdGFsZVRpbWVgIGlzIHRoZSB2YWx1ZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uLlxuICAgIC8vIFdoZW4gdGhpcyBpcyBhdmFpbGFibGUsIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBhbnkgb2YgdGhlIGhldXJpc3RpY3NcbiAgICAvLyB0aGF0IGZvbGxvdy5cbiAgICAvL1xuICAgIC8vIFRPRE86IFdoZW4gUFBSIGlzIGVuYWJsZWQsIHRoZSBzZXJ2ZXIgd2lsbCAqYWx3YXlzKiByZXR1cm4gYSBzdGFsZSB0aW1lXG4gICAgLy8gd2hlbiBwcmVmZXRjaGluZy4gV2Ugc2hvdWxkIG5ldmVyIHVzZSBhIHByZWZldGNoIGVudHJ5IHRoYXQgaGFzbid0IHlldFxuICAgIC8vIHJlY2VpdmVkIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBTbyB0aGUgb25seSB0d28gY2FzZXMgc2hvdWxkIGJlIDEpIHdlIHVzZVxuICAgIC8vIHRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHN0YWxlIHRpbWUgMikgdGhlIHVucmVzb2x2ZWQgZW50cnkgaXMgZGlzY2FyZGVkLlxuICAgIHJldHVybiBEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgc3RhbGVUaW1lXG4gICAgICA/IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaFxuICAgICAgOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuc3RhbGVcbiAgfVxuXG4gIC8vIFdlIHdpbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byB0aGUgYGR5bmFtaWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChEYXRlLm5vdygpIDwgKGxhc3RVc2VkVGltZSA/PyBwcmVmZXRjaFRpbWUpICsgRFlOQU1JQ19TVEFMRVRJTUVfTVMpIHtcbiAgICByZXR1cm4gbGFzdFVzZWRUaW1lXG4gICAgICA/IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgICAgOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgfVxuXG4gIC8vIEZvciBcImF1dG9cIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIG9ubHkgdGhlIGxvYWRpbmcgYm91bmRhcnkgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIC8vIEEgc3RhbGUgZW50cnkgd2lsbCBvbmx5IHJlLXVzZSB0aGUgYGxvYWRpbmdgIGJvdW5kYXJ5LCBub3QgdGhlIGZ1bGwgZGF0YS5cbiAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBcImxhenkgZmV0Y2hcIiBmb3IgdGhlIGZ1bGwgZGF0YS5cbiAgaWYgKGtpbmQgPT09IFByZWZldGNoS2luZC5BVVRPKSB7XG4gICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlXG4gICAgfVxuICB9XG5cbiAgLy8gZm9yIFwiZnVsbFwiIHByZWZldGNoaW5nLCB3ZSdsbCByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGRhdGEgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCkge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZXhwaXJlZFxufVxuIl0sIm5hbWVzIjpbIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiU1RBVElDX1NUQUxFVElNRV9NUyIsImNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwicHJ1bmVQcmVmZXRjaENhY2hlIiwiSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIiLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbCIsInVybCIsImluY2x1ZGVTZWFyY2hQYXJhbXMiLCJwcmVmaXgiLCJwYXRobmFtZUZyb21VcmwiLCJwYXRobmFtZSIsInNlYXJjaCIsImNyZWF0ZVByZWZldGNoQ2FjaGVLZXkiLCJraW5kIiwibmV4dFVybCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJnZXRFeGlzdGluZ0NhY2hlRW50cnkiLCJwcmVmZXRjaENhY2hlIiwiYWxsb3dBbGlhc2luZyIsIlRFTVBPUkFSWSIsIm1heWJlTmV4dFVybCIsImNhY2hlS2V5V2l0aFBhcmFtcyIsImNhY2hlS2V5V2l0aG91dFBhcmFtcyIsImNhY2hlS2V5VG9Vc2UiLCJleGlzdGluZ0VudHJ5IiwiZ2V0IiwiaXNBbGlhc2VkIiwiYWxpYXNlZCIsImVudHJ5V2l0aG91dFBhcmFtcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImtleSIsImluY2x1ZGVzIiwiY2FjaGVFbnRyeSIsInZhbHVlcyIsInVuZGVmaW5lZCIsInRyZWUiLCJleGlzdGluZ0NhY2hlRW50cnkiLCJzdGF0dXMiLCJnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMiLCJzd2l0Y2hlZFRvRnVsbFByZWZldGNoIiwiZGF0YSIsInRoZW4iLCJwcmVmZXRjaFJlc3BvbnNlIiwiaXNGdWxsUHJlZmV0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJmbGlnaHREYXRhIiwic29tZSIsImlzUm9vdFJlbmRlciIsInNlZWREYXRhIiwiY3JlYXRlTGF6eVByZWZldGNoRW50cnkiLCJwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSIsImV4aXN0aW5nQ2FjaGVLZXkiLCJuZXdDYWNoZUtleSIsInNldCIsImRlbGV0ZSIsInByZWZldGNoQ2FjaGVLZXkiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVmZXRjaEVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInByZWZldGNoVGltZSIsIkRhdGUiLCJub3ciLCJsYXN0VXNlZFRpbWUiLCJzdGFsZVRpbWUiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJmcmVzaCIsInByZWZldGNoUXVldWUiLCJlbnF1ZXVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImZsaWdodFJvdXRlclN0YXRlIiwicHJlZmV0Y2hLaW5kIiwicHJlcmVuZGVyZWQiLCJocmVmIiwicHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhwaXJlZCIsIk51bWJlciIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSIsInN0YWxlIiwicmV1c2FibGUiLCJBVVRPIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findHeadInCache\", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, '');\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    // First try the 'children' parallel route if it exists\n    // when starting from the \"root\", this corresponds with the main page component\n    if (parallelRoutes.children) {\n        const [segment, childParallelRoutes] = parallelRoutes.children;\n        const childSegmentMap = cache.parallelRoutes.get('children');\n        if (childSegmentMap) {\n            const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n            const cacheNode = childSegmentMap.get(cacheKey);\n            if (cacheNode) {\n                const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n                if (item) return item;\n            }\n        }\n    }\n    // if we didn't find metadata in the page slot, check the other parallel routes\n    for(const key in parallelRoutes){\n        if (key === 'children') continue; // already checked above\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUlnQkE7OztlQUFBQTs7O2tEQUZxQjtBQUU5QixTQUFTQSxnQkFDZEMsS0FBZ0IsRUFDaEJDLGNBQW9DO0lBRXBDLE9BQU9DLG9CQUFvQkYsT0FBT0MsZ0JBQWdCO0FBQ3BEO0FBRUEsU0FBU0Msb0JBQ1BGLEtBQWdCLEVBQ2hCQyxjQUFvQyxFQUNwQ0UsU0FBaUI7SUFFakIsTUFBTUMsYUFBYUMsT0FBT0MsSUFBSSxDQUFDTCxnQkFBZ0JNLE1BQU0sS0FBSztJQUMxRCxJQUFJSCxZQUFZO1FBQ2QsMEVBQTBFO1FBQzFFLE9BQU87WUFBQ0o7WUFBT0c7U0FBVTtJQUMzQjtJQUVBLHVEQUF1RDtJQUN2RCwrRUFBK0U7SUFDL0UsSUFBSUYsZUFBZU8sUUFBUSxFQUFFO1FBQzNCLE1BQU0sQ0FBQ0MsU0FBU0Msb0JBQW9CLEdBQUdULGVBQWVPLFFBQVE7UUFDOUQsTUFBTUcsa0JBQWtCWCxNQUFNQyxjQUFjLENBQUNXLEdBQUcsQ0FBQztRQUNqRCxJQUFJRCxpQkFBaUI7WUFDbkIsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFBQSxFQUFxQkw7WUFDdEMsTUFBTU0sWUFBWUosZ0JBQWdCQyxHQUFHLENBQUNDO1lBQ3RDLElBQUlFLFdBQVc7Z0JBQ2IsTUFBTUMsT0FBT2Qsb0JBQ1hhLFdBQ0FMLHFCQUNBUCxZQUFZLE1BQU1VO2dCQUVwQixJQUFJRyxNQUFNLE9BQU9BO1lBQ25CO1FBQ0Y7SUFDRjtJQUVBLCtFQUErRTtJQUMvRSxJQUFLLE1BQU1DLE9BQU9oQixlQUFnQjtRQUNoQyxJQUFJZ0IsUUFBUSxZQUFZLFVBQVMsd0JBQXdCO1FBRXpELE1BQU0sQ0FBQ1IsU0FBU0Msb0JBQW9CLEdBQUdULGNBQWMsQ0FBQ2dCLElBQUk7UUFDMUQsTUFBTU4sa0JBQWtCWCxNQUFNQyxjQUFjLENBQUNXLEdBQUcsQ0FBQ0s7UUFDakQsSUFBSSxDQUFDTixpQkFBaUI7WUFDcEI7UUFDRjtRQUVBLE1BQU1FLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBQUEsRUFBcUJMO1FBRXRDLE1BQU1NLFlBQVlKLGdCQUFnQkMsR0FBRyxDQUFDQztRQUN0QyxJQUFJLENBQUNFLFdBQVc7WUFDZDtRQUNGO1FBRUEsTUFBTUMsT0FBT2Qsb0JBQ1hhLFdBQ0FMLHFCQUNBUCxZQUFZLE1BQU1VO1FBRXBCLElBQUlHLE1BQU07WUFDUixPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxmaW5kLWhlYWQtaW4tY2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSGVhZEluQ2FjaGUoXG4gIGNhY2hlOiBDYWNoZU5vZGUsXG4gIHBhcmFsbGVsUm91dGVzOiBGbGlnaHRSb3V0ZXJTdGF0ZVsxXVxuKTogW0NhY2hlTm9kZSwgc3RyaW5nXSB8IG51bGwge1xuICByZXR1cm4gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsICcnKVxufVxuXG5mdW5jdGlvbiBmaW5kSGVhZEluQ2FjaGVJbXBsKFxuICBjYWNoZTogQ2FjaGVOb2RlLFxuICBwYXJhbGxlbFJvdXRlczogRmxpZ2h0Um91dGVyU3RhdGVbMV0sXG4gIGtleVByZWZpeDogc3RyaW5nXG4pOiBbQ2FjaGVOb2RlLCBzdHJpbmddIHwgbnVsbCB7XG4gIGNvbnN0IGlzTGFzdEl0ZW0gPSBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwXG4gIGlmIChpc0xhc3RJdGVtKSB7XG4gICAgLy8gUmV0dXJucyB0aGUgZW50aXJlIENhY2hlIE5vZGUgb2YgdGhlIHNlZ21lbnQgd2hvc2UgaGVhZCB3ZSB3aWxsIHJlbmRlci5cbiAgICByZXR1cm4gW2NhY2hlLCBrZXlQcmVmaXhdXG4gIH1cblxuICAvLyBGaXJzdCB0cnkgdGhlICdjaGlsZHJlbicgcGFyYWxsZWwgcm91dGUgaWYgaXQgZXhpc3RzXG4gIC8vIHdoZW4gc3RhcnRpbmcgZnJvbSB0aGUgXCJyb290XCIsIHRoaXMgY29ycmVzcG9uZHMgd2l0aCB0aGUgbWFpbiBwYWdlIGNvbXBvbmVudFxuICBpZiAocGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBbc2VnbWVudCwgY2hpbGRQYXJhbGxlbFJvdXRlc10gPSBwYXJhbGxlbFJvdXRlcy5jaGlsZHJlblxuICAgIGNvbnN0IGNoaWxkU2VnbWVudE1hcCA9IGNhY2hlLnBhcmFsbGVsUm91dGVzLmdldCgnY2hpbGRyZW4nKVxuICAgIGlmIChjaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcbiAgICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpXG4gICAgICBpZiAoY2FjaGVOb2RlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBmaW5kSGVhZEluQ2FjaGVJbXBsKFxuICAgICAgICAgIGNhY2hlTm9kZSxcbiAgICAgICAgICBjaGlsZFBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgIGtleVByZWZpeCArICcvJyArIGNhY2hlS2V5XG4gICAgICAgIClcbiAgICAgICAgaWYgKGl0ZW0pIHJldHVybiBpdGVtXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgd2UgZGlkbid0IGZpbmQgbWV0YWRhdGEgaW4gdGhlIHBhZ2Ugc2xvdCwgY2hlY2sgdGhlIG90aGVyIHBhcmFsbGVsIHJvdXRlc1xuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIGNvbnRpbnVlIC8vIGFscmVhZHkgY2hlY2tlZCBhYm92ZVxuXG4gICAgY29uc3QgW3NlZ21lbnQsIGNoaWxkUGFyYWxsZWxSb3V0ZXNdID0gcGFyYWxsZWxSb3V0ZXNba2V5XVxuICAgIGNvbnN0IGNoaWxkU2VnbWVudE1hcCA9IGNhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpXG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50KVxuXG4gICAgY29uc3QgY2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcbiAgICBpZiAoIWNhY2hlTm9kZSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtID0gZmluZEhlYWRJbkNhY2hlSW1wbChcbiAgICAgIGNhY2hlTm9kZSxcbiAgICAgIGNoaWxkUGFyYWxsZWxSb3V0ZXMsXG4gICAgICBrZXlQcmVmaXggKyAnLycgKyBjYWNoZUtleVxuICAgIClcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbImZpbmRIZWFkSW5DYWNoZSIsImNhY2hlIiwicGFyYWxsZWxSb3V0ZXMiLCJmaW5kSGVhZEluQ2FjaGVJbXBsIiwia2V5UHJlZml4IiwiaXNMYXN0SXRlbSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJjaGlsZHJlbiIsInNlZ21lbnQiLCJjaGlsZFBhcmFsbGVsUm91dGVzIiwiY2hpbGRTZWdtZW50TWFwIiwiZ2V0IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImNhY2hlTm9kZSIsIml0ZW0iLCJrZXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js ***!
  \***********************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSegmentValue\", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2dldC1zZWdtZW50LXZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBRWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxnQkFBZ0JDLE9BQWdCO0lBQzlDLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBV0EsT0FBTyxDQUFDLEVBQUUsR0FBR0E7QUFDL0MiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxnZXQtc2VnbWVudC12YWx1ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlZ21lbnRWYWx1ZShzZWdtZW50OiBTZWdtZW50KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnRcbn1cbiJdLCJuYW1lcyI6WyJnZXRTZWdtZW50VmFsdWUiLCJzZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js ***!
  \********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../shared/lib/router/utils/interception-routes */ \"(ssr)/./node_modules/next/dist/shared/lib/router/utils/interception-routes.js\");\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7cUVBR2dCQTs7O2VBQUFBOzs7Z0RBRjJCO0FBRXBDLFNBQVNBLGtDQUFrQyxLQUc5QjtJQUg4QixLQUNoREMsU0FDQUMsZUFDa0IsR0FIOEI7SUFJaEQsd0dBQXdHO0lBQ3hHLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsWUFBYUEsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRQSxPQUFPLENBQUMsRUFBRSxLQUFLLEtBQUcsRUFBSTtRQUMxRSxPQUFPO0lBQ1Q7SUFFQSxvRUFBb0U7SUFDcEUsSUFBSSxPQUFPQSxZQUFZLFlBQVlJLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBQUEsRUFBMkJKLFVBQVU7UUFDdEUsT0FBTztJQUNUO0lBRUEsK0NBQStDO0lBQy9DLElBQUlDLGdCQUFnQjtRQUNsQixJQUFLLE1BQU1JLE9BQU9KLGVBQWdCO1lBQ2hDLElBQUlGLGtDQUFrQ0UsY0FBYyxDQUFDSSxJQUFJLEdBQUc7Z0JBQzFELE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxoYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVyY2VwdGlvbi1yb3V0ZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoW1xuICBzZWdtZW50LFxuICBwYXJhbGxlbFJvdXRlcyxcbl06IEZsaWdodFJvdXRlclN0YXRlKTogYm9vbGVhbiB7XG4gIC8vIElmIHdlIGhhdmUgYSBkeW5hbWljIHNlZ21lbnQsIGl0J3MgbWFya2VkIGFzIGFuIGludGVyY2VwdGlvbiByb3V0ZSBieSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGBpYCBzdWZmaXguXG4gIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpICYmIChzZWdtZW50WzJdID09PSAnZGknIHx8IHNlZ21lbnRbMl0gPT09ICdjaScpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIElmIHNlZ21lbnQgaXMgbm90IGFuIGFycmF5LCBhcHBseSB0aGUgZXhpc3Rpbmcgc3RyaW5nLWJhc2VkIGNoZWNrXG4gIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycgJiYgaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgoc2VnbWVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIHBhcmFsbGVsUm91dGVzIGlmIHRoZXkgZXhpc3RcbiAgaWYgKHBhcmFsbGVsUm91dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUocGFyYWxsZWxSb3V0ZXNba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiJdLCJuYW1lcyI6WyJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImtleSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(ssr)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    const navigatedAt = Date.now();\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2htci1yZWZyZXNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztxREErSGFBOzs7ZUFBQUE7OztpREEvSHVCOytDQUNGO3lEQUNVO3lEQUNBOzZDQU9WOzJDQUNKOzZDQUNFO3VDQUVLO21EQUNDOytEQUNZO0FBRWxELHdGQUF3RjtBQUN4RixTQUFTQyxzQkFDUEMsS0FBMkIsRUFDM0JDLE1BQXdCO0lBRXhCLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdEO0lBQ25CLE1BQU1FLFVBQW1CLENBQUM7SUFDMUIsTUFBTUMsT0FBT0osTUFBTUssWUFBWTtJQUUvQkYsUUFBUUcsMEJBQTBCLEdBQUc7SUFFckMsTUFBTUMsUUFBbUJDLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFBQTtJQUN6QixzRkFBc0Y7SUFDdEYsc0hBQXNIO0lBQ3RILE1BQU1DLGlCQUFpQkMsQ0FBQUEsR0FBQUEsbUNBQUFBLGlDQUFBQSxFQUFrQ1YsTUFBTVcsSUFBSTtJQUVuRSx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDLE1BQU1DLGNBQWNDLEtBQUtDLEdBQUc7SUFDNUJQLE1BQU1RLFFBQVEsR0FBR0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQixJQUFJQyxJQUFJYixNQUFNRixTQUFTO1FBQzFEZ0IsbUJBQW1CO1lBQUNsQixNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFO1NBQVU7UUFDM0VRLFNBQVNWLGlCQUFpQlQsTUFBTW1CLE9BQU8sR0FBRztRQUMxQ0MsY0FBYztJQUNoQjtJQUVBLE9BQU9iLE1BQU1RLFFBQVEsQ0FBQ00sSUFBSSxDQUN4QjtZQUFDLEVBQUVDLFVBQVUsRUFBRWpCLGNBQWNrQixvQkFBb0IsRUFBRTtRQUNqRCw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPRCxlQUFlLFVBQVU7WUFDbEMsT0FBT0UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMeEIsT0FDQUcsU0FDQW1CLFlBQ0F0QixNQUFNeUIsT0FBTyxDQUFDQyxXQUFXO1FBRTdCO1FBRUEsK0RBQStEO1FBQy9EbkIsTUFBTVEsUUFBUSxHQUFHO1FBRWpCLElBQUlZLGNBQWMzQixNQUFNVyxJQUFJO1FBQzVCLElBQUlpQixlQUFlNUIsTUFBTU8sS0FBSztRQUU5QixLQUFLLE1BQU1zQix3QkFBd0JQLFdBQVk7WUFDN0MsTUFBTSxFQUFFWCxNQUFNbUIsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR0Y7WUFDMUMsSUFBSSxDQUFDRSxjQUFjO2dCQUNqQixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBT2pDO1lBQ1Q7WUFFQSxNQUFNa0MsVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUNkO2dCQUNDO2FBQUcsRUFDSlIsYUFDQUcsV0FDQTlCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSTZCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFBQSxFQUFzQnBDLE9BQU9DLFFBQVE2QjtZQUM5QztZQUVBLElBQUlPLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFBNEJWLGFBQWFPLFVBQVU7Z0JBQ3JELE9BQU9WLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFDdEJ4QixPQUNBRyxTQUNBQyxNQUNBSixNQUFNeUIsT0FBTyxDQUFDQyxXQUFXO1lBRTdCO1lBRUEsTUFBTVksMkJBQTJCZix1QkFDN0JnQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCaEIsd0JBQ2xCaUI7WUFFSixJQUFJakIsc0JBQXNCO2dCQUN4QnBCLFFBQVFFLFlBQVksR0FBR2lDO1lBQ3pCO1lBQ0EsTUFBTUcsVUFBVUMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQ2Q5QixhQUNBZ0IsY0FDQXJCLE9BQ0FzQjtZQUdGLElBQUlZLFNBQVM7Z0JBQ1h0QyxRQUFRSSxLQUFLLEdBQUdBO2dCQUNoQnFCLGVBQWVyQjtZQUNqQjtZQUVBSixRQUFRd0MsV0FBVyxHQUFHVDtZQUN0Qi9CLFFBQVFFLFlBQVksR0FBR0Q7WUFFdkJ1QixjQUFjTztRQUNoQjtRQUNBLE9BQU9VLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWM1QyxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVY7QUFFQSxTQUFTNkMsc0JBQ1A3QyxLQUEyQixFQUMzQjhDLE9BQXlCO0lBRXpCLE9BQU85QztBQUNUO0FBRU8sTUFBTUYsb0JBL0dxQyxNQWdINUIsR0FDaEIrQyxDQUFxQkEsR0FDckI5QyIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXGhtci1yZWZyZXNoLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4uL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUge1xuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgUmVkdWNlclN0YXRlLFxuICBIbXJSZWZyZXNoQWN0aW9uLFxuICBNdXRhYmxlLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGhhbmRsZUV4dGVybmFsVXJsIH0gZnJvbSAnLi9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHsgYXBwbHlGbGlnaHREYXRhIH0gZnJvbSAnLi4vYXBwbHktZmxpZ2h0LWRhdGEnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgaGFuZGxlU2VnbWVudE1pc21hdGNoIH0gZnJvbSAnLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2gnXG5pbXBvcnQgeyBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUgfSBmcm9tICcuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlJ1xuXG4vLyBBIHZlcnNpb24gb2YgcmVmcmVzaCByZWR1Y2VyIHRoYXQga2VlcHMgdGhlIGNhY2hlIGFyb3VuZCBpbnN0ZWFkIG9mIHdpcGluZyBhbGwgb2YgaXQuXG5mdW5jdGlvbiBobXJSZWZyZXNoUmVkdWNlckltcGwoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBIbXJSZWZyZXNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IG9yaWdpbiB9ID0gYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgLy8gSWYgdGhlIGN1cnJlbnQgdHJlZSB3YXMgaW50ZXJjZXB0ZWQsIHRoZSBuZXh0VXJsIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC5cbiAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICBjb25zdCBpbmNsdWRlTmV4dFVybCA9IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShzdGF0ZS50cmVlKVxuXG4gIC8vIFRPRE8tQVBQOiB2ZXJpZnkgdGhhdCBgaHJlZmAgaXMgbm90IGFuIGV4dGVybmFsIHVybC5cbiAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICBjb25zdCBuYXZpZ2F0ZWRBdCA9IERhdGUubm93KClcbiAgY2FjaGUubGF6eURhdGEgPSBmZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwge1xuICAgIGZsaWdodFJvdXRlclN0YXRlOiBbc3RhdGUudHJlZVswXSwgc3RhdGUudHJlZVsxXSwgc3RhdGUudHJlZVsyXSwgJ3JlZmV0Y2gnXSxcbiAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsLFxuICAgIGlzSG1yUmVmcmVzaDogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gY2FjaGUubGF6eURhdGEudGhlbihcbiAgICAoeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlIH0pID0+IHtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgY2FjaGUubGF6eURhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbFxuXG4gICAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG4gICAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGVcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdHJlZTogdHJlZVBhdGNoLCBpc1Jvb3RSZW5kZXIgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JFRlJFU0ggRkFJTEVEJylcbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgIFsnJ10sXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlU2VnbWVudE1pc21hdGNoKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICAgID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpXG4gICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGxpZWQgPSBhcHBseUZsaWdodERhdGEoXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIClcblxuICAgICAgICBpZiAoYXBwbGllZCkge1xuICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlXG4gICAgICAgIH1cblxuICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZVxuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWZcblxuICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH0sXG4gICAgKCkgPT4gc3RhdGVcbiAgKVxufVxuXG5mdW5jdGlvbiBobXJSZWZyZXNoUmVkdWNlck5vb3AoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgX2FjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCBobXJSZWZyZXNoUmVkdWNlciA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcbiAgICA/IGhtclJlZnJlc2hSZWR1Y2VyTm9vcFxuICAgIDogaG1yUmVmcmVzaFJlZHVjZXJJbXBsXG4iXSwibmFtZXMiOlsiaG1yUmVmcmVzaFJlZHVjZXIiLCJobXJSZWZyZXNoUmVkdWNlckltcGwiLCJzdGF0ZSIsImFjdGlvbiIsIm9yaWdpbiIsIm11dGFibGUiLCJocmVmIiwiY2Fub25pY2FsVXJsIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiaW5jbHVkZU5leHRVcmwiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJ0cmVlIiwibmF2aWdhdGVkQXQiLCJEYXRlIiwibm93IiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwiaXNIbXJSZWZyZXNoIiwidGhlbiIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImhhbmRsZUV4dGVybmFsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwiY3VycmVudFRyZWUiLCJjdXJyZW50Q2FjaGUiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWVQYXRjaCIsImlzUm9vdFJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJhcHBsaWVkIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiaG1yUmVmcmVzaFJlZHVjZXJOb29wIiwiX2FjdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(ssr)/./node_modules/next/dist/client/components/app-router.js\");\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js\");\nconst _aliasedprefetchnavigations = __webpack_require__(/*! ../aliased-prefetch-navigations */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(ssr)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _segmentcache.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _segmentcache.NavigationResultTag.NoOp:\n            {\n                // The server responded with no change to the current page. However, if\n                // the URL changed, we still need to update that.\n                const newCanonicalUrl = result.data.canonicalUrl;\n                mutable.canonicalUrl = newCanonicalUrl;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                mutable.scrollableSegments = result.data.scrollableSegments;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    if (false) {}\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        prefetchCache: state.prefetchCache,\n        allowAliasing\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;\n        const navigatedAt = Date.now();\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = navigatedAt;\n            isFirstRead = true;\n        }\n        if (prefetchValues.aliased) {\n            const result = (0, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(navigatedAt, state, flightData, url, mutable);\n            // We didn't return new router state because we didn't apply the aliased entry for some reason.\n            // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n            // will create an on-demand prefetch entry.\n            if (result === false) {\n                return navigateReducer(state, {\n                    ...action,\n                    allowAliasing: false\n                });\n            }\n            return result;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        const updatedCanonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        const onlyHashChange = !!hash && state.canonicalUrl.split('#', 1)[0] === updatedCanonicalUrl.split('#', 1)[0];\n        // If only the hash has changed, the server hasn't sent us any new data. We can just update\n        // the mutable properties responsible for URL and scroll handling and return early.\n        if (onlyHashChange) {\n            mutable.onlyHashChange = true;\n            mutable.canonicalUrl = updatedCanonicalUrl;\n            mutable.shouldScroll = shouldScroll;\n            mutable.hashFragment = hash;\n            mutable.scrollableSegments = [];\n            return (0, _handlemutable.handleMutable)(state, mutable);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const normalizedFlightData of flightData){\n            const { pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;\n            let treePatch = normalizedFlightData.tree;\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                '',\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if (// will send back a static response that's rendered from\n                // the root. If for some reason it doesn't, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via startPPRNavigation. The current structure is just\n                // an incremental step.\n                seedData && isRootRender && postponed) {\n                    const task = (0, _pprnavigations.startPPRNavigation)(navigatedAt, currentCache, currentTree, treePatch, seedData, head, isHeadPartial, false, scrollableSegments);\n                    if (task !== null) {\n                        if (task.route === null) {\n                            // Detected a change to the root layout. Perform an full-\n                            // page navigation.\n                            return handleExternalUrl(state, mutable, href, pendingPush);\n                        }\n                        // Use the tree computed by startPPRNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        if (newCache !== null) {\n                            // We've created a new Cache Node tree that contains a prefetched\n                            // version of the next page. This can be rendered instantly.\n                            mutable.cache = newCache;\n                        }\n                        const dynamicRequestTree = task.dynamicRequestTree;\n                        if (dynamicRequestTree !== null) {\n                            // The prefetched tree has dynamic holes in it. We initiate a\n                            // dynamic request to fill them in.\n                            //\n                            // Do not block on the result. We'll immediately render the Cache\n                            // Node tree and suspend on the dynamic parts. When the request\n                            // comes in, we'll fill in missing data and ping React to\n                            // re-render. Unlike the lazy fetching model in the non-PPR\n                            // implementation, this is modeled as a single React update +\n                            // streaming, rather than multiple top-level updates. (However,\n                            // even in the new model, we'll still need to sometimes update the\n                            // root multiple times per navigation, like if the server sends us\n                            // a different response than we expected. For now, we revert back\n                            // to the lazy fetching mechanism in that case.)\n                            const dynamicRequest = (0, _fetchserverresponse.fetchServerResponse)(url, {\n                                flightRouterState: dynamicRequestTree,\n                                nextUrl: state.nextUrl\n                            });\n                            (0, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);\n                        // We store the dynamic request on the `lazyData` property of the CacheNode\n                        // because we're not going to await the dynamic request here. Since we're not blocking\n                        // on the dynamic request, `layout-router` will\n                        // task.node.lazyData = dynamicRequest\n                        } else {\n                        // The prefetched tree does not contain dynamic holes â€” it's\n                        // fully static. We can skip the dynamic request.\n                        }\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = treePatch;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there's no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                        return handleExternalUrl(state, mutable, href, pendingPush);\n                    }\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                        // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache's loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = navigatedAt;\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the \"current cache\" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                    for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                        const scrollableSegmentPath = [\n                            ...flightSegmentPath,\n                            ...subSegment\n                        ];\n                        // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                        if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                            scrollableSegments.push(scrollableSegmentPath);\n                        }\n                    }\n                }\n                currentTree = newTree;\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = updatedCanonicalUrl;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBb0NnQkEsaUJBQWlCO2VBQWpCQTs7SUFzSUFDLGVBQWU7ZUFBZkE7OztpREFyS29COytDQUNGO21FQUNvQjt5REFDVjtnREFDVDt5REFDUztnREFPckM7MkNBQ3VCOzZDQUNFOzZDQUNGO3VDQUNPO3FDQUNEOzRDQUN3QjtnREFJckQ7OERBQzBDO3dEQUNOOzBDQUtwQztBQUVBLFNBQVNELGtCQUNkRSxLQUEyQixFQUMzQkMsT0FBZ0IsRUFDaEJDLEdBQVcsRUFDWEMsV0FBb0I7SUFFcEJGLFFBQVFHLGFBQWEsR0FBRztJQUN4QkgsUUFBUUksWUFBWSxHQUFHSDtJQUN2QkQsUUFBUUUsV0FBVyxHQUFHQTtJQUN0QkYsUUFBUUssa0JBQWtCLEdBQUdDO0lBRTdCLE9BQU9DLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWNSLE9BQU9DO0FBQzlCO0FBRUEsU0FBU1EsMEJBQ1BDLGlCQUFvQztJQUVwQyxNQUFNQyxXQUFnQyxFQUFFO0lBQ3hDLE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHSDtJQUVsQyxJQUFJSSxPQUFPQyxJQUFJLENBQUNGLGdCQUFnQkcsTUFBTSxLQUFLLEdBQUc7UUFDNUMsT0FBTztZQUFDO2dCQUFDSjthQUFRO1NBQUM7SUFDcEI7SUFFQSxLQUFLLE1BQU0sQ0FBQ0ssa0JBQWtCQyxjQUFjLElBQUlKLE9BQU9LLE9BQU8sQ0FDNUROLGdCQUNDO1FBQ0QsS0FBSyxNQUFNTyxnQkFBZ0JYLDBCQUEwQlMsZUFBZ0I7WUFDbkUsbUVBQW1FO1lBQ25FLElBQUlOLFlBQVksSUFBSTtnQkFDbEJELFNBQVNVLElBQUksQ0FBQztvQkFBQ0o7dUJBQXFCRztpQkFBYTtZQUNuRCxPQUFPO2dCQUNMVCxTQUFTVSxJQUFJLENBQUM7b0JBQUNU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QUFBLEdBQUFBLHVDQUFBQSxxQ0FBQUEsRUFDRXRFLE9BQ0E5QixjQUNBQzt3QkFFRiw4RUFBOEU7d0JBQzlFeEIsUUFBUXFELEtBQUssR0FBR0E7b0JBQ2xCLE9BQU8sSUFBSStELFNBQVM7d0JBQ2xCcEgsUUFBUXFELEtBQUssR0FBR0E7d0JBQ2hCLDRFQUE0RTt3QkFDNUUsOEVBQThFO3dCQUM5RTlCLGVBQWU4QjtvQkFDakI7b0JBRUEsS0FBSyxNQUFNdUUsY0FBY3BILDBCQUEwQmlCLFdBQVk7d0JBQzdELE1BQU1vRyx3QkFBd0I7K0JBQ3pCckc7K0JBQ0FvRzt5QkFDSjt3QkFDRCxrRkFBa0Y7d0JBQ2xGLElBQ0VDLHFCQUFxQixDQUFDQSxzQkFBc0I5RyxNQUFNLEdBQUcsRUFBRSxLQUN2RCtHLFNBQUFBLG1CQUFtQixFQUNuQjs0QkFDQXpILG1CQUFtQmUsSUFBSSxDQUFDeUc7d0JBQzFCO29CQUNGO2dCQUNGO2dCQUVBOUIsY0FBY1E7WUFDaEI7UUFDRjtRQUVBdkcsUUFBUXVELFdBQVcsR0FBR3dDO1FBQ3RCL0YsUUFBUUksWUFBWSxHQUFHeUY7UUFDdkI3RixRQUFRSyxrQkFBa0IsR0FBR0E7UUFDN0JMLFFBQVFtRCxZQUFZLEdBQUdGO1FBQ3ZCakQsUUFBUWtELFlBQVksR0FBR0E7UUFFdkIsT0FBTzNDLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWNSLE9BQU9DO0lBQzlCLEdBQ0EsSUFBTUQ7QUFFViIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXG5hdmlnYXRlLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEZsaWdodFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCB9IGZyb20gJy4uL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBzaG91bGRIYXJkTmF2aWdhdGUgfSBmcm9tICcuLi9zaG91bGQtaGFyZC1uYXZpZ2F0ZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHtcbiAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLFxuICB0eXBlIE11dGFibGUsXG4gIHR5cGUgTmF2aWdhdGVBY3Rpb24sXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIHR5cGUgUmVkdWNlclN0YXRlLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHsgcHJlZmV0Y2hRdWV1ZSB9IGZyb20gJy4vcHJlZmV0Y2gtcmVkdWNlcidcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCwgc3RhcnRQUFJOYXZpZ2F0aW9uIH0gZnJvbSAnLi4vcHByLW5hdmlnYXRpb25zJ1xuaW1wb3J0IHtcbiAgZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnksXG4gIHBydW5lUHJlZmV0Y2hDYWNoZSxcbn0gZnJvbSAnLi4vcHJlZmV0Y2gtY2FjaGUtdXRpbHMnXG5pbXBvcnQgeyBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aCB9IGZyb20gJy4uL2NsZWFyLWNhY2hlLW5vZGUtZGF0YS1mb3Itc2VnbWVudC1wYXRoJ1xuaW1wb3J0IHsgaGFuZGxlQWxpYXNlZFByZWZldGNoRW50cnkgfSBmcm9tICcuLi9hbGlhc2VkLXByZWZldGNoLW5hdmlnYXRpb25zJ1xuaW1wb3J0IHtcbiAgbmF2aWdhdGUgYXMgbmF2aWdhdGVVc2luZ1NlZ21lbnRDYWNoZSxcbiAgTmF2aWdhdGlvblJlc3VsdFRhZyxcbiAgdHlwZSBOYXZpZ2F0aW9uUmVzdWx0LFxufSBmcm9tICcuLi8uLi9zZWdtZW50LWNhY2hlJ1xuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgbXV0YWJsZTogTXV0YWJsZSxcbiAgdXJsOiBzdHJpbmcsXG4gIHBlbmRpbmdQdXNoOiBib29sZWFuXG4pIHtcbiAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gdHJ1ZVxuICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IHVybFxuICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gcGVuZGluZ1B1c2hcbiAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSB1bmRlZmluZWRcblxuICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaChcbiAgZmxpZ2h0Um91dGVyUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBGbGlnaHRTZWdtZW50UGF0aFtdIHtcbiAgY29uc3Qgc2VnbWVudHM6IEZsaWdodFNlZ21lbnRQYXRoW10gPSBbXVxuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyUGF0Y2hcblxuICBpZiAoT2JqZWN0LmtleXMocGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbW3NlZ21lbnRdXVxuICB9XG5cbiAgZm9yIChjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgcGFyYWxsZWxSb3V0ZV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgcGFyYWxsZWxSb3V0ZXNcbiAgKSkge1xuICAgIGZvciAoY29uc3QgY2hpbGRTZWdtZW50IG9mIGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2gocGFyYWxsZWxSb3V0ZSkpIHtcbiAgICAgIC8vIElmIHRoZSBzZWdtZW50IGlzIGVtcHR5LCBpdCBtZWFucyB3ZSBhcmUgYXQgdGhlIHJvb3Qgb2YgdGhlIHRyZWVcbiAgICAgIGlmIChzZWdtZW50ID09PSAnJykge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFtwYXJhbGxlbFJvdXRlS2V5LCAuLi5jaGlsZFNlZ21lbnRdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleSwgLi4uY2hpbGRTZWdtZW50XSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckxhenlGZXRjaEZvckxlYWZTZWdtZW50cyhcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgY3VycmVudENhY2hlOiBDYWNoZU5vZGUsXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgdHJlZVBhdGNoOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKSB7XG4gIGxldCBhcHBsaWVkUGF0Y2ggPSBmYWxzZVxuXG4gIG5ld0NhY2hlLnJzYyA9IGN1cnJlbnRDYWNoZS5yc2NcbiAgbmV3Q2FjaGUucHJlZmV0Y2hSc2MgPSBjdXJyZW50Q2FjaGUucHJlZmV0Y2hSc2NcbiAgbmV3Q2FjaGUubG9hZGluZyA9IGN1cnJlbnRDYWNoZS5sb2FkaW5nXG4gIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChjdXJyZW50Q2FjaGUucGFyYWxsZWxSb3V0ZXMpXG5cbiAgY29uc3Qgc2VnbWVudFBhdGhzVG9GaWxsID0gZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpLm1hcChcbiAgICAoc2VnbWVudCkgPT4gWy4uLmZsaWdodFNlZ21lbnRQYXRoLCAuLi5zZWdtZW50XVxuICApXG5cbiAgZm9yIChjb25zdCBzZWdtZW50UGF0aHMgb2Ygc2VnbWVudFBhdGhzVG9GaWxsKSB7XG4gICAgY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgobmV3Q2FjaGUsIGN1cnJlbnRDYWNoZSwgc2VnbWVudFBhdGhzKVxuXG4gICAgYXBwbGllZFBhdGNoID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGFwcGxpZWRQYXRjaFxufVxuXG5mdW5jdGlvbiBoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0KFxuICB1cmw6IFVSTCxcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBtdXRhYmxlOiBNdXRhYmxlLFxuICBwZW5kaW5nUHVzaDogYm9vbGVhbixcbiAgcmVzdWx0OiBOYXZpZ2F0aW9uUmVzdWx0XG4pOiBSZWR1Y2VyU3RhdGUge1xuICBzd2l0Y2ggKHJlc3VsdC50YWcpIHtcbiAgICBjYXNlIE5hdmlnYXRpb25SZXN1bHRUYWcuTVBBOiB7XG4gICAgICAvLyBQZXJmb3JtIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgY29uc3QgbmV3VXJsID0gcmVzdWx0LmRhdGFcbiAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgbmV3VXJsLCBwZW5kaW5nUHVzaClcbiAgICB9XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLk5vT3A6IHtcbiAgICAgIC8vIFRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggbm8gY2hhbmdlIHRvIHRoZSBjdXJyZW50IHBhZ2UuIEhvd2V2ZXIsIGlmXG4gICAgICAvLyB0aGUgVVJMIGNoYW5nZWQsIHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoYXQuXG4gICAgICBjb25zdCBuZXdDYW5vbmljYWxVcmwgPSByZXN1bHQuZGF0YS5jYW5vbmljYWxVcmxcbiAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gbmV3Q2Fub25pY2FsVXJsXG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBvbmx5IHRoaW5nIHRoYXQgY2hhbmdlZCB3YXMgdGhlIGhhc2ggZnJhZ21lbnQuXG4gICAgICBjb25zdCBvbGRVcmwgPSBuZXcgVVJMKHN0YXRlLmNhbm9uaWNhbFVybCwgdXJsKVxuICAgICAgY29uc3Qgb25seUhhc2hDaGFuZ2UgPVxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbXBhcmUgdGhlIG9yaWdpbnMsIGJlY2F1c2UgY2xpZW50LWRyaXZlblxuICAgICAgICAvLyBuYXZpZ2F0aW9ucyBhcmUgYWx3YXlzIHNhbWUtb3JpZ2luLlxuICAgICAgICB1cmwucGF0aG5hbWUgPT09IG9sZFVybC5wYXRobmFtZSAmJlxuICAgICAgICB1cmwuc2VhcmNoID09PSBvbGRVcmwuc2VhcmNoICYmXG4gICAgICAgIHVybC5oYXNoICE9PSBvbGRVcmwuaGFzaFxuICAgICAgaWYgKG9ubHlIYXNoQ2hhbmdlKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHVwZGF0ZWQgcGFydCBvZiB0aGUgVVJMIGlzIHRoZSBoYXNoLlxuICAgICAgICBtdXRhYmxlLm9ubHlIYXNoQ2hhbmdlID0gdHJ1ZVxuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHJlc3VsdC5kYXRhLnNob3VsZFNjcm9sbFxuICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IHVybC5oYXNoXG4gICAgICAgIC8vIFNldHRpbmcgdGhpcyB0byBhbiBlbXB0eSBhcnJheSB0cmlnZ2VycyBhIHNjcm9sbCBmb3IgYWxsIG5ldyBhbmRcbiAgICAgICAgLy8gdXBkYXRlZCBzZWdtZW50cy4gU2VlIGBTY3JvbGxBbmRGb2N1c0hhbmRsZXJgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIG11dGFibGUuc2Nyb2xsYWJsZVNlZ21lbnRzID0gW11cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfVxuICAgIGNhc2UgTmF2aWdhdGlvblJlc3VsdFRhZy5TdWNjZXNzOiB7XG4gICAgICAvLyBSZWNlaXZlZCBhIG5ldyByZXN1bHQuXG4gICAgICBtdXRhYmxlLmNhY2hlID0gcmVzdWx0LmRhdGEuY2FjaGVOb2RlXG4gICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gcmVzdWx0LmRhdGEuZmxpZ2h0Um91dGVyU3RhdGVcbiAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gcmVzdWx0LmRhdGEuY2Fub25pY2FsVXJsXG4gICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHJlc3VsdC5kYXRhLnNjcm9sbGFibGVTZWdtZW50c1xuICAgICAgbXV0YWJsZS5zaG91bGRTY3JvbGwgPSByZXN1bHQuZGF0YS5zaG91bGRTY3JvbGxcbiAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gcmVzdWx0LmRhdGEuaGFzaFxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfVxuICAgIGNhc2UgTmF2aWdhdGlvblJlc3VsdFRhZy5Bc3luYzoge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhLnRoZW4oXG4gICAgICAgIChhc3luY1Jlc3VsdCkgPT5cbiAgICAgICAgICBoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0KHVybCwgc3RhdGUsIG11dGFibGUsIHBlbmRpbmdQdXNoLCBhc3luY1Jlc3VsdCksXG4gICAgICAgIC8vIElmIHRoZSBuYXZpZ2F0aW9uIGZhaWxlZCwgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIG1hdGNoZXMgdGhlIGN1cnJlbnQgYmVoYXZpb3IgYnV0IHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nXG4gICAgICAgIC8vIGJldHRlciBoZXJlIGlmIHRoZSBuZXR3b3JrIGZhaWxzLlxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmVzdWx0IHNhdGlzZmllcyBuZXZlclxuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0ZVJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBOYXZpZ2F0ZUFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyB1cmwsIGlzRXh0ZXJuYWxVcmwsIG5hdmlnYXRlVHlwZSwgc2hvdWxkU2Nyb2xsLCBhbGxvd0FsaWFzaW5nIH0gPVxuICAgIGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBNdXRhYmxlID0ge31cbiAgY29uc3QgeyBoYXNoIH0gPSB1cmxcbiAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybClcbiAgY29uc3QgcGVuZGluZ1B1c2ggPSBuYXZpZ2F0ZVR5cGUgPT09ICdwdXNoJ1xuICAvLyB3ZSB3YW50IHRvIHBydW5lIHRoZSBwcmVmZXRjaCBjYWNoZSBvbiBldmVyeSBuYXZpZ2F0aW9uIHRvIGF2b2lkIGl0IGdyb3dpbmcgdG9vIGxhcmdlXG4gIHBydW5lUHJlZmV0Y2hDYWNoZShzdGF0ZS5wcmVmZXRjaENhY2hlKVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gcGVuZGluZ1B1c2hcblxuICBpZiAoaXNFeHRlcm5hbFVybCkge1xuICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgdXJsLnRvU3RyaW5nKCksIHBlbmRpbmdQdXNoKVxuICB9XG5cbiAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIGA8bWV0YSBodHRwLWVxdWl2PVwicmVmcmVzaFwiPmAgdGFnIGlzIHByZXNlbnQsXG4gIC8vIHdoaWNoIHdpbGwgdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQtcGFnZS1yZWRpcmVjdCcpKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaClcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUpIHtcbiAgICAvLyAoVmVyeSBFYXJseSBFeHBlcmltZW50YWwgRmVhdHVyZSkgU2VnbWVudCBDYWNoZVxuICAgIC8vXG4gICAgLy8gQnlwYXNzIHRoZSBub3JtYWwgcHJlZmV0Y2ggY2FjaGUgYW5kIHVzZSB0aGUgbmV3IHBlci1zZWdtZW50IGNhY2hlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gaW5zdGVhZC4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBpZiBQUFIgaXMgZW5hYmxlZCwgdG9vLlxuICAgIC8vXG4gICAgLy8gVGVtcG9yYXJ5IGdsdWUgY29kZSBiZXR3ZWVuIHRoZSByb3V0ZXIgcmVkdWNlciBhbmQgdGhlIG5ldyBuYXZpZ2F0aW9uXG4gICAgLy8gaW1wbGVtZW50YXRpb24uIEV2ZW50dWFsbHkgd2UnbGwgcmV3cml0ZSB0aGUgcm91dGVyIHJlZHVjZXIgdG8gYVxuICAgIC8vIHN0YXRlIG1hY2hpbmUuXG4gICAgY29uc3QgcmVzdWx0ID0gbmF2aWdhdGVVc2luZ1NlZ21lbnRDYWNoZShcbiAgICAgIHVybCxcbiAgICAgIHN0YXRlLmNhY2hlLFxuICAgICAgc3RhdGUudHJlZSxcbiAgICAgIHN0YXRlLm5leHRVcmwsXG4gICAgICBzaG91bGRTY3JvbGxcbiAgICApXG4gICAgcmV0dXJuIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQodXJsLCBzdGF0ZSwgbXV0YWJsZSwgcGVuZGluZ1B1c2gsIHJlc3VsdClcbiAgfVxuXG4gIGNvbnN0IHByZWZldGNoVmFsdWVzID0gZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgIHVybCxcbiAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICBhbGxvd0FsaWFzaW5nLFxuICB9KVxuICBjb25zdCB7IHRyZWVBdFRpbWVPZlByZWZldGNoLCBkYXRhIH0gPSBwcmVmZXRjaFZhbHVlc1xuXG4gIHByZWZldGNoUXVldWUuYnVtcChkYXRhKVxuXG4gIHJldHVybiBkYXRhLnRoZW4oXG4gICAgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSwgcG9zdHBvbmVkIH0pID0+IHtcbiAgICAgIGNvbnN0IG5hdmlnYXRlZEF0ID0gRGF0ZS5ub3coKVxuXG4gICAgICBsZXQgaXNGaXJzdFJlYWQgPSBmYWxzZVxuICAgICAgLy8gd2Ugb25seSB3YW50IHRvIG1hcmsgdGhpcyBvbmNlXG4gICAgICBpZiAoIXByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSkge1xuICAgICAgICAvLyBpbXBvcnRhbnQ6IHdlIHNob3VsZCBvbmx5IG1hcmsgdGhlIGNhY2hlIG5vZGUgYXMgZGlydHkgYWZ0ZXIgd2UgdW5zdXNwZW5kIGZyb20gdGhlIGNhbGwgYWJvdmVcbiAgICAgICAgcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lID0gbmF2aWdhdGVkQXRcbiAgICAgICAgaXNGaXJzdFJlYWQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVmZXRjaFZhbHVlcy5hbGlhc2VkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhhbmRsZUFsaWFzZWRQcmVmZXRjaEVudHJ5KFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIG11dGFibGVcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFdlIGRpZG4ndCByZXR1cm4gbmV3IHJvdXRlciBzdGF0ZSBiZWNhdXNlIHdlIGRpZG4ndCBhcHBseSB0aGUgYWxpYXNlZCBlbnRyeSBmb3Igc29tZSByZWFzb24uXG4gICAgICAgIC8vIFdlJ2xsIHJlLWludm9rZSB0aGUgbmF2aWdhdGlvbiBoYW5kbGVyIGJ1dCBlbnN1cmUgdGhhdCB3ZSBkb24ndCBhdHRlbXB0IHRvIHVzZSB0aGUgYWxpYXNlZCBlbnRyeS4gVGhpc1xuICAgICAgICAvLyB3aWxsIGNyZWF0ZSBhbiBvbi1kZW1hbmQgcHJlZmV0Y2ggZW50cnkuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRlUmVkdWNlcihzdGF0ZSwgeyAuLi5hY3Rpb24sIGFsbG93QWxpYXNpbmc6IGZhbHNlIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHBlbmRpbmdQdXNoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGVkQ2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgICAgOiBocmVmXG5cbiAgICAgIGNvbnN0IG9ubHlIYXNoQ2hhbmdlID1cbiAgICAgICAgISFoYXNoICYmXG4gICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybC5zcGxpdCgnIycsIDEpWzBdID09PVxuICAgICAgICAgIHVwZGF0ZWRDYW5vbmljYWxVcmwuc3BsaXQoJyMnLCAxKVswXVxuXG4gICAgICAvLyBJZiBvbmx5IHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGUgc2VydmVyIGhhc24ndCBzZW50IHVzIGFueSBuZXcgZGF0YS4gV2UgY2FuIGp1c3QgdXBkYXRlXG4gICAgICAvLyB0aGUgbXV0YWJsZSBwcm9wZXJ0aWVzIHJlc3BvbnNpYmxlIGZvciBVUkwgYW5kIHNjcm9sbCBoYW5kbGluZyBhbmQgcmV0dXJuIGVhcmx5LlxuICAgICAgaWYgKG9ubHlIYXNoQ2hhbmdlKSB7XG4gICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlXG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXBkYXRlZENhbm9uaWNhbFVybFxuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbFxuICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IGhhc2hcbiAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBbXVxuICAgICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICAgIH1cblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG4gICAgICBsZXQgc2Nyb2xsYWJsZVNlZ21lbnRzOiBGbGlnaHRTZWdtZW50UGF0aFtdID0gW11cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGF0aFRvU2VnbWVudDogZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgc2VlZERhdGEsXG4gICAgICAgICAgaGVhZCxcbiAgICAgICAgICBpc0hlYWRQYXJ0aWFsLFxuICAgICAgICAgIGlzUm9vdFJlbmRlcixcbiAgICAgICAgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIGxldCB0cmVlUGF0Y2ggPSBub3JtYWxpemVkRmxpZ2h0RGF0YS50cmVlXG5cbiAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkgPSBbJycsIC4uLmZsaWdodFNlZ21lbnRQYXRoXVxuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICBsZXQgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBocmVmXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgdHJlZSBwYXRjaCBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHRyZWUgdGhlbiB3ZSB1c2UgdGhlIHRyZWUgYXQgdGltZSBvZiBwcmVmZXRjaFxuICAgICAgICAvLyBUT0RPLUFQUDogVGhpcyBzaG91bGQgaW5zdGVhZCBmaWxsIGluIHRoZSBtaXNzaW5nIHBpZWNlcyBpbiBgY3VycmVudFRyZWVgIHdpdGggdGhlIGRhdGEgZnJvbSBgdHJlZUF0VGltZU9mUHJlZmV0Y2hgLCB0aGVuIGFwcGx5IHRoZSBwYXRjaC5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2gsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBocmVmXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGp1c3QgYSBwYXJhbm9pZCBjaGVjay4gV2hlbiBhIHJvdXRlIGlzIFBQUmVkLCB0aGUgc2VydmVyXG4gICAgICAgICAgICAvLyB3aWxsIHNlbmQgYmFjayBhIHN0YXRpYyByZXNwb25zZSB0aGF0J3MgcmVuZGVyZWQgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIHJvb3QuIElmIGZvciBzb21lIHJlYXNvbiBpdCBkb2Vzbid0LCB3ZSBmYWxsIGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBub24tUFBSIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlIGVsc2UgYnJhbmNoIGFuZCBkbyBhbGwgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgIC8vIHZpYSBzdGFydFBQUk5hdmlnYXRpb24uIFRoZSBjdXJyZW50IHN0cnVjdHVyZSBpcyBqdXN0XG4gICAgICAgICAgICAvLyBhbiBpbmNyZW1lbnRhbCBzdGVwLlxuICAgICAgICAgICAgc2VlZERhdGEgJiZcbiAgICAgICAgICAgIGlzUm9vdFJlbmRlciAmJlxuICAgICAgICAgICAgcG9zdHBvbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gc3RhcnRQUFJOYXZpZ2F0aW9uKFxuICAgICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgICAgICBzZWVkRGF0YSxcbiAgICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgICAgaXNIZWFkUGFydGlhbCxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodGFzay5yb3V0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIERldGVjdGVkIGEgY2hhbmdlIHRvIHRoZSByb290IGxheW91dC4gUGVyZm9ybSBhbiBmdWxsLVxuICAgICAgICAgICAgICAgIC8vIHBhZ2UgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVzZSB0aGUgdHJlZSBjb21wdXRlZCBieSBzdGFydFBQUk5hdmlnYXRpb24gaW5zdGVhZFxuICAgICAgICAgICAgICAvLyBvZiB0aGUgb25lIGNvbXB1dGVkIGJ5IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHJlbW92ZSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWVcbiAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgUFBSIHBhdGggZW50aXJlbHkuXG4gICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUgPSB0YXNrLnJvdXRlXG4gICAgICAgICAgICAgIG5ld1RyZWUgPSBwYXRjaGVkUm91dGVyU3RhdGVcblxuICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IHRhc2subm9kZVxuICAgICAgICAgICAgICBpZiAobmV3Q2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBjcmVhdGVkIGEgbmV3IENhY2hlIE5vZGUgdHJlZSB0aGF0IGNvbnRhaW5zIGEgcHJlZmV0Y2hlZFxuICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gb2YgdGhlIG5leHQgcGFnZS4gVGhpcyBjYW4gYmUgcmVuZGVyZWQgaW5zdGFudGx5LlxuICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBuZXdDYWNoZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZSA9IHRhc2suZHluYW1pY1JlcXVlc3RUcmVlXG4gICAgICAgICAgICAgIGlmIChkeW5hbWljUmVxdWVzdFRyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJlZmV0Y2hlZCB0cmVlIGhhcyBkeW5hbWljIGhvbGVzIGluIGl0LiBXZSBpbml0aWF0ZSBhXG4gICAgICAgICAgICAgICAgLy8gZHluYW1pYyByZXF1ZXN0IHRvIGZpbGwgdGhlbSBpbi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBibG9jayBvbiB0aGUgcmVzdWx0LiBXZSdsbCBpbW1lZGlhdGVseSByZW5kZXIgdGhlIENhY2hlXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB0cmVlIGFuZCBzdXNwZW5kIG9uIHRoZSBkeW5hbWljIHBhcnRzLiBXaGVuIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgLy8gY29tZXMgaW4sIHdlJ2xsIGZpbGwgaW4gbWlzc2luZyBkYXRhIGFuZCBwaW5nIFJlYWN0IHRvXG4gICAgICAgICAgICAgICAgLy8gcmUtcmVuZGVyLiBVbmxpa2UgdGhlIGxhenkgZmV0Y2hpbmcgbW9kZWwgaW4gdGhlIG5vbi1QUFJcbiAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgdGhpcyBpcyBtb2RlbGVkIGFzIGEgc2luZ2xlIFJlYWN0IHVwZGF0ZSArXG4gICAgICAgICAgICAgICAgLy8gc3RyZWFtaW5nLCByYXRoZXIgdGhhbiBtdWx0aXBsZSB0b3AtbGV2ZWwgdXBkYXRlcy4gKEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiB0aGUgbmV3IG1vZGVsLCB3ZSdsbCBzdGlsbCBuZWVkIHRvIHNvbWV0aW1lcyB1cGRhdGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gcm9vdCBtdWx0aXBsZSB0aW1lcyBwZXIgbmF2aWdhdGlvbiwgbGlrZSBpZiB0aGUgc2VydmVyIHNlbmRzIHVzXG4gICAgICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgcmVzcG9uc2UgdGhhbiB3ZSBleHBlY3RlZC4gRm9yIG5vdywgd2UgcmV2ZXJ0IGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbGF6eSBmZXRjaGluZyBtZWNoYW5pc20gaW4gdGhhdCBjYXNlLilcbiAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljUmVxdWVzdCA9IGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCB7XG4gICAgICAgICAgICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogZHluYW1pY1JlcXVlc3RUcmVlLFxuICAgICAgICAgICAgICAgICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QodGFzaywgZHluYW1pY1JlcXVlc3QpXG4gICAgICAgICAgICAgICAgLy8gV2Ugc3RvcmUgdGhlIGR5bmFtaWMgcmVxdWVzdCBvbiB0aGUgYGxhenlEYXRhYCBwcm9wZXJ0eSBvZiB0aGUgQ2FjaGVOb2RlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSdyZSBub3QgZ29pbmcgdG8gYXdhaXQgdGhlIGR5bmFtaWMgcmVxdWVzdCBoZXJlLiBTaW5jZSB3ZSdyZSBub3QgYmxvY2tpbmdcbiAgICAgICAgICAgICAgICAvLyBvbiB0aGUgZHluYW1pYyByZXF1ZXN0LCBgbGF5b3V0LXJvdXRlcmAgd2lsbFxuICAgICAgICAgICAgICAgIC8vIHRhc2subm9kZS5sYXp5RGF0YSA9IGR5bmFtaWNSZXF1ZXN0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByZWZldGNoZWQgdHJlZSBkb2VzIG5vdCBjb250YWluIGR5bmFtaWMgaG9sZXMg4oCUIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBmdWxseSBzdGF0aWMuIFdlIGNhbiBza2lwIHRoZSBkeW5hbWljIHJlcXVlc3QuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZCwgc28gcmV1c2UgdGhlIG9sZCBjYWNoZS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB0aGUgaGVhZCBjaGFuZ2VkIGJ1dCBub3QgYW55IG9mIHRoZSBzZWdtZW50IGRhdGE/XG4gICAgICAgICAgICAgIC8vIElzIHRoYXQgcG9zc2libGU/IElmIHNvLCB3ZSBzaG91bGQgY2xvbmUgdGhlIHdob2xlIHRyZWUgYW5kXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVhZC5cbiAgICAgICAgICAgICAgbmV3VHJlZSA9IHRyZWVQYXRjaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgc3RhdGljIHJlc3BvbnNlIGRvZXMgbm90IGluY2x1ZGUgYW55IGR5bmFtaWMgaG9sZXMsIHNvXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gZG8gYSBzZWNvbmQgcmVxdWVzdC5cbiAgICAgICAgICAgIC8vIFRPRE86IEFzIGFuIGluY3JlbWVudGFsIHN0ZXAgdGhpcyBqdXN0IHJldmVydHMgYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIG5vbi1QUFIgaW1wbGVtZW50YXRpb24uIFdlIGNhbiBzaW1wbGlmeSB0aGlzIGJyYW5jaCBmdXJ0aGVyLFxuICAgICAgICAgICAgLy8gZ2l2ZW4gdGhhdCBQUFIgcHJlZmV0Y2hlcyBhcmUgYWx3YXlzIHN0YXRpYyBhbmQgcmV0dXJuIHRoZSB3aG9sZVxuICAgICAgICAgICAgLy8gdHJlZS4gT3IgaW4gdGhlIG1lYW50aW1lIHdlIGNvdWxkIGZhY3RvciBpdCBvdXQgaW50byBhXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBmdW5jdGlvbi5cblxuICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgICAgICAgICAgIGxldCBhcHBsaWVkID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwcmVmZXRjaFZhbHVlcy5zdGF0dXMgPT09IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZSAmJlxuICAgICAgICAgICAgICAhaXNGaXJzdFJlYWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgYSBzdGFsZSBwcmVmZXRjaCBlbnRyeSwgd2Ugb25seSB3YW50IHRvIHJlLXVzZSB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgcm91dGUgd2UncmUgbmF2aWdhdGluZyB0bywgdG8gc3VwcG9ydCBpbnN0YW50IGxvYWRpbmcgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoIGZvciB0aGUgYWN0dWFsIHBhZ2UgZGF0YSBieSBudWxsaW5nIHRoZSBgcnNjYCBhbmQgYHByZWZldGNoUnNjYCB2YWx1ZXMgZm9yIHBhZ2UgZGF0YSxcbiAgICAgICAgICAgICAgLy8gd2hpbGUgY29weWluZyBvdmVyIHRoZSBgbG9hZGluZ2AgZm9yIHRoZSBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIHBhZ2UgZGF0YS5cbiAgICAgICAgICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIG9uIHN1YnNlcXVlbnQgcmVhZHMsIGFzIG90aGVyd2lzZSB0aGVyZSdkIGJlIG5vIGxvYWRpbmcgZGF0YSB0byByZS11c2UuXG5cbiAgICAgICAgICAgICAgLy8gV2Ugc2tpcCB0aGlzIGJyYW5jaCBpZiBvbmx5IHRoZSBoYXNoIGZyYWdtZW50IGhhcyBjaGFuZ2VkLCBhcyB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGluIHRoYXQgY2FzZVxuICAgICAgICAgICAgICBhcHBsaWVkID0gdHJpZ2dlckxhenlGZXRjaEZvckxlYWZTZWdtZW50cyhcbiAgICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgdHJlZVBhdGNoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgcmUtdXNlZCB0aGUgc3RhbGUgY2FjaGUncyBsb2FkaW5nIHN0YXRlICYgcmVmcmVzaGVkIHRoZSBkYXRhLFxuICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGBsYXN0VXNlZFRpbWVgIHNvIHRoYXQgaXQgY2FuIGNvbnRpbnVlIHRvIGJlIHJlLXVzZWQgZm9yIHRoZSBuZXh0IDMwc1xuICAgICAgICAgICAgICBwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUgPSBuYXZpZ2F0ZWRBdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwbGllZCA9IGFwcGx5RmxpZ2h0RGF0YShcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoYXJkTmF2aWdhdGUgPSBzaG91bGRIYXJkTmF2aWdhdGUoXG4gICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgICAgICBjdXJyZW50VHJlZVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAoaGFyZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgIC8vIENvcHkgcnNjIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgY2FjaGUucnNjID0gY3VycmVudENhY2hlLnJzY1xuICAgICAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IGN1cnJlbnRDYWNoZS5wcmVmZXRjaFJzY1xuXG4gICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoXG4gICAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBleGlzdGluZyBjYWNoZSB2YWx1ZSBpcyB1c2VkIHdoZW4gdGhlIGNhY2hlIHdhcyBub3QgaW52YWxpZGF0ZWQuXG4gICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcHBsaWVkKSB7XG4gICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgICAgICAvLyBJZiB3ZSBhcHBsaWVkIHRoZSBjYWNoZSwgd2UgdXBkYXRlIHRoZSBcImN1cnJlbnQgY2FjaGVcIiB2YWx1ZSBzbyBhbnkgb3RoZXJcbiAgICAgICAgICAgICAgLy8gc2VnbWVudHMgaW4gdGhlIEZsaWdodERhdGFQYXRoIHdpbGwgYmUgYWJsZSB0byByZWZlcmVuY2UgdGhlIHVwZGF0ZWQgY2FjaGUuXG4gICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViU2VnbWVudCBvZiBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHRyZWVQYXRjaCkpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoID0gW1xuICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIC4uLnN1YlNlZ21lbnQsXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgX19ERUZBVUxUX18gcGF0aHMgYXMgdGhleSBzaG91bGRuJ3QgYmUgc2Nyb2xsZWQgdG8gaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoW3Njcm9sbGFibGVTZWdtZW50UGF0aC5sZW5ndGggLSAxXSAhPT1cbiAgICAgICAgICAgICAgICBERUZBVUxUX1NFR01FTlRfS0VZXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50cy5wdXNoKHNjcm9sbGFibGVTZWdtZW50UGF0aClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBjdXJyZW50VHJlZVxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cGRhdGVkQ2Fub25pY2FsVXJsXG4gICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHNjcm9sbGFibGVTZWdtZW50c1xuICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSBoYXNoXG4gICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbFxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJoYW5kbGVFeHRlcm5hbFVybCIsIm5hdmlnYXRlUmVkdWNlciIsInN0YXRlIiwibXV0YWJsZSIsInVybCIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsImNhbm9uaWNhbFVybCIsInNjcm9sbGFibGVTZWdtZW50cyIsInVuZGVmaW5lZCIsImhhbmRsZU11dGFibGUiLCJnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoIiwiZmxpZ2h0Um91dGVyUGF0Y2giLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5IiwicGFyYWxsZWxSb3V0ZSIsImVudHJpZXMiLCJjaGlsZFNlZ21lbnQiLCJwdXNoIiwidHJpZ2dlckxhenlGZXRjaEZvckxlYWZTZWdtZW50cyIsIm5ld0NhY2hlIiwiY3VycmVudENhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJ0cmVlUGF0Y2giLCJhcHBsaWVkUGF0Y2giLCJyc2MiLCJwcmVmZXRjaFJzYyIsImxvYWRpbmciLCJNYXAiLCJzZWdtZW50UGF0aHNUb0ZpbGwiLCJtYXAiLCJzZWdtZW50UGF0aHMiLCJjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aCIsImhhbmRsZU5hdmlnYXRpb25SZXN1bHQiLCJyZXN1bHQiLCJ0YWciLCJOYXZpZ2F0aW9uUmVzdWx0VGFnIiwiTVBBIiwibmV3VXJsIiwiZGF0YSIsIk5vT3AiLCJuZXdDYW5vbmljYWxVcmwiLCJvbGRVcmwiLCJVUkwiLCJvbmx5SGFzaENoYW5nZSIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsInNob3VsZFNjcm9sbCIsImhhc2hGcmFnbWVudCIsIlN1Y2Nlc3MiLCJjYWNoZSIsImNhY2hlTm9kZSIsInBhdGNoZWRUcmVlIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJBc3luYyIsInRoZW4iLCJhc3luY1Jlc3VsdCIsImFjdGlvbiIsImlzRXh0ZXJuYWxVcmwiLCJuYXZpZ2F0ZVR5cGUiLCJhbGxvd0FsaWFzaW5nIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwicHJ1bmVQcmVmZXRjaENhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwidG9TdHJpbmciLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsIm5hdmlnYXRlVXNpbmdTZWdtZW50Q2FjaGUiLCJ0cmVlIiwibmV4dFVybCIsInByZWZldGNoVmFsdWVzIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsInByZWZldGNoUXVldWUiLCJidW1wIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwicG9zdHBvbmVkIiwibmF2aWdhdGVkQXQiLCJEYXRlIiwibm93IiwiaXNGaXJzdFJlYWQiLCJsYXN0VXNlZFRpbWUiLCJhbGlhc2VkIiwiaGFuZGxlQWxpYXNlZFByZWZldGNoRW50cnkiLCJ1cGRhdGVkQ2Fub25pY2FsVXJsIiwic3BsaXQiLCJjdXJyZW50VHJlZSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwicGF0aFRvU2VnbWVudCIsInNlZWREYXRhIiwiaGVhZCIsImlzSGVhZFBhcnRpYWwiLCJpc1Jvb3RSZW5kZXIiLCJmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkiLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwidGFzayIsInN0YXJ0UFBSTmF2aWdhdGlvbiIsInJvdXRlIiwicGF0Y2hlZFJvdXRlclN0YXRlIiwibm9kZSIsImR5bmFtaWNSZXF1ZXN0VHJlZSIsImR5bmFtaWNSZXF1ZXN0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJhcHBsaWVkIiwic3RhdHVzIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwic3RhbGUiLCJhcHBseUZsaWdodERhdGEiLCJoYXJkTmF2aWdhdGUiLCJzaG91bGRIYXJkTmF2aWdhdGUiLCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwic3ViU2VnbWVudCIsInNjcm9sbGFibGVTZWdtZW50UGF0aCIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ \"(ssr)/./node_modules/next/dist/client/components/promise-queue.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nconst prefetchReducer =  false ? 0 : prefetchReducerImpl;\nfunction identityReducerWhenSegmentCacheIsEnabled(state) {\n    // Unlike the old implementation, the Segment Cache doesn't store its data in\n    // the router reducer state.\n    //\n    // This shouldn't be reachable because we wrap the prefetch API in a check,\n    // too, which prevents the action from being dispatched. But it's here for\n    // clarity + code elimination.\n    return state;\n}\nfunction prefetchReducerImpl(state, action) {\n    // let's prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        allowAliasing: true\n    });\n    return state;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBVWFBLGFBQWE7ZUFBYkE7O0lBRUFDLGVBQWU7ZUFBZkE7OzswQ0FQZ0I7Z0RBSXRCO0FBQ0EsTUFBTUQsZ0JBQWdCLElBQUlFLGNBQUFBLFlBQVksQ0FBQztBQUV2QyxNQUFNRCxrQkFBa0JFLE1BQXVDLEdBQ2xFRyxDQUF3Q0EsR0FDeENDO0FBRUosU0FBU0QseUNBQTRDRSxLQUFRO0lBQzNELDZFQUE2RTtJQUM3RSw0QkFBNEI7SUFDNUIsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSwwRUFBMEU7SUFDMUUsOEJBQThCO0lBQzlCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTRCxvQkFDUEMsS0FBMkIsRUFDM0JDLE1BQXNCO0lBRXRCLDREQUE0RDtJQUM1REMsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFBQSxFQUFtQkYsTUFBTUcsYUFBYTtJQUV0QyxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHSDtJQUVoQkksQ0FBQUEsR0FBQUEsb0JBQUFBLDZCQUFBQSxFQUE4QjtRQUM1QkQ7UUFDQUUsU0FBU04sTUFBTU0sT0FBTztRQUN0QkgsZUFBZUgsTUFBTUcsYUFBYTtRQUNsQ0ksTUFBTU4sT0FBT00sSUFBSTtRQUNqQkMsTUFBTVIsTUFBTVEsSUFBSTtRQUNoQkMsZUFBZTtJQUNqQjtJQUVBLE9BQU9UO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxwcmVmZXRjaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgUHJlZmV0Y2hBY3Rpb24sXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgUHJvbWlzZVF1ZXVlIH0gZnJvbSAnLi4vLi4vcHJvbWlzZS1xdWV1ZSdcbmltcG9ydCB7XG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBwcnVuZVByZWZldGNoQ2FjaGUsXG59IGZyb20gJy4uL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuZXhwb3J0IGNvbnN0IHByZWZldGNoUXVldWUgPSBuZXcgUHJvbWlzZVF1ZXVlKDUpXG5cbmV4cG9ydCBjb25zdCBwcmVmZXRjaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgPyBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkXG4gIDogcHJlZmV0Y2hSZWR1Y2VySW1wbFxuXG5mdW5jdGlvbiBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkPFQ+KHN0YXRlOiBUKTogVCB7XG4gIC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0cyBkYXRhIGluXG4gIC8vIHRoZSByb3V0ZXIgcmVkdWNlciBzdGF0ZS5cbiAgLy9cbiAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlIGJlY2F1c2Ugd2Ugd3JhcCB0aGUgcHJlZmV0Y2ggQVBJIGluIGEgY2hlY2ssXG4gIC8vIHRvbywgd2hpY2ggcHJldmVudHMgdGhlIGFjdGlvbiBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuIEJ1dCBpdCdzIGhlcmUgZm9yXG4gIC8vIGNsYXJpdHkgKyBjb2RlIGVsaW1pbmF0aW9uLlxuICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFByZWZldGNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICAvLyBsZXQncyBwcnVuZSB0aGUgcHJlZmV0Y2ggY2FjaGUgYmVmb3JlIHdlIGRvIGFueXRoaW5nIGVsc2VcbiAgcHJ1bmVQcmVmZXRjaENhY2hlKHN0YXRlLnByZWZldGNoQ2FjaGUpXG5cbiAgY29uc3QgeyB1cmwgfSA9IGFjdGlvblxuXG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICB1cmwsXG4gICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIGtpbmQ6IGFjdGlvbi5raW5kLFxuICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgYWxsb3dBbGlhc2luZzogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gc3RhdGVcbn1cbiJdLCJuYW1lcyI6WyJwcmVmZXRjaFF1ZXVlIiwicHJlZmV0Y2hSZWR1Y2VyIiwiUHJvbWlzZVF1ZXVlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsImlkZW50aXR5UmVkdWNlcldoZW5TZWdtZW50Q2FjaGVJc0VuYWJsZWQiLCJwcmVmZXRjaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwidXJsIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwia2luZCIsInRyZWUiLCJhbGxvd0FsaWFzaW5nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"refreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(ssr)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(ssr)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            currentTree[0],\n            currentTree[1],\n            currentTree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null\n    });\n    const navigatedAt = Date.now();\n    return cache.lazyData.then(async (param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const loading = cacheNodeSeedData[3];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = loading;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                navigatedAt,\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQW9CZ0JBOzs7ZUFBQUE7OztpREFwQm9COytDQUNGO3lEQUNVO3lEQUNBOzZDQU9WOzJDQUNKOzJEQUVnQjt1Q0FDVDttREFDQzsrREFDWTs2REFDRjswQ0FDVjtBQUUvQixTQUFTQSxlQUNkQyxLQUEyQixFQUMzQkMsTUFBcUI7SUFFckIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CLElBQUlDLGNBQWNOLE1BQU1PLElBQUk7SUFFNUJKLFFBQVFLLDBCQUEwQixHQUFHO0lBRXJDLE1BQU1DLFFBQW1CQyxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBQUE7SUFFekIsc0ZBQXNGO0lBQ3RGLHNIQUFzSDtJQUN0SCxNQUFNQyxpQkFBaUJDLENBQUFBLEdBQUFBLG1DQUFBQSxpQ0FBaUMsRUFBQ1osTUFBTU8sSUFBSTtJQUVuRSx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDRSxNQUFNSSxRQUFRLEdBQUdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFBb0IsSUFBSUMsSUFBSVgsTUFBTUYsU0FBUztRQUMxRGMsbUJBQW1CO1lBQ2pCVixXQUFXLENBQUMsRUFBRTtZQUNkQSxXQUFXLENBQUMsRUFBRTtZQUNkQSxXQUFXLENBQUMsRUFBRTtZQUNkO1NBQ0Q7UUFDRFcsU0FBU04saUJBQWlCWCxNQUFNaUIsT0FBTyxHQUFHO0lBQzVDO0lBRUEsTUFBTUMsY0FBY0MsS0FBS0MsR0FBRztJQUM1QixPQUFPWCxNQUFNSSxRQUFRLENBQUNRLElBQUksQ0FDeEI7WUFBTyxFQUFFQyxVQUFVLEVBQUVqQixjQUFja0Isb0JBQW9CLEVBQUU7UUFDdkQsNERBQTREO1FBQzVELElBQUksT0FBT0QsZUFBZSxVQUFVO1lBQ2xDLE9BQU9FLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHhCLE9BQ0FHLFNBQ0FtQixZQUNBdEIsTUFBTXlCLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLCtEQUErRDtRQUMvRGpCLE1BQU1JLFFBQVEsR0FBRztRQUVqQixLQUFLLE1BQU1jLHdCQUF3QkwsV0FBWTtZQUM3QyxNQUFNLEVBQ0pmLE1BQU1xQixTQUFTLEVBQ2ZDLFVBQVVDLGlCQUFpQixFQUMzQkMsSUFBSSxFQUNKQyxZQUFZLEVBQ2IsR0FBR0w7WUFFSixJQUFJLENBQUNLLGNBQWM7Z0JBQ2pCLG9DQUFvQztnQkFDcENDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPbEM7WUFDVDtZQUVBLE1BQU1tQyxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQ2Q7Z0JBQ0M7YUFBRyxFQUNKOUIsYUFDQXNCLFdBQ0E1QixNQUFNSyxZQUFZO1lBR3BCLElBQUk4QixZQUFZLE1BQU07Z0JBQ3BCLE9BQU9FLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBQUEsRUFBc0JyQyxPQUFPQyxRQUFRMkI7WUFDOUM7WUFFQSxJQUFJVSxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQTRCaEMsYUFBYTZCLFVBQVU7Z0JBQ3JELE9BQU9YLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHhCLE9BQ0FHLFNBQ0FDLE1BQ0FKLE1BQU15QixPQUFPLENBQUNDLFdBQVc7WUFFN0I7WUFFQSxNQUFNYSwyQkFBMkJoQix1QkFDN0JpQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCakIsd0JBQ2xCa0I7WUFFSixJQUFJbEIsc0JBQXNCO2dCQUN4QnBCLFFBQVFFLFlBQVksR0FBR2tDO1lBQ3pCO1lBRUEsOEZBQThGO1lBQzlGLElBQUlULHNCQUFzQixNQUFNO2dCQUM5QixNQUFNWSxNQUFNWixpQkFBaUIsQ0FBQyxFQUFFO2dCQUNoQyxNQUFNYSxVQUFVYixpQkFBaUIsQ0FBQyxFQUFFO2dCQUNwQ3JCLE1BQU1pQyxHQUFHLEdBQUdBO2dCQUNaakMsTUFBTW1DLFdBQVcsR0FBRztnQkFDcEJuQyxNQUFNa0MsT0FBTyxHQUFHQTtnQkFDaEJFLENBQUFBLEdBQUFBLCtCQUFBQSw2QkFBQUEsRUFDRTNCLGFBQ0FULE9BQ0EsV0FFQW1CLFdBQ0FFLG1CQUNBQyxNQUNBVTtnQkFFRixJQUFJSyxLQUF1QyxFQUFFLEVBRTVDLE1BQU07b0JBQ0wzQyxRQUFRK0MsYUFBYSxHQUFHLElBQUlDO2dCQUM5QjtZQUNGO1lBRUEsTUFBTUMsQ0FBQUEsR0FBQUEsaUNBQUFBLCtCQUFBQSxFQUFnQztnQkFDcENsQztnQkFDQWxCO2dCQUNBcUQsYUFBYWxCO2dCQUNibUIsY0FBYzdDO2dCQUNkRTtnQkFDQU4sY0FBY0YsUUFBUUUsWUFBWSxJQUFJTCxNQUFNSyxZQUFZO1lBQzFEO1lBRUFGLFFBQVFNLEtBQUssR0FBR0E7WUFDaEJOLFFBQVFvRCxXQUFXLEdBQUdwQjtZQUV0QjdCLGNBQWM2QjtRQUNoQjtRQUVBLE9BQU9xQixDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjeEQsT0FBT0c7SUFDOUIsR0FDQSxJQUFNSDtBQUVWIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyZWR1Y2Vyc1xccmVmcmVzaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgTXV0YWJsZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVmcmVzaEFjdGlvbixcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCB9IGZyb20gJy4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgaGFuZGxlU2VnbWVudE1pc21hdGNoIH0gZnJvbSAnLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2gnXG5pbXBvcnQgeyBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUgfSBmcm9tICcuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlJ1xuaW1wb3J0IHsgcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyB9IGZyb20gJy4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMnXG5pbXBvcnQgeyByZXZhbGlkYXRlRW50aXJlQ2FjaGUgfSBmcm9tICcuLi8uLi9zZWdtZW50LWNhY2hlJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaFJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBSZWZyZXNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IG9yaWdpbiB9ID0gYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsXG5cbiAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG5cbiAgLy8gSWYgdGhlIGN1cnJlbnQgdHJlZSB3YXMgaW50ZXJjZXB0ZWQsIHRoZSBuZXh0VXJsIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC5cbiAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICBjb25zdCBpbmNsdWRlTmV4dFVybCA9IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShzdGF0ZS50cmVlKVxuXG4gIC8vIFRPRE8tQVBQOiB2ZXJpZnkgdGhhdCBgaHJlZmAgaXMgbm90IGFuIGV4dGVybmFsIHVybC5cbiAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICBjYWNoZS5sYXp5RGF0YSA9IGZldGNoU2VydmVyUmVzcG9uc2UobmV3IFVSTChocmVmLCBvcmlnaW4pLCB7XG4gICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtcbiAgICAgIGN1cnJlbnRUcmVlWzBdLFxuICAgICAgY3VycmVudFRyZWVbMV0sXG4gICAgICBjdXJyZW50VHJlZVsyXSxcbiAgICAgICdyZWZldGNoJyxcbiAgICBdLFxuICAgIG5leHRVcmw6IGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsXG4gIH0pXG5cbiAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG4gIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKFxuICAgIGFzeW5jICh7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUgfSkgPT4ge1xuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBjYWNoZS5sYXp5RGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgY2FjaGUubGF6eURhdGEgPSBudWxsXG5cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHJlZTogdHJlZVBhdGNoLFxuICAgICAgICAgIHNlZWREYXRhOiBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICAgICAgICBoZWFkLFxuICAgICAgICAgIGlzUm9vdFJlbmRlcixcbiAgICAgICAgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG5cbiAgICAgICAgaWYgKCFpc1Jvb3RSZW5kZXIpIHtcbiAgICAgICAgICAvLyBUT0RPLUFQUDogaGFuZGxlIHRoaXMgY2FzZSBiZXR0ZXJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKVxuICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgWycnXSxcbiAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgIClcblxuICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVTZWdtZW50TWlzbWF0Y2goc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZSkge1xuICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgcHJlZmV0Y2ggb25seSByZXR1cm5zIHRoZSByb3V0ZXIgdHJlZSBwYXRjaCB3aXRob3V0IHJlbmRlcmVkIGNvbXBvbmVudHMuXG4gICAgICAgIGlmIChjYWNoZU5vZGVTZWVkRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHJzYyA9IGNhY2hlTm9kZVNlZWREYXRhWzFdXG4gICAgICAgICAgY29uc3QgbG9hZGluZyA9IGNhY2hlTm9kZVNlZWREYXRhWzNdXG4gICAgICAgICAgY2FjaGUucnNjID0gcnNjXG4gICAgICAgICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBudWxsXG4gICAgICAgICAgY2FjaGUubG9hZGluZyA9IGxvYWRpbmdcbiAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAvLyBFeGlzdGluZyBjYWNoZSBpcyBub3QgcGFzc2VkIGluIGFzIGByb3V0ZXIucmVmcmVzaCgpYCBoYXMgdG8gaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLlxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgICAgY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUpIHtcbiAgICAgICAgICAgIHJldmFsaWRhdGVFbnRpcmVDYWNoZShzdGF0ZS5uZXh0VXJsLCBuZXdUcmVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdXRhYmxlLnByZWZldGNoQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHtcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB1cGRhdGVkVHJlZTogbmV3VHJlZSxcbiAgICAgICAgICB1cGRhdGVkQ2FjaGU6IGNhY2hlLFxuICAgICAgICAgIGluY2x1ZGVOZXh0VXJsLFxuICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmwgfHwgc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICB9KVxuXG4gICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZVxuXG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJyZWZyZXNoUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwib3JpZ2luIiwibXV0YWJsZSIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJjdXJyZW50VHJlZSIsInRyZWUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsInRoZW4iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZVBhdGNoIiwic2VlZERhdGEiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwicnNjIiwibG9hZGluZyIsInByZWZldGNoUnNjIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsIk1hcCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJ1cGRhdGVkVHJlZSIsInVwZGF0ZWRDYWNoZSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"restoreReducer\", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQVNnQkE7OztlQUFBQTs7OytDQVRrQjtnREFNZTs0Q0FDSTtBQUU5QyxTQUFTQSxlQUNkQyxLQUEyQixFQUMzQkMsTUFBcUI7SUFFckIsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLElBQUksRUFBRSxHQUFHRjtJQUN0QixNQUFNRyxPQUFPQyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCSDtJQUMvQiwwRUFBMEU7SUFDMUUsNEZBQTRGO0lBQzVGLGdHQUFnRztJQUNoRyw2RkFBNkY7SUFDN0YsOERBQThEO0lBQzlELHlHQUF5RztJQUN6RyxNQUFNSSxnQkFBZ0JILFFBQVFILE1BQU1HLElBQUk7SUFFeEMsTUFBTUksV0FBV1AsTUFBTVEsS0FBSztJQUM1QixNQUFNQyxXQUFXQyxNQUFzQixHQUVuQywyREFDMkQ7SUFDM0QsMkJBQTJCO0lBQzNCRyxDQUE2RFAsR0FDN0RDO1FBZ0JPTztJQWRYLE9BQU87UUFDTCxvQkFBb0I7UUFDcEJDLGNBQWNYO1FBQ2RZLFNBQVM7WUFDUEMsYUFBYTtZQUNiQyxlQUFlO1lBQ2YsNkZBQTZGO1lBQzdGQyw0QkFBNEI7UUFDOUI7UUFDQUMsbUJBQW1CcEIsTUFBTW9CLGlCQUFpQjtRQUMxQ1osT0FBT0M7UUFDUFksZUFBZXJCLE1BQU1xQixhQUFhO1FBQ2xDLHdCQUF3QjtRQUN4QmxCLE1BQU1HO1FBQ05nQixTQUFTUixDQUFBQSxvQ0FBQUEsQ0FBQUEsR0FBQUEsb0JBQUFBLGdDQUFBQSxFQUFpQ1IsY0FBQUEsS0FBQUEsT0FBakNRLG9DQUFtRFosSUFBSXFCLFFBQVE7SUFDMUU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXHJlc3RvcmUtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHR5cGUge1xuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgUmVkdWNlclN0YXRlLFxuICBSZXN0b3JlQWN0aW9uLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vY29tcHV0ZS1jaGFuZ2VkLXBhdGgnXG5pbXBvcnQgeyB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24gfSBmcm9tICcuLi9wcHItbmF2aWdhdGlvbnMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlc3RvcmVBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgdXJsLCB0cmVlIH0gPSBhY3Rpb25cbiAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybClcbiAgLy8gVGhpcyBhY3Rpb24gaXMgdXNlZCB0byByZXN0b3JlIHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgLy8gSG93ZXZlciwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBoaXN0b3J5IHN0YXRlIG5vIGxvbmdlciBjb250YWlucyB0aGUgYEZsaWdodFJvdXRlclN0YXRlYC5cbiAgLy8gV2Ugd2lsbCBjb3B5IG92ZXIgdGhlIGludGVybmFsIHN0YXRlIG9uIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgZXZlbnRzLCBidXQgaWYgYSBoaXN0b3J5IGVudHJ5XG4gIC8vIG9jY3VycmVkIGJlZm9yZSBoeWRyYXRpb24sIG9yIGlmIHRoZSB1c2VyIG5hdmlnYXRlZCB0byBhIGhhc2ggdXNpbmcgYSByZWd1bGFyIGFuY2hvciBsaW5rLFxuICAvLyB0aGUgaGlzdG9yeSBzdGF0ZSB3aWxsIG5vdCBjb250YWluIHRoZSBgRmxpZ2h0Um91dGVyU3RhdGVgLlxuICAvLyBJbiB0aGlzIGNhc2UsIHdlJ2xsIGNvbnRpbnVlIHRvIHVzZSB0aGUgZXhpc3RpbmcgdHJlZSBzbyB0aGUgcm91dGVyIGRvZXNuJ3QgZ2V0IGludG8gYW4gaW52YWxpZCBzdGF0ZS5cbiAgY29uc3QgdHJlZVRvUmVzdG9yZSA9IHRyZWUgfHwgc3RhdGUudHJlZVxuXG4gIGNvbnN0IG9sZENhY2hlID0gc3RhdGUuY2FjaGVcbiAgY29uc3QgbmV3Q2FjaGUgPSBwcm9jZXNzLmVudi5fX05FWFRfUFBSXG4gICAgPyAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCB3ZSB1cGRhdGUgdGhlIGNhY2hlIHRvIGRyb3AgdGhlIHByZWZldGNoXG4gICAgICAvLyBkYXRhIGZvciBhbnkgc2VnbWVudCB3aG9zZSBkeW5hbWljIGRhdGEgd2FzIGFscmVhZHkgcmVjZWl2ZWQuIFRoaXNcbiAgICAgIC8vIHByZXZlbnRzIGFuIHVubmVjZXNzYXJ5IGZsYXNoIGJhY2sgdG8gUFBSIHN0YXRlIGR1cmluZyBhXG4gICAgICAvLyBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbi5cbiAgICAgIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbihvbGRDYWNoZSwgdHJlZVRvUmVzdG9yZSlcbiAgICA6IG9sZENhY2hlXG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTZXQgY2Fub25pY2FsIHVybFxuICAgIGNhbm9uaWNhbFVybDogaHJlZixcbiAgICBwdXNoUmVmOiB7XG4gICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgY3VzdG9tIGhpc3Rvcnkgc3RhdGUgdGhhdCB3YXMgc2V0IGlzIHByZXNlcnZlZCB3aGVuIGFwcGx5aW5nIHRoaXMgdXBkYXRlLlxuICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWUsXG4gICAgfSxcbiAgICBmb2N1c0FuZFNjcm9sbFJlZjogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgY2FjaGU6IG5ld0NhY2hlLFxuICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgLy8gUmVzdG9yZSBwcm92aWRlZCB0cmVlXG4gICAgdHJlZTogdHJlZVRvUmVzdG9yZSxcbiAgICBuZXh0VXJsOiBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSh0cmVlVG9SZXN0b3JlKSA/PyB1cmwucGF0aG5hbWUsXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJyZXN0b3JlUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidXJsIiwidHJlZSIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInRyZWVUb1Jlc3RvcmUiLCJvbGRDYWNoZSIsImNhY2hlIiwibmV3Q2FjaGUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1BQUiIsInVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiY2Fub25pY2FsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJwcmVmZXRjaENhY2hlIiwibmV4dFVybCIsInBhdGhuYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverActionReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ \"(ssr)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../../app-find-source-map-url */ \"(ssr)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ \"(ssr)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _assignlocation = __webpack_require__(/*! ../../../assign-location */ \"(ssr)/./node_modules/next/dist/client/assign-location.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(ssr)/./node_modules/next/dist/client/components/app-router.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../../flight-data-helpers */ \"(ssr)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _redirect = __webpack_require__(/*! ../../redirect */ \"(ssr)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ../../redirect-error */ \"(ssr)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../remove-base-path */ \"(ssr)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../has-base-path */ \"(ssr)/./node_modules/next/dist/client/has-base-path.js\");\nconst _serverreferenceinfo = __webpack_require__(/*! ../../../../shared/lib/server-reference-info */ \"(ssr)/./node_modules/next/dist/shared/lib/server-reference-info.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(ssr)/./node_modules/next/dist/client/components/segment-cache.js\");\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, createTemporaryReferenceSet, encodeReply } =  true ? __webpack_require__(/*! react-server-dom-webpack/client.edge */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-webpack-client-edge.js\") : 0;\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;\n    const body = await encodeReply(usedArgs, {\n        temporaryReferences\n    });\n    const res = await fetch('', {\n        method: 'POST',\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION_HEADER]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location, _redirectType] = (redirectHeader == null ? void 0 : redirectHeader.split(';')) || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = _redirecterror.RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = _redirecterror.RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? (0, _assignlocation.assignLocation)(location, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    if (contentType == null ? void 0 : contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER)) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer,\n            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n            temporaryReferences\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            return {\n                actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n                redirectLocation,\n                redirectType,\n                revalidatedParts,\n                isPrerender\n            };\n        }\n        return {\n            actionResult: response.a,\n            actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            redirectLocation,\n            redirectType,\n            revalidatedParts,\n            isPrerender\n        };\n    }\n    // Handle invalid server action responses\n    if (res.status >= 400) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const error = contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(error), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return {\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    const navigatedAt = Date.now();\n    return fetchServerAction(state, nextUrl, action).then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;\n        let redirectHref;\n        // honor the redirect type instead of defaulting to push in case of server actions.\n        if (redirectLocation) {\n            if (redirectType === _redirecterror.RedirectType.replace) {\n                state.pushRef.pendingPush = false;\n                mutable.pendingPush = false;\n            } else {\n                state.pushRef.pendingPush = true;\n                mutable.pendingPush = true;\n            }\n            redirectHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = redirectHref;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === 'string') {\n            // Handle case when navigating to page in `pages` from `app`\n            resolve(actionResult);\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('SERVER ACTION APPLY FAILED');\n                resolve(actionResult);\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);\n            if (newTree === null) {\n                resolve(actionResult);\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                resolve(actionResult);\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);\n            }\n            // The server sent back RSC data for the server action, so we need to apply it to the cache.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = cacheNodeSeedData[3];\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                mutable.cache = cache;\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n                if (actionRevalidated) {\n                    await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                        navigatedAt,\n                        state,\n                        updatedTree: newTree,\n                        updatedCache: cache,\n                        includeNextUrl: Boolean(nextUrl),\n                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                    });\n                }\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        if (redirectLocation && redirectHref) {\n            if ( true && !actionRevalidated) {\n                // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n                // with the FlightData that we got from the server action for the target page, so that it's\n                // available when the page is navigated to and doesn't need to be re-fetched.\n                // We only do this if the server action didn't revalidate any data, as in that case the\n                // client cache will be cleared and the data will be re-fetched anyway.\n                // NOTE: We don't do this in the Segment Cache implementation.\n                // Dynamic data should never be placed into the cache, unless it's\n                // \"converted\" to static data using <Link prefetch={true}>. What we\n                // do instead is re-prefetch links and forms whenever the cache is\n                // invalidated.\n                (0, _prefetchcacheutils.createSeededPrefetchCacheEntry)({\n                    url: redirectLocation,\n                    data: {\n                        flightData,\n                        canonicalUrl: undefined,\n                        couldBeIntercepted: false,\n                        prerendered: false,\n                        postponed: false,\n                        // TODO: We should be able to set this if the server action\n                        // returned a fully static response.\n                        staleTime: -1\n                    },\n                    tree: state.tree,\n                    prefetchCache: state.prefetchCache,\n                    nextUrl: state.nextUrl,\n                    kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO\n                });\n                mutable.prefetchCache = state.prefetchCache;\n            }\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            reject((0, _redirect.getRedirectError)((0, _hasbasepath.hasBasePath)(redirectHref) ? (0, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));\n        } else {\n            resolve(actionResult);\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3VEQTRNZ0JBOzs7ZUFBQUE7OzsyQ0F4TVc7aURBQ007OENBTzFCO2dEQW9CQTs0Q0FDd0I7K0NBQ0c7NkNBQ0E7eURBQ1U7eURBQ0E7MkNBRWQ7MkRBQ2dCO3VDQUNUOytEQUNhO21EQUNaOzZEQUNVOytDQUl6QztzQ0FDMEI7MkNBQ0o7Z0RBQ2tCOzRDQUNoQjt5Q0FDSDtpREFJckI7MENBQytCO0FBNUN0QyxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEUsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLDJCQUEyQixFQUFFQyxXQUFXLEVBQUUsR0FDakUsS0FBMEIsR0FFdEJJLG1CQUFPQSxDQUFDLCtKQUFzQyxJQUU5Q0EsQ0FBMEM7QUFrRGhELGVBQWVDLGtCQUNiQyxLQUEyQixFQUMzQkMsT0FBd0MsRUFDeEMsS0FBNEM7SUFBNUMsTUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQXNCLEdBQTVDO0lBRUEsTUFBTUMsc0JBQXNCWDtJQUM1QixNQUFNWSxPQUFPQyxDQUFBQSxHQUFBQSxxQkFBQUEsZ0NBQWdDLEVBQUNKO0lBRTlDLDZFQUE2RTtJQUM3RSw4RUFBOEU7SUFDOUUsK0NBQStDO0lBQy9DLE1BQU1LLFdBQ0pGLEtBQUtHLElBQUksS0FBSyxjQUFjQyxDQUFBQSxHQUFBQSxxQkFBQUEsY0FBQUEsRUFBZU4sWUFBWUUsUUFBUUY7SUFFakUsTUFBTU8sT0FBTyxNQUFNaEIsWUFBWWEsVUFBVTtRQUFFSDtJQUFvQjtJQUUvRCxNQUFNTyxNQUFNLE1BQU1DLE1BQU0sSUFBSTtRQUMxQkMsUUFBUTtRQUNSQyxTQUFTO1lBQ1BDLFFBQVFDLGtCQUFBQSx1QkFBdUI7WUFDL0IsQ0FBQ0Msa0JBQUFBLGFBQWEsQ0FBQyxF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RTtvQkFDTHNFLE1BQU07d0JBQ0p0Qzt3QkFDQTdCLGNBQWNiO3dCQUNkaUYsb0JBQW9CO3dCQUNwQkMsYUFBYTt3QkFDYkMsV0FBVzt3QkFDWCwyREFBMkQ7d0JBQzNELG9DQUFvQzt3QkFDcENDLFdBQVcsQ0FBQztvQkFDZDtvQkFDQWhHLE1BQU10QixNQUFNc0IsSUFBSTtvQkFDaEJrRixlQUFleEcsTUFBTXdHLGFBQWE7b0JBQ2xDdkcsU0FBU0QsTUFBTUMsT0FBTztvQkFDdEJzSCxNQUFNcEYsY0FBY3FGLG9CQUFBQSxZQUFZLENBQUNDLElBQUksR0FBR0Qsb0JBQUFBLFlBQVksQ0FBQ0UsSUFBSTtnQkFDM0Q7Z0JBQ0F0RCxRQUFRb0MsYUFBYSxHQUFHeEcsTUFBTXdHLGFBQWE7WUFDN0M7WUFFQSwrRUFBK0U7WUFDL0UsK0VBQStFO1lBQy9FLHNGQUFzRjtZQUN0RixvRkFBb0Y7WUFDcEYsbUZBQW1GO1lBQ25GLDJDQUEyQztZQUMzQ3JDLE9BQ0V3RCxDQUFBQSxHQUFBQSxVQUFBQSxnQkFBQUEsRUFDRUMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWS9DLGdCQUNSZ0QsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQUFBLEVBQWVoRCxnQkFDZkEsY0FDSi9DLGdCQUFnQkMsZUFBQUEsWUFBWSxDQUFDQyxJQUFJO1FBR3ZDLE9BQU87WUFDTHNCLFFBQVFNO1FBQ1Y7UUFFQSxPQUFPa0UsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBQUEsRUFBYzlILE9BQU9vRTtJQUM5QixHQUNBLENBQUN6QjtRQUNDLG1IQUFtSDtRQUNuSHdCLE9BQU94QjtRQUVQLE9BQU8zQztJQUNUO0FBRUoiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxzZXJ2ZXItYWN0aW9uLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBBY3Rpb25GbGlnaHRSZXNwb25zZSxcbiAgQWN0aW9uUmVzdWx0LFxufSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGNhbGxTZXJ2ZXIgfSBmcm9tICcuLi8uLi8uLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgeyBmaW5kU291cmNlTWFwVVJMIH0gZnJvbSAnLi4vLi4vLi4vYXBwLWZpbmQtc291cmNlLW1hcC11cmwnXG5pbXBvcnQge1xuICBBQ1RJT05fSEVBREVSLFxuICBORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1VSTCxcbiAgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG59IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXItaGVhZGVycydcblxuLy8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IHsgY3JlYXRlRnJvbUZldGNoIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbi8vIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbi8vIGltcG9ydCB7IGVuY29kZVJlcGx5IH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbmNvbnN0IHsgY3JlYXRlRnJvbUZldGNoLCBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQsIGVuY29kZVJlcGx5IH0gPSAoXG4gICEhcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gICAgICByZXF1aXJlKCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmVkZ2UnKVxuICAgIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuICAgICAgcmVxdWlyZSgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCcpXG4pIGFzIHR5cGVvZiBpbXBvcnQoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnKVxuXG5pbXBvcnQge1xuICBQcmVmZXRjaEtpbmQsXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIHR5cGUgUmVkdWNlclN0YXRlLFxuICB0eXBlIFNlcnZlckFjdGlvbkFjdGlvbixcbiAgdHlwZSBTZXJ2ZXJBY3Rpb25NdXRhYmxlLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFzc2lnbkxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vYXNzaWduLWxvY2F0aW9uJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGhhbmRsZUV4dGVybmFsVXJsIH0gZnJvbSAnLi9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgeyBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCB9IGZyb20gJy4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyB9IGZyb20gJy4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMnXG5pbXBvcnQge1xuICBub3JtYWxpemVGbGlnaHREYXRhLFxuICB0eXBlIE5vcm1hbGl6ZWRGbGlnaHREYXRhLFxufSBmcm9tICcuLi8uLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgZ2V0UmVkaXJlY3RFcnJvciB9IGZyb20gJy4uLy4uL3JlZGlyZWN0J1xuaW1wb3J0IHsgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi4vLi4vcmVkaXJlY3QtZXJyb3InXG5pbXBvcnQgeyBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkgfSBmcm9tICcuLi9wcmVmZXRjaC1jYWNoZS11dGlscydcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7XG4gIGV4dHJhY3RJbmZvRnJvbVNlcnZlclJlZmVyZW5jZUlkLFxuICBvbWl0VW51c2VkQXJncyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9zZXJ2ZXItcmVmZXJlbmNlLWluZm8nXG5pbXBvcnQgeyByZXZhbGlkYXRlRW50aXJlQ2FjaGUgfSBmcm9tICcuLi8uLi9zZWdtZW50LWNhY2hlJ1xuXG50eXBlIEZldGNoU2VydmVyQWN0aW9uUmVzdWx0ID0ge1xuICByZWRpcmVjdExvY2F0aW9uOiBVUkwgfCB1bmRlZmluZWRcbiAgcmVkaXJlY3RUeXBlOiBSZWRpcmVjdFR5cGUgfCB1bmRlZmluZWRcbiAgYWN0aW9uUmVzdWx0PzogQWN0aW9uUmVzdWx0XG4gIGFjdGlvbkZsaWdodERhdGE/OiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nXG4gIGlzUHJlcmVuZGVyOiBib29sZWFuXG4gIHJldmFsaWRhdGVkUGFydHM6IHtcbiAgICB0YWc6IGJvb2xlYW5cbiAgICBjb29raWU6IGJvb2xlYW5cbiAgICBwYXRoczogc3RyaW5nW11cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZlckFjdGlvbihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBuZXh0VXJsOiBSZWFkb25seVJlZHVjZXJTdGF0ZVsnbmV4dFVybCddLFxuICB7IGFjdGlvbklkLCBhY3Rpb25BcmdzIH06IFNlcnZlckFjdGlvbkFjdGlvblxuKTogUHJvbWlzZTxGZXRjaFNlcnZlckFjdGlvblJlc3VsdD4ge1xuICBjb25zdCB0ZW1wb3JhcnlSZWZlcmVuY2VzID0gY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0KClcbiAgY29uc3QgaW5mbyA9IGV4dHJhY3RJbmZvRnJvbVNlcnZlclJlZmVyZW5jZUlkKGFjdGlvbklkKVxuXG4gIC8vIFRPRE86IEN1cnJlbnRseSwgd2UncmUgb25seSBvbWl0dGluZyB1bnVzZWQgYXJncyBmb3IgdGhlIGV4cGVyaW1lbnRhbCBcInVzZVxuICAvLyBjYWNoZVwiIGZ1bmN0aW9ucy4gT25jZSB0aGUgc2VydmVyIHJlZmVyZW5jZSBpbmZvIGJ5dGUgZmVhdHVyZSBpcyBzdGFibGUsIHdlXG4gIC8vIHNob3VsZCBhcHBseSB0aGlzIHRvIHNlcnZlciBhY3Rpb25zIGFzIHdlbGwuXG4gIGNvbnN0IHVzZWRBcmdzID1cbiAgICBpbmZvLnR5cGUgPT09ICd1c2UtY2FjaGUnID8gb21pdFVudXNlZEFyZ3MoYWN0aW9uQXJncywgaW5mbykgOiBhY3Rpb25BcmdzXG5cbiAgY29uc3QgYm9keSA9IGF3YWl0IGVuY29kZVJlcGx5KHVzZWRBcmdzLCB7IHRlbXBvcmFyeVJlZmVyZW5jZXMgfSlcblxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnJywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIEFjY2VwdDogUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG4gICAgICBbQUNUSU9OX0hFQURFUl06IGFjdGlvbklkLFxuICAgICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTogZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKVxuICAgICAgKSxcbiAgICAgIC4uLihwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAneC1kZXBsb3ltZW50LWlkJzogcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lELFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSksXG4gICAgICAuLi4obmV4dFVybFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIFtORVhUX1VSTF06IG5leHRVcmwsXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9KSxcbiAgICB9LFxuICAgIGJvZHksXG4gIH0pXG5cbiAgY29uc3QgcmVkaXJlY3RIZWFkZXIgPSByZXMuaGVhZGVycy5nZXQoJ3gtYWN0aW9uLXJlZGlyZWN0JylcbiAgY29uc3QgW2xvY2F0aW9uLCBfcmVkaXJlY3RUeXBlXSA9IHJlZGlyZWN0SGVhZGVyPy5zcGxpdCgnOycpIHx8IFtdXG4gIGxldCByZWRpcmVjdFR5cGU6IFJlZGlyZWN0VHlwZSB8IHVuZGVmaW5lZFxuICBzd2l0Y2ggKF9yZWRpcmVjdFR5cGUpIHtcbiAgICBjYXNlICdwdXNoJzpcbiAgICAgIHJlZGlyZWN0VHlwZSA9IFJlZGlyZWN0VHlwZS5wdXNoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgcmVkaXJlY3RUeXBlID0gUmVkaXJlY3RUeXBlLnJlcGxhY2VcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJlZGlyZWN0VHlwZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgaXNQcmVyZW5kZXIgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIpXG4gIGxldCByZXZhbGlkYXRlZFBhcnRzOiBGZXRjaFNlcnZlckFjdGlvblJlc3VsdFsncmV2YWxpZGF0ZWRQYXJ0cyddXG4gIHRyeSB7XG4gICAgY29uc3QgcmV2YWxpZGF0ZWRIZWFkZXIgPSBKU09OLnBhcnNlKFxuICAgICAgcmVzLmhlYWRlcnMuZ2V0KCd4LWFjdGlvbi1yZXZhbGlkYXRlZCcpIHx8ICdbW10sMCwwXSdcbiAgICApXG4gICAgcmV2YWxpZGF0ZWRQYXJ0cyA9IHtcbiAgICAgIHBhdGhzOiByZXZhbGlkYXRlZEhlYWRlclswXSB8fCBbXSxcbiAgICAgIHRhZzogISFyZXZhbGlkYXRlZEhlYWRlclsxXSxcbiAgICAgIGNvb2tpZTogcmV2YWxpZGF0ZWRIZWFkZXJbMl0sXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV2YWxpZGF0ZWRQYXJ0cyA9IHtcbiAgICAgIHBhdGhzOiBbXSxcbiAgICAgIHRhZzogZmFsc2UsXG4gICAgICBjb29raWU6IGZhbHNlLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlZGlyZWN0TG9jYXRpb24gPSBsb2NhdGlvblxuICAgID8gYXNzaWduTG9jYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBuZXcgVVJMKHN0YXRlLmNhbm9uaWNhbFVybCwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICApXG4gICAgOiB1bmRlZmluZWRcblxuICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJylcblxuICBpZiAoY29udGVudFR5cGU/LnN0YXJ0c1dpdGgoUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIpKSB7XG4gICAgY29uc3QgcmVzcG9uc2U6IEFjdGlvbkZsaWdodFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlRnJvbUZldGNoKFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHJlcyksXG4gICAgICB7IGNhbGxTZXJ2ZXIsIGZpbmRTb3VyY2VNYXBVUkwsIHRlbXBvcmFyeVJlZmVyZW5jZXMgfVxuICAgIClcblxuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgLy8gaWYgaXQgd2FzIGEgcmVkaXJlY3Rpb24sIHRoZW4gcmVzdWx0IGlzIGp1c3QgYSByZWd1bGFyIFJTQyBwYXlsb2FkXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb25GbGlnaHREYXRhOiBub3JtYWxpemVGbGlnaHREYXRhKHJlc3BvbnNlLmYpLFxuICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICByZWRpcmVjdFR5cGUsXG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgICAgIGlzUHJlcmVuZGVyLFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb25SZXN1bHQ6IHJlc3BvbnNlLmEsXG4gICAgICBhY3Rpb25GbGlnaHREYXRhOiBub3JtYWxpemVGbGlnaHREYXRhKHJlc3BvbnNlLmYpLFxuICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgIHJlZGlyZWN0VHlwZSxcbiAgICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgICBpc1ByZXJlbmRlcixcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgaW52YWxpZCBzZXJ2ZXIgYWN0aW9uIHJlc3BvbnNlc1xuICBpZiAocmVzLnN0YXR1cyA+PSA0MDApIHtcbiAgICAvLyBUaGUgc2VydmVyIGNhbiByZXNwb25kIHdpdGggYSB0ZXh0L3BsYWluIGVycm9yIG1lc3NhZ2UsIGJ1dCB3ZSdsbCBmYWxsYmFjayB0byBzb21ldGhpbmcgZ2VuZXJpY1xuICAgIC8vIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAgICBjb25zdCBlcnJvciA9XG4gICAgICBjb250ZW50VHlwZSA9PT0gJ3RleHQvcGxhaW4nXG4gICAgICAgID8gYXdhaXQgcmVzLnRleHQoKVxuICAgICAgICA6ICdBbiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdhcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuJ1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgIHJlZGlyZWN0VHlwZSxcbiAgICByZXZhbGlkYXRlZFBhcnRzLFxuICAgIGlzUHJlcmVuZGVyLFxuICB9XG59XG5cbi8qXG4gKiBUaGlzIHJlZHVjZXIgaXMgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgdGhlIHNlcnZlciBhY3Rpb24gYW5kIHByb2Nlc3NpbmcgYW55IHNpZGUtZWZmZWN0cyBmcm9tIHRoZSBzZXJ2ZXIgYWN0aW9uLlxuICogSXQgZG9lcyBub3QgbXV0YXRlIHRoZSBzdGF0ZSBieSBpdHNlbGYgYnV0IHJhdGhlciBkZWxlZ2F0ZXMgdG8gb3RoZXIgcmVkdWNlcnMgdG8gZG8gdGhlIGFjdHVhbCBtdXRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcnZlckFjdGlvblJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBTZXJ2ZXJBY3Rpb25BY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogU2VydmVyQWN0aW9uTXV0YWJsZSA9IHt9XG5cbiAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIC8vIG9ubHkgcGFzcyBhbG9uZyB0aGUgYG5leHRVcmxgIHBhcmFtICh1c2VkIGZvciBpbnRlcmNlcHRpb24gcm91dGVzKSBpZiB0aGUgY3VycmVudCByb3V0ZSB3YXMgaW50ZXJjZXB0ZWQuXG4gIC8vIElmIHRoZSByb3V0ZSBoYXMgYmVlbiBpbnRlcmNlcHRlZCwgdGhlIGFjdGlvbiBzaG91bGQgYmUgYXMgd2VsbC5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBzZXJ2ZXIgYWN0aW9uIG1pZ2h0IGJlIGludGVyY2VwdGVkIHdpdGggdGhlIHdyb25nIGFjdGlvbiBpZFxuICAvLyAoaWUsIG9uZSB0aGF0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGludGVyY2VwdGVkIHJvdXRlKVxuICBjb25zdCBuZXh0VXJsID1cbiAgICBzdGF0ZS5uZXh0VXJsICYmIGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShzdGF0ZS50cmVlKVxuICAgICAgPyBzdGF0ZS5uZXh0VXJsXG4gICAgICA6IG51bGxcblxuICBjb25zdCBuYXZpZ2F0ZWRBdCA9IERhdGUubm93KClcblxuICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc3RhdGUsIG5leHRVcmwsIGFjdGlvbikudGhlbihcbiAgICBhc3luYyAoe1xuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgYWN0aW9uRmxpZ2h0RGF0YTogZmxpZ2h0RGF0YSxcbiAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICByZWRpcmVjdFR5cGUsXG4gICAgICBpc1ByZXJlbmRlcixcbiAgICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHJlZGlyZWN0SHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgIC8vIGhvbm9yIHRoZSByZWRpcmVjdCB0eXBlIGluc3RlYWQgb2YgZGVmYXVsdGluZyB0byBwdXNoIGluIGNhc2Ugb2Ygc2VydmVyIGFjdGlvbnMuXG4gICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSBSZWRpcmVjdFR5cGUucmVwbGFjZSkge1xuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2ggPSBmYWxzZVxuICAgICAgICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2ggPSB0cnVlXG4gICAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZGlyZWN0SHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHJlZGlyZWN0TG9jYXRpb24sIGZhbHNlKVxuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IHJlZGlyZWN0SHJlZlxuICAgICAgfVxuXG4gICAgICBpZiAoIWZsaWdodERhdGEpIHtcbiAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWRpcmVjdCBidXQgbm8gZmxpZ2h0IGRhdGEgd2UgbmVlZCB0byBkbyBhIG1wYU5hdmlnYXRpb24uXG4gICAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgICAgcmVkaXJlY3RMb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aW9uUmV2YWxpZGF0ZWQgPVxuICAgICAgICByZXZhbGlkYXRlZFBhcnRzLnBhdGhzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cy50YWcgfHxcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cy5jb29raWVcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmVlOiB0cmVlUGF0Y2gsXG4gICAgICAgICAgc2VlZERhdGE6IGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgaXNSb290UmVuZGVyLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcblxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdTRVJWRVIgQUNUSU9OIEFQUExZIEZBSUxFRCcpXG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdpdmVuIHRoZSBwYXRoIGNhbiBvbmx5IGhhdmUgdHdvIGl0ZW1zIHRoZSBpdGVtcyBhcmUgb25seSB0aGUgcm91dGVyIHN0YXRlIGFuZCByc2MgZm9yIHRoZSByb290LlxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICByZWRpcmVjdEhyZWYgPyByZWRpcmVjdEhyZWYgOiBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlU2VnbWVudE1pc21hdGNoKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICByZWRpcmVjdEhyZWYgfHwgc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc2VudCBiYWNrIFJTQyBkYXRhIGZvciB0aGUgc2VydmVyIGFjdGlvbiwgc28gd2UgbmVlZCB0byBhcHBseSBpdCB0byB0aGUgY2FjaGUuXG4gICAgICAgIGlmIChjYWNoZU5vZGVTZWVkRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHJzYyA9IGNhY2hlTm9kZVNlZWREYXRhWzFdXG4gICAgICAgICAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgICAgICAgICBjYWNoZS5yc2MgPSByc2NcbiAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGxcbiAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM11cbiAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAvLyBFeGlzdGluZyBjYWNoZSBpcyBub3QgcGFzc2VkIGluIGFzIHNlcnZlciBhY3Rpb25zIGhhdmUgdG8gaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLlxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgICAgY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZUVudGlyZUNhY2hlKHN0YXRlLm5leHRVcmwsIG5ld1RyZWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWN0aW9uUmV2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoe1xuICAgICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHVwZGF0ZWRUcmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICB1cGRhdGVkQ2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICBpbmNsdWRlTmV4dFVybDogQm9vbGVhbihuZXh0VXJsKSxcbiAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybCB8fCBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgfVxuXG4gICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbiAmJiByZWRpcmVjdEhyZWYpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUgJiYgIWFjdGlvblJldmFsaWRhdGVkKSB7XG4gICAgICAgICAgLy8gQmVjYXVzZSB0aGUgUmVkaXJlY3RCb3VuZGFyeSB3aWxsIHRyaWdnZXIgYSBuYXZpZ2F0aW9uLCB3ZSBuZWVkIHRvIHNlZWQgdGhlIHByZWZldGNoIGNhY2hlXG4gICAgICAgICAgLy8gd2l0aCB0aGUgRmxpZ2h0RGF0YSB0aGF0IHdlIGdvdCBmcm9tIHRoZSBzZXJ2ZXIgYWN0aW9uIGZvciB0aGUgdGFyZ2V0IHBhZ2UsIHNvIHRoYXQgaXQnc1xuICAgICAgICAgIC8vIGF2YWlsYWJsZSB3aGVuIHRoZSBwYWdlIGlzIG5hdmlnYXRlZCB0byBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIHJlLWZldGNoZWQuXG4gICAgICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIGlmIHRoZSBzZXJ2ZXIgYWN0aW9uIGRpZG4ndCByZXZhbGlkYXRlIGFueSBkYXRhLCBhcyBpbiB0aGF0IGNhc2UgdGhlXG4gICAgICAgICAgLy8gY2xpZW50IGNhY2hlIHdpbGwgYmUgY2xlYXJlZCBhbmQgdGhlIGRhdGEgd2lsbCBiZSByZS1mZXRjaGVkIGFueXdheS5cbiAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCBkbyB0aGlzIGluIHRoZSBTZWdtZW50IENhY2hlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIC8vIER5bmFtaWMgZGF0YSBzaG91bGQgbmV2ZXIgYmUgcGxhY2VkIGludG8gdGhlIGNhY2hlLCB1bmxlc3MgaXQnc1xuICAgICAgICAgIC8vIFwiY29udmVydGVkXCIgdG8gc3RhdGljIGRhdGEgdXNpbmcgPExpbmsgcHJlZmV0Y2g9e3RydWV9Pi4gV2hhdCB3ZVxuICAgICAgICAgIC8vIGRvIGluc3RlYWQgaXMgcmUtcHJlZmV0Y2ggbGlua3MgYW5kIGZvcm1zIHdoZW5ldmVyIHRoZSBjYWNoZSBpc1xuICAgICAgICAgIC8vIGludmFsaWRhdGVkLlxuICAgICAgICAgIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgICAgICAgICB1cmw6IHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHBvc3Rwb25lZDogZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBiZSBhYmxlIHRvIHNldCB0aGlzIGlmIHRoZSBzZXJ2ZXIgYWN0aW9uXG4gICAgICAgICAgICAgIC8vIHJldHVybmVkIGEgZnVsbHkgc3RhdGljIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBzdGFsZVRpbWU6IC0xLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICAgICAgICAgIGtpbmQ6IGlzUHJlcmVuZGVyID8gUHJlZmV0Y2hLaW5kLkZVTEwgOiBQcmVmZXRjaEtpbmQuQVVUTyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IHN0YXRlLnByZWZldGNoQ2FjaGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBhY3Rpb24gdHJpZ2dlcmVkIGEgcmVkaXJlY3QsIHRoZSBhY3Rpb24gcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGhcbiAgICAgICAgLy8gYSByZWRpcmVjdCBzbyB0aGF0IGl0J3MgaGFuZGxlZCBieSBSZWRpcmVjdEJvdW5kYXJ5IGFzIHdlIHdvbid0IGhhdmUgYSB2YWxpZFxuICAgICAgICAvLyBhY3Rpb24gcmVzdWx0IHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aC4gVGhpcyB3aWxsIGVmZmVjdGl2ZWx5IHJlc2V0IHRoZSBzdGF0ZSBvZlxuICAgICAgICAvLyB0aGUgY29tcG9uZW50IHRoYXQgY2FsbGVkIHRoZSBhY3Rpb24gYXMgdGhlIGVycm9yIGJvdW5kYXJ5IHdpbGwgcmVtb3VudCB0aGUgdHJlZS5cbiAgICAgICAgLy8gVGhlIHN0YXR1cyBjb2RlIGRvZXNuJ3QgbWF0dGVyIGhlcmUgYXMgdGhlIGFjdGlvbiBoYW5kbGVyIHdpbGwgaGF2ZSBhbHJlYWR5IHNlbnRcbiAgICAgICAgLy8gYSByZXNwb25zZSB3aXRoIHRoZSBjb3JyZWN0IHN0YXR1cyBjb2RlLlxuICAgICAgICByZWplY3QoXG4gICAgICAgICAgZ2V0UmVkaXJlY3RFcnJvcihcbiAgICAgICAgICAgIGhhc0Jhc2VQYXRoKHJlZGlyZWN0SHJlZilcbiAgICAgICAgICAgICAgPyByZW1vdmVCYXNlUGF0aChyZWRpcmVjdEhyZWYpXG4gICAgICAgICAgICAgIDogcmVkaXJlY3RIcmVmLFxuICAgICAgICAgICAgcmVkaXJlY3RUeXBlIHx8IFJlZGlyZWN0VHlwZS5wdXNoXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfSxcbiAgICAoZTogYW55KSA9PiB7XG4gICAgICAvLyBXaGVuIHRoZSBzZXJ2ZXIgYWN0aW9uIGlzIHJlamVjdGVkIHdlIGRvbid0IHVwZGF0ZSB0aGUgc3RhdGUgYW5kIGluc3RlYWQgY2FsbCB0aGUgcmVqZWN0IGhhbmRsZXIgb2YgdGhlIHByb21pc2UuXG4gICAgICByZWplY3QoZSlcblxuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuICApXG59XG4iXSwibmFtZXMiOlsic2VydmVyQWN0aW9uUmVkdWNlciIsImNyZWF0ZUZyb21GZXRjaCIsImNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZVNldCIsImVuY29kZVJlcGx5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInJlcXVpcmUiLCJmZXRjaFNlcnZlckFjdGlvbiIsInN0YXRlIiwibmV4dFVybCIsImFjdGlvbklkIiwiYWN0aW9uQXJncyIsInRlbXBvcmFyeVJlZmVyZW5jZXMiLCJpbmZvIiwiZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQiLCJ1c2VkQXJncyIsInR5cGUiLCJvbWl0VW51c2VkQXJncyIsImJvZHkiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJBY2NlcHQiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIkFDVElPTl9IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmVlIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiTkVYVF9VUkwiLCJyZWRpcmVjdEhlYWRlciIsImdldCIsImxvY2F0aW9uIiwiX3JlZGlyZWN0VHlwZSIsInNwbGl0IiwicmVkaXJlY3RUeXBlIiwiUmVkaXJlY3RUeXBlIiwicHVzaCIsInJlcGxhY2UiLCJ1bmRlZmluZWQiLCJpc1ByZXJlbmRlciIsIk5FWFRfSVNfUFJFUkVOREVSX0hFQURFUiIsInJldmFsaWRhdGVkUGFydHMiLCJyZXZhbGlkYXRlZEhlYWRlciIsInBhcnNlIiwicGF0aHMiLCJ0YWciLCJjb29raWUiLCJlIiwicmVkaXJlY3RMb2NhdGlvbiIsImFzc2lnbkxvY2F0aW9uIiwiVVJMIiwiY2Fub25pY2FsVXJsIiwid2luZG93IiwiaHJlZiIsImNvbnRlbnRUeXBlIiwic3RhcnRzV2l0aCIsInJlc3BvbnNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYWxsU2VydmVyIiwiZmluZFNvdXJjZU1hcFVSTCIsImFjdGlvbkZsaWdodERhdGEiLCJub3JtYWxpemVGbGlnaHREYXRhIiwiZiIsImFjdGlvblJlc3VsdCIsImEiLCJzdGF0dXMiLCJlcnJvciIsInRleHQiLCJFcnJvciIsImFjdGlvbiIsInJlamVjdCIsIm11dGFibGUiLCJjdXJyZW50VHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwibmF2aWdhdGVkQXQiLCJEYXRlIiwibm93IiwidGhlbiIsImZsaWdodERhdGEiLCJyZWRpcmVjdEhyZWYiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjcmVhdGVIcmVmRnJvbVVybCIsImhhbmRsZUV4dGVybmFsVXJsIiwiYWN0aW9uUmV2YWxpZGF0ZWQiLCJsZW5ndGgiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWVQYXRjaCIsInNlZWREYXRhIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJoZWFkIiwiaXNSb290UmVuZGVyIiwiY29uc29sZSIsImxvZyIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJyc2MiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwicHJlZmV0Y2hSc2MiLCJsb2FkaW5nIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJyZXZhbGlkYXRlRW50aXJlQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwiaW5jbHVkZU5leHRVcmwiLCJCb29sZWFuIiwicGF0Y2hlZFRyZWUiLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJ1cmwiLCJkYXRhIiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlcmVuZGVyZWQiLCJwb3N0cG9uZWQiLCJzdGFsZVRpbWUiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsIkFVVE8iLCJnZXRSZWRpcmVjdEVycm9yIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImhhbmRsZU11dGFibGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverPatchReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(ssr)/./node_modules/next/dist/client/components/app-router.js\");\nfunction serverPatchReducer(state, action) {\n    const { serverResponse: { flightData, canonicalUrl: canonicalUrlOverride }, navigatedAt } = action;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === 'string') {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const normalizedFlightData of flightData){\n        const { segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            '',\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n        // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n        // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n        // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n        // the entire page to reload.\n        if (newTree === null) {\n            return state;\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7c0RBZWdCQTs7O2VBQUFBOzs7K0NBZmtCO3lEQUNVO3lEQUNBOzZDQU9WOzZDQUNGOzJDQUNGO3VDQUVPO0FBRTlCLFNBQVNBLG1CQUNkQyxLQUEyQixFQUMzQkMsTUFBeUI7SUFFekIsTUFBTSxFQUNKQyxnQkFBZ0IsRUFBRUMsVUFBVSxFQUFFQyxjQUFjQyxvQkFBb0IsRUFBRSxFQUNsRUMsV0FBVyxFQUNaLEdBQUdMO0lBRUosTUFBTU0sVUFBbUIsQ0FBQztJQUUxQkEsUUFBUUMsMEJBQTBCLEdBQUc7SUFFckMsNERBQTREO0lBQzVELElBQUksT0FBT0wsZUFBZSxVQUFVO1FBQ2xDLE9BQU9NLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTFQsT0FDQU8sU0FDQUosWUFDQUgsTUFBTVUsT0FBTyxDQUFDQyxXQUFXO0lBRTdCO0lBRUEsSUFBSUMsY0FBY1osTUFBTWEsSUFBSTtJQUM1QixJQUFJQyxlQUFlZCxNQUFNZSxLQUFLO0lBRTlCLEtBQUssTUFBTUMsd0JBQXdCYixXQUFZO1FBQzdDLE1BQU0sRUFBRWMsYUFBYUMsaUJBQWlCLEVBQUVMLE1BQU1NLFNBQVMsRUFBRSxHQUN2REg7UUFFRixNQUFNSSxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQ2Q7WUFDQztlQUFPSDtTQUFrQixFQUMxQk4sYUFDQU8sV0FDQW5CLE1BQU1JLFlBQVk7UUFHcEIsa0lBQWtJO1FBQ2xJLDhHQUE4RztRQUM5RyxvSUFBb0k7UUFDcEksbUlBQW1JO1FBQ25JLDZCQUE2QjtRQUM3QixJQUFJZ0IsWUFBWSxNQUFNO1lBQ3BCLE9BQU9wQjtRQUNUO1FBRUEsSUFBSXNCLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFBNEJWLGFBQWFRLFVBQVU7WUFDckQsT0FBT1gsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMVCxPQUNBTyxTQUNBUCxNQUFNSSxZQUFZLEVBQ2xCSixNQUFNVSxPQUFPLENBQUNDLFdBQVc7UUFFN0I7UUFFQSxNQUFNWSwyQkFBMkJsQix1QkFDN0JtQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCbkIsd0JBQ2xCb0I7UUFFSixJQUFJRiwwQkFBMEI7WUFDNUJoQixRQUFRSCxZQUFZLEdBQUdtQjtRQUN6QjtRQUVBLE1BQU1SLFFBQW1CVyxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBQUE7UUFDekJDLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFBQSxFQUFnQnJCLGFBQWFRLGNBQWNDLE9BQU9DO1FBRWxEVCxRQUFRcUIsV0FBVyxHQUFHUjtRQUN0QmIsUUFBUVEsS0FBSyxHQUFHQTtRQUVoQkQsZUFBZUM7UUFDZkgsY0FBY1E7SUFDaEI7SUFFQSxPQUFPUyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjN0IsT0FBT087QUFDOUIiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxzZXJ2ZXItcGF0Y2gtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgU2VydmVyUGF0Y2hBY3Rpb24sXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIE11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuLi9hcHBseS1mbGlnaHQtZGF0YSdcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJ2ZXJQYXRjaFJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBTZXJ2ZXJQYXRjaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3Qge1xuICAgIHNlcnZlclJlc3BvbnNlOiB7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUgfSxcbiAgICBuYXZpZ2F0ZWRBdCxcbiAgfSA9IGFjdGlvblxuXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgc3RhdGUsXG4gICAgICBtdXRhYmxlLFxuICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICApXG4gIH1cblxuICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG4gIGxldCBjdXJyZW50Q2FjaGUgPSBzdGF0ZS5jYWNoZVxuXG4gIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgIGNvbnN0IHsgc2VnbWVudFBhdGg6IGZsaWdodFNlZ21lbnRQYXRoLCB0cmVlOiB0cmVlUGF0Y2ggfSA9XG4gICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgIFsnJywgLi4uZmxpZ2h0U2VnbWVudFBhdGhdLFxuICAgICAgY3VycmVudFRyZWUsXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICApXG5cbiAgICAvLyBgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlYCByZXR1cm5zIGBudWxsYCB3aGVuIGl0IGRldGVybWluZWQgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIGlzIG5vdCBhcHBsaWNhYmxlIHRvIHRoZSBjdXJyZW50IHRyZWUuXG4gICAgLy8gSW4gb3RoZXIgd29yZHMsIHRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSB0cmVlIHRoYXQgZG9lc24ndCBtYXRjaCB3aGF0IHRoZSBjbGllbnQgaXMgY3VycmVudGx5IHJlbmRlcmluZy5cbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHNlcnZlciBwYXRjaCBhY3Rpb24gdG9vayBsb25nZXIgdG8gcmVzb2x2ZSB0aGFuIGEgc3Vic2VxdWVudCBuYXZpZ2F0aW9uIHdoaWNoIHdvdWxkIGhhdmUgY2hhbmdlZCB0aGUgdHJlZS5cbiAgICAvLyBQcmV2aW91c2x5IHRoaXMgY2FzZSB0cmlnZ2VyZWQgYW4gTVBBIG5hdmlnYXRpb24gYnV0IGl0IHNob3VsZCBiZSBzYWZlIHRvIHNpbXBseSBkaXNjYXJkIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgcmF0aGVyIHRoYW4gZm9yY2luZ1xuICAgIC8vIHRoZSBlbnRpcmUgcGFnZSB0byByZWxvYWQuXG4gICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdGF0ZVxuICAgIH1cblxuICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBtdXRhYmxlLFxuICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmKSB7XG4gICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gICAgYXBwbHlGbGlnaHREYXRhKG5hdmlnYXRlZEF0LCBjdXJyZW50Q2FjaGUsIGNhY2hlLCBub3JtYWxpemVkRmxpZ2h0RGF0YSlcblxuICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG4gICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG5cbiAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICB9XG5cbiAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG59XG4iXSwibmFtZXMiOlsic2VydmVyUGF0Y2hSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJzZXJ2ZXJSZXNwb25zZSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmwiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsIm5hdmlnYXRlZEF0IiwibXV0YWJsZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwic2VnbWVudFBhdGgiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/./node_modules/next/dist/shared/lib/segment.js\");\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { navigatedAt, state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === 'refresh' && // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), {\n            // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n            // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n            flightRouterState: [\n                rootTree[0],\n                rootTree[1],\n                rootTree[2],\n                'refetch'\n            ],\n            nextUrl: includeNextUrl ? state.nextUrl : null\n        }).then((param)=>{\n            let { flightData } = param;\n            if (typeof flightData !== 'string') {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n                    // just been created & has been written to, but hasn't been \"committed\" yet.\n                    (0, _applyflightdata.applyFlightData)(navigatedAt, updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            navigatedAt,\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n        tree[2] = path;\n        tree[3] = 'refresh';\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBeUhnQkEsd0NBQXdDO2VBQXhDQTs7SUE5Rk1DLCtCQUErQjtlQUEvQkE7Ozs2Q0F4QlU7aURBQ0k7cUNBQ0g7QUFzQjFCLGVBQWVBLGdDQUNwQkMsT0FBd0M7SUFFeEMsTUFBTUMsa0JBQWtCLElBQUlDO0lBQzVCLE1BQU1DLG9DQUFvQztRQUN4QyxHQUFHSCxPQUFPO1FBQ1ZJLFVBQVVKLFFBQVFLLFdBQVc7UUFDN0JKO0lBQ0Y7QUFDRjtBQUVBLGVBQWVFLG9DQUFvQyxLQVlsRDtJQVprRCxNQUNqREcsV0FBVyxFQUNYQyxLQUFLLEVBQ0xGLFdBQVcsRUFDWEcsWUFBWSxFQUNaQyxjQUFjLEVBQ2RSLGVBQWUsRUFDZkcsV0FBV0MsV0FBVyxFQUN0QkssWUFBWSxFQUliLEdBWmtEO0lBYWpELE1BQU0sR0FBR0MsZ0JBQWdCQyxhQUFhQyxjQUFjLEdBQUdSO0lBQ3ZELE1BQU1TLGdCQUFnQixFQUFFO0lBRXhCLElBQ0VGLGVBQ0FBLGdCQUFnQkYsZ0JBQ2hCRyxrQkFBa0IsYUFDbEIsNEZBQTRGO0lBQzVGLHNEQUFzRDtJQUN0RCxDQUFDWixnQkFBZ0JjLEdBQUcsQ0FBQ0gsY0FDckI7UUFDQVgsZ0JBQWdCZSxHQUFHLENBQUNKLGFBQWEsMkJBQTJCOztRQUU1RCx3SEFBd0g7UUFDeEgsa0lBQWtJO1FBQ2xJLE1BQU1LLGVBQWVDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFDbkIsSUFBSUMsSUFBSVAsYUFBYVEsU0FBU0MsTUFBTSxHQUNwQztZQUNFLGdHQUFnRztZQUNoRyw4SEFBOEg7WUFDOUhDLG1CQUFtQjtnQkFBQ2xCLFFBQVEsQ0FBQyxFQUFFO2dCQUFFQSxRQUFRLENBQUMsRUFBRTtnQkFBRUEsUUFBUSxDQUFDLEVBQUU7Z0JBQUU7YUFBVTtZQUNyRW1CLFNBQVNkLGlCQUFpQkYsTUFBTWdCLE9BQU8sR0FBRztRQUM1QyxHQUNBQyxJQUFJLENBQUM7Z0JBQUMsRUFBRUMsVUFBVSxFQUFFO1lBQ3BCLElBQUksT0FBT0EsZUFBZSxVQUFVO2dCQUNsQyxLQUFLLE1BQU1DLGtCQUFrQkQsV0FBWTtvQkFDdkMsd0ZBQXdGO29CQUN4Riw0R0FBNEc7b0JBQzVHLDRFQUE0RTtvQkFDNUVFLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFBQSxFQUNFckIsYUFDQUUsY0FDQUEsY0FDQWtCO2dCQUVKO1lBQ0YsT0FBTztZQUNMLDRHQUE0RztZQUM1RywrR0FBK0c7WUFDL0csc0VBQXNFO1lBQ3hFO1FBQ0Y7UUFFQVosY0FBY2MsSUFBSSxDQUFDWDtJQUNyQjtJQUVBLElBQUssTUFBTVksT0FBT2xCLGVBQWdCO1FBQ2hDLE1BQU1tQix1QkFBdUIzQixvQ0FBb0M7WUFDL0RHO1lBQ0FDO1lBQ0FGLGFBQWFNLGNBQWMsQ0FBQ2tCLElBQUk7WUFDaENyQjtZQUNBQztZQUNBUjtZQUNBRztZQUNBTTtRQUNGO1FBRUFJLGNBQWNjLElBQUksQ0FBQ0U7SUFDckI7SUFFQSxNQUFNQyxRQUFRQyxHQUFHLENBQUNsQjtBQUNwQjtBQVFPLFNBQVNoQix5Q0FDZG1DLElBQXVCLEVBQ3ZCQyxJQUFZO0lBRVosTUFBTSxDQUFDQyxTQUFTeEIsa0JBQWtCRSxjQUFjLEdBQUdvQjtJQUNuRCxvR0FBb0c7SUFDcEcsSUFBSUUsUUFBUUMsUUFBUSxDQUFDQyxTQUFBQSxnQkFBZ0IsS0FBS3hCLGtCQUFrQixXQUFXO1FBQ3JFb0IsSUFBSSxDQUFDLEVBQUUsR0FBR0M7UUFDVkQsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNaO0lBRUEsSUFBSyxNQUFNSixPQUFPbEIsZUFBZ0I7UUFDaENiLHlDQUF5Q2EsY0FBYyxDQUFDa0IsSUFBSSxFQUFFSztJQUNoRTtBQUNGIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlclN0YXRlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4vYXBwbHktZmxpZ2h0LWRhdGEnXG5pbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBQQUdFX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuXG5pbnRlcmZhY2UgUmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyB7XG4gIG5hdmlnYXRlZEF0OiBudW1iZXJcbiAgc3RhdGU6IEFwcFJvdXRlclN0YXRlXG4gIHVwZGF0ZWRUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICB1cGRhdGVkQ2FjaGU6IENhY2hlTm9kZVxuICBpbmNsdWRlTmV4dFVybDogYm9vbGVhblxuICBjYW5vbmljYWxVcmw6IHN0cmluZ1xufVxuXG4vKipcbiAqIFJlZnJlc2hlcyBpbmFjdGl2ZSBzZWdtZW50cyB0aGF0IGFyZSBzdGlsbCBpbiB0aGUgY3VycmVudCBGbGlnaHRSb3V0ZXJTdGF0ZS5cbiAqIEEgc2VnbWVudCBpcyBjb25zaWRlcmVkIFwiaW5hY3RpdmVcIiB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaW5kaWNhdGVzIGl0IGRpZG4ndCBtYXRjaCB0byBhIHBhZ2UgY29tcG9uZW50LlxuICogVGhpcyBoYXBwZW5zIGR1cmluZyBhIHNvZnQtbmF2aWdhdGlvbiwgd2hlcmUgdGhlIHNlcnZlciB3aWxsIHdhbnQgdG8gcGF0Y2ggaW4gdGhlIHNlZ21lbnRcbiAqIHdpdGggdGhlIFwiZGVmYXVsdFwiIGNvbXBvbmVudCwgYnV0IHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZSBzZXJ2ZXIgaW4gdGhpcyBjYXNlXG4gKiBhbmQga2VlcCB0aGUgZXhpc3Rpbmcgc3RhdGUgZm9yIHRoYXQgc2VnbWVudC4gTmV3IGRhdGEgZm9yIGluYWN0aXZlIHNlZ21lbnRzIGFyZSBpbmhlcmVudGx5XG4gKiBub3QgcGFydCBvZiB0aGUgc2VydmVyIHJlc3BvbnNlIHdoZW4gd2UgcGF0Y2ggdGhlIHRyZWUsIGJlY2F1c2UgdGhleSB3ZXJlIGFzc29jaWF0ZWQgd2l0aCBhIHJlc3BvbnNlXG4gKiBmcm9tIGFuIGVhcmxpZXIgbmF2aWdhdGlvbi9yZXF1ZXN0LiBGb3IgZWFjaCBzZWdtZW50LCBvbmNlIGl0IGJlY29tZXMgXCJhY3RpdmVcIiwgd2UgZW5jb2RlIHRoZSBVUkwgdGhhdCBwcm92aWRlZFxuICogdGhlIGRhdGEgZm9yIGl0LiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyBwYXJhbGxlbCByb3V0ZXMgbG9va2luZyBmb3IgdGhlc2UgbWFya2VycyBzbyB0aGF0IGl0IGNhbiByZS1mZXRjaFxuICogYW5kIHBhdGNoIHRoZSBuZXcgZGF0YSBpbnRvIHRoZSB0cmVlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyhcbiAgb3B0aW9uczogUmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c1xuKSB7XG4gIGNvbnN0IGZldGNoZWRTZWdtZW50cyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHJvb3RUcmVlOiBvcHRpb25zLnVwZGF0ZWRUcmVlLFxuICAgIGZldGNoZWRTZWdtZW50cyxcbiAgfSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwoe1xuICBuYXZpZ2F0ZWRBdCxcbiAgc3RhdGUsXG4gIHVwZGF0ZWRUcmVlLFxuICB1cGRhdGVkQ2FjaGUsXG4gIGluY2x1ZGVOZXh0VXJsLFxuICBmZXRjaGVkU2VnbWVudHMsXG4gIHJvb3RUcmVlID0gdXBkYXRlZFRyZWUsXG4gIGNhbm9uaWNhbFVybCxcbn06IFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMgJiB7XG4gIGZldGNoZWRTZWdtZW50czogU2V0PHN0cmluZz5cbiAgcm9vdFRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG59KSB7XG4gIGNvbnN0IFssIHBhcmFsbGVsUm91dGVzLCByZWZldGNoUGF0aCwgcmVmZXRjaE1hcmtlcl0gPSB1cGRhdGVkVHJlZVxuICBjb25zdCBmZXRjaFByb21pc2VzID0gW11cblxuICBpZiAoXG4gICAgcmVmZXRjaFBhdGggJiZcbiAgICByZWZldGNoUGF0aCAhPT0gY2Fub25pY2FsVXJsICYmXG4gICAgcmVmZXRjaE1hcmtlciA9PT0gJ3JlZnJlc2gnICYmXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHRyZWUgdG8gY29udGFpbiBtdWx0aXBsZSBzZWdtZW50cyB0aGF0IGNvbnRhaW4gZGF0YSBhdCB0aGUgc2FtZSBVUkxcbiAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHRoZW0gc28gd2UgY2FuIGRlZHVwZSB0aGUgcmVxdWVzdHNcbiAgICAhZmV0Y2hlZFNlZ21lbnRzLmhhcyhyZWZldGNoUGF0aClcbiAgKSB7XG4gICAgZmV0Y2hlZFNlZ21lbnRzLmFkZChyZWZldGNoUGF0aCkgLy8gTWFyayB0aGlzIFVSTCBhcyBmZXRjaGVkXG5cbiAgICAvLyBFYWdlcmx5IGtpY2sgb2ZmIHRoZSBmZXRjaCBmb3IgdGhlIHJlZmV0Y2ggcGF0aCAmIHRoZSBwYXJhbGxlbCByb3V0ZXMuIFRoaXMgc2hvdWxkIGJlIGZpbmUgdG8gZG8gYXMgdGhleSBlYWNoIG9wZXJhdGVcbiAgICAvLyBpbmRlcGVuZGVudGx5IG9uIHRoZWlyIG93biBjYWNoZSBub2RlcywgYW5kIGBhcHBseUZsaWdodERhdGFgIHdpbGwgY29weSBhbnl0aGluZyBpdCBkb2Vzbid0IGNhcmUgYWJvdXQgZnJvbSB0aGUgZXhpc3RpbmcgY2FjaGUuXG4gICAgY29uc3QgZmV0Y2hQcm9taXNlID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgICAgIG5ldyBVUkwocmVmZXRjaFBhdGgsIGxvY2F0aW9uLm9yaWdpbiksXG4gICAgICB7XG4gICAgICAgIC8vIHJlZmV0Y2ggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdXBkYXRlZCB0cmVlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBzY29wZWQgdG8gdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAgICAvLyBhbmQgbWlnaHQgbm90IGNvbnRhaW4gdGhlIGRhdGEgd2UgbmVlZCB0byBwYXRjaCBpbiBpbnRlcmNlcHRpb24gcm91dGUgZGF0YSAoc3VjaCBhcyBkeW5hbWljIHBhcmFtcyBmcm9tIGEgcHJldmlvdXMgc2VnbWVudClcbiAgICAgICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtyb290VHJlZVswXSwgcm9vdFRyZWVbMV0sIHJvb3RUcmVlWzJdLCAncmVmZXRjaCddLFxuICAgICAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsLFxuICAgICAgfVxuICAgICkudGhlbigoeyBmbGlnaHREYXRhIH0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgICAgLy8gd2Ugb25seSBwYXNzIHRoZSBuZXcgY2FjaGUgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgY2xlYXJpbmcgdGhlIHJvdXRlciBjYWNoZVxuICAgICAgICAgIC8vIGFuZCBmaWxsaW5nIGluIHRoZSBuZXcgcGFnZSBkYXRhIGZyb20gdGhlIHNlcnZlci4gTWVhbmluZyB0aGUgZXhpc3RpbmcgY2FjaGUgaXMgYWN0dWFsbHkgdGhlIGNhY2hlIHRoYXQnc1xuICAgICAgICAgIC8vIGp1c3QgYmVlbiBjcmVhdGVkICYgaGFzIGJlZW4gd3JpdHRlbiB0bywgYnV0IGhhc24ndCBiZWVuIFwiY29tbWl0dGVkXCIgeWV0LlxuICAgICAgICAgIGFwcGx5RmxpZ2h0RGF0YShcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgdXBkYXRlZENhY2hlLFxuICAgICAgICAgICAgdXBkYXRlZENhY2hlLFxuICAgICAgICAgICAgZmxpZ2h0RGF0YVBhdGhcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gZmxpZ2h0RGF0YSBpcyBhIHN0cmluZywgaXQgc3VnZ2VzdHMgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIHNob3VsZCBoYXZlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvblxuICAgICAgICAvLyBJJ20gbm90IDEwMCUgc3VyZSBvZiB0aGlzIGRlY2lzaW9uLCBidXQgaXQgc2VlbXMgdW5saWtlbHkgdGhhdCB3ZSdkIHdhbnQgdG8gaW50cm9kdWNlIGEgcmVkaXJlY3Qgc2lkZSBlZmZlY3RcbiAgICAgICAgLy8gd2hlbiByZWZyZXNoaW5nIG9uLXNjcmVlbiBkYXRhLCBzbyBoYW5kbGluZyB0aGlzIGhhcyBiZWVuIG9tbWl0dGVkLlxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmZXRjaFByb21pc2VzLnB1c2goZmV0Y2hQcm9taXNlKVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBjb25zdCBwYXJhbGxlbEZldGNoUHJvbWlzZSA9IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgc3RhdGUsXG4gICAgICB1cGRhdGVkVHJlZTogcGFyYWxsZWxSb3V0ZXNba2V5XSxcbiAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgIGluY2x1ZGVOZXh0VXJsLFxuICAgICAgZmV0Y2hlZFNlZ21lbnRzLFxuICAgICAgcm9vdFRyZWUsXG4gICAgICBjYW5vbmljYWxVcmwsXG4gICAgfSlcblxuICAgIGZldGNoUHJvbWlzZXMucHVzaChwYXJhbGxlbEZldGNoUHJvbWlzZSlcbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKGZldGNoUHJvbWlzZXMpXG59XG5cbi8qKlxuICogV2Fsa3MgdGhlIGN1cnJlbnQgcGFyYWxsZWwgc2VnbWVudHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIFwiYWN0aXZlXCIuXG4gKiBBbiBhY3RpdmUgcGFyYWxsZWwgcm91dGUgd2lsbCBoYXZlIGEgYF9fUEFHRV9fYCBzZWdtZW50IGluIHRoZSBGbGlnaHRSb3V0ZXJTdGF0ZS5cbiAqIEFzIG9wcG9zZWQgdG8gYSBgX19ERUZBVUxUX19gIHNlZ21lbnQsIHdoaWNoIG1lYW5zIHRoZXJlIHdhcyBubyBtYXRjaCBmb3IgdGhhdCBwYXJhbGxlbCByb3V0ZS5cbiAqIFdlIGFkZCBhIHNwZWNpYWwgbWFya2VyIGhlcmUgc28gdGhhdCB3ZSBrbm93IGhvdyB0byByZWZyZXNoIGl0cyBkYXRhIHdoZW4gdGhlIHJvdXRlciBpcyByZXZhbGlkYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMoXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXRoOiBzdHJpbmdcbikge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXMsICwgcmVmZXRjaE1hcmtlcl0gPSB0cmVlXG4gIC8vIGEgcGFnZSBzZWdtZW50IG1pZ2h0IGFsc28gY29udGFpbiBjb25jYXRlbmF0ZWQgc2VhcmNoIHBhcmFtcywgc28gd2UgZG8gYSBwYXJ0aWFsIG1hdGNoIG9uIHRoZSBrZXlcbiAgaWYgKHNlZ21lbnQuaW5jbHVkZXMoUEFHRV9TRUdNRU5UX0tFWSkgJiYgcmVmZXRjaE1hcmtlciAhPT0gJ3JlZnJlc2gnKSB7XG4gICAgdHJlZVsyXSA9IHBhdGhcbiAgICB0cmVlWzNdID0gJ3JlZnJlc2gnXG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMocGFyYWxsZWxSb3V0ZXNba2V5XSwgcGF0aClcbiAgfVxufVxuIl0sIm5hbWVzIjpbImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwib3B0aW9ucyIsImZldGNoZWRTZWdtZW50cyIsIlNldCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsIiwicm9vdFRyZWUiLCJ1cGRhdGVkVHJlZSIsIm5hdmlnYXRlZEF0Iiwic3RhdGUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsImNhbm9uaWNhbFVybCIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFBhdGgiLCJyZWZldGNoTWFya2VyIiwiZmV0Y2hQcm9taXNlcyIsImhhcyIsImFkZCIsImZldGNoUHJvbWlzZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInRoZW4iLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJhcHBseUZsaWdodERhdGEiLCJwdXNoIiwia2V5IiwicGFyYWxsZWxGZXRjaFByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwidHJlZSIsInBhdGgiLCJzZWdtZW50IiwiaW5jbHVkZXMiLCJQQUdFX1NFR01FTlRfS0VZIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_PREFETCH = 'prefetch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n    return PrefetchKind;\n}({});\nvar PrefetchCacheEntryStatus = /*#__PURE__*/ function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\n    return PrefetchCacheEntryStatus;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQVlhQSxrQkFBa0I7ZUFBbEJBOztJQUpBQyxlQUFlO2VBQWZBOztJQUdBQyxlQUFlO2VBQWZBOztJQUpBQyxjQUFjO2VBQWRBOztJQUVBQyxjQUFjO2VBQWRBOztJQUlBQyxvQkFBb0I7ZUFBcEJBOztJQUhBQyxtQkFBbUI7ZUFBbkJBOztJQXlNREMsd0JBQXdCO2VBQXhCQTs7SUFoRUFDLFlBQVk7ZUFBWkE7OztBQTVJTCxNQUFNTCxpQkFBaUI7QUFDdkIsTUFBTUYsa0JBQWtCO0FBQ3hCLE1BQU1HLGlCQUFpQjtBQUN2QixNQUFNRSxzQkFBc0I7QUFDNUIsTUFBTUosa0JBQWtCO0FBQ3hCLE1BQU1GLHFCQUFxQjtBQUMzQixNQUFNSyx1QkFBdUI7QUFzSTdCLElBQUtHLGVBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFlBQUFBOzs7O1dBQUFBOztBQWdFTCxJQUFLRCwyQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsd0JBQUFBOzs7OztXQUFBQSIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccm91dGVyLXJlZHVjZXItdHlwZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEZsaWdodFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG5leHBvcnQgY29uc3QgQUNUSU9OX1JFRlJFU0ggPSAncmVmcmVzaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fTkFWSUdBVEUgPSAnbmF2aWdhdGUnXG5leHBvcnQgY29uc3QgQUNUSU9OX1JFU1RPUkUgPSAncmVzdG9yZSdcbmV4cG9ydCBjb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gJ3NlcnZlci1wYXRjaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSAncHJlZmV0Y2gnXG5leHBvcnQgY29uc3QgQUNUSU9OX0hNUl9SRUZSRVNIID0gJ2htci1yZWZyZXNoJ1xuZXhwb3J0IGNvbnN0IEFDVElPTl9TRVJWRVJfQUNUSU9OID0gJ3NlcnZlci1hY3Rpb24nXG5cbmV4cG9ydCB0eXBlIFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoe1xuICBuYXZpZ2F0ZWRBdCxcbiAgcHJldmlvdXNUcmVlLFxuICBzZXJ2ZXJSZXNwb25zZSxcbn06IHtcbiAgbmF2aWdhdGVkQXQ6IG51bWJlclxuICBwcmV2aW91c1RyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4gIHNlcnZlclJlc3BvbnNlOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0XG59KSA9PiB2b2lkXG5cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YWJsZSB7XG4gIG1wYU5hdmlnYXRpb24/OiBib29sZWFuXG4gIHBhdGNoZWRUcmVlPzogRmxpZ2h0Um91dGVyU3RhdGVcbiAgY2Fub25pY2FsVXJsPzogc3RyaW5nXG4gIHNjcm9sbGFibGVTZWdtZW50cz86IEZsaWdodFNlZ21lbnRQYXRoW11cbiAgcGVuZGluZ1B1c2g/OiBib29sZWFuXG4gIGNhY2hlPzogQ2FjaGVOb2RlXG4gIHByZWZldGNoQ2FjaGU/OiBBcHBSb3V0ZXJTdGF0ZVsncHJlZmV0Y2hDYWNoZSddXG4gIGhhc2hGcmFnbWVudD86IHN0cmluZ1xuICBzaG91bGRTY3JvbGw/OiBib29sZWFuXG4gIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlPzogYm9vbGVhblxuICBvbmx5SGFzaENoYW5nZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJBY3Rpb25NdXRhYmxlIGV4dGVuZHMgTXV0YWJsZSB7XG4gIGluRmxpZ2h0U2VydmVyQWN0aW9uPzogUHJvbWlzZTxhbnk+IHwgbnVsbFxufVxuXG4vKipcbiAqIFJlZnJlc2ggdHJpZ2dlcnMgYSByZWZyZXNoIG9mIHRoZSBmdWxsIHBhZ2UgZGF0YS5cbiAqIC0gZmV0Y2hlcyB0aGUgRmxpZ2h0IGRhdGEgYW5kIGZpbGxzIHJzYyBhdCB0aGUgcm9vdCBvZiB0aGUgY2FjaGUuXG4gKiAtIFRoZSByb3V0ZXIgc3RhdGUgaXMgdXBkYXRlZCBhdCB0aGUgcm9vdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWZyZXNoQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9SRUZSRVNIXG4gIG9yaWdpbjogTG9jYXRpb25bJ29yaWdpbiddXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG1yUmVmcmVzaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fSE1SX1JFRlJFU0hcbiAgb3JpZ2luOiBMb2NhdGlvblsnb3JpZ2luJ11cbn1cblxuZXhwb3J0IHR5cGUgU2VydmVyQWN0aW9uRGlzcGF0Y2hlciA9IChcbiAgYXJnczogT21pdDxcbiAgICBTZXJ2ZXJBY3Rpb25BY3Rpb24sXG4gICAgJ3R5cGUnIHwgJ211dGFibGUnIHwgJ25hdmlnYXRlJyB8ICdjaGFuZ2VCeVNlcnZlclJlc3BvbnNlJyB8ICdjYWNoZSdcbiAgPlxuKSA9PiB2b2lkXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyQWN0aW9uQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9TRVJWRVJfQUNUSU9OXG4gIGFjdGlvbklkOiBzdHJpbmdcbiAgYWN0aW9uQXJnczogYW55W11cbiAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWRcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkXG59XG5cbi8qKlxuICogTmF2aWdhdGUgdHJpZ2dlcnMgYSBuYXZpZ2F0aW9uIHRvIHRoZSBwcm92aWRlZCB1cmwuIEl0IHN1cHBvcnRzIHR3byB0eXBlczogYHB1c2hgIGFuZCBgcmVwbGFjZWAuXG4gKlxuICogYG5hdmlnYXRlVHlwZWA6XG4gKiAtIGBwdXNoYCAtIHB1c2hlcyBhIG5ldyBoaXN0b3J5IGVudHJ5IGluIHRoZSBicm93c2VyIGhpc3RvcnlcbiAqIC0gYHJlcGxhY2VgIC0gcmVwbGFjZXMgdGhlIGN1cnJlbnQgaGlzdG9yeSBlbnRyeSBpbiB0aGUgYnJvd3NlciBoaXN0b3J5XG4gKlxuICogTmF2aWdhdGUgaGFzIG11bHRpcGxlIGNhY2hlIGhldXJpc3RpY3M6XG4gKiAtIHBhZ2Ugd2FzIHByZWZldGNoZWRcbiAqICAtIEFwcGx5IHJvdXRlciBzdGF0ZSB0cmVlIGZyb20gcHJlZmV0Y2hcbiAqICAtIEFwcGx5IEZsaWdodCBkYXRhIGZyb20gcHJlZmV0Y2ggdG8gdGhlIGNhY2hlXG4gKiAgLSBJZiBGbGlnaHQgZGF0YSBpcyBhIHN0cmluZywgaXQncyBhIHJlZGlyZWN0IGFuZCB0aGUgc3RhdGUgaXMgdXBkYXRlZCB0byB0cmlnZ2VyIGEgcmVkaXJlY3RcbiAqICAtIENoZWNrIGlmIGhhcmQgbmF2aWdhdGlvbiBpcyBuZWVkZWRcbiAqICAgIC0gSGFyZCBuYXZpZ2F0aW9uIGhhcHBlbnMgd2hlbiBhIGR5bmFtaWMgcGFyYW1ldGVyIGJlbG93IHRoZSBjb21tb24gbGF5b3V0IGNoYW5nZWRcbiAqICAgIC0gV2hlbiBoYXJkIG5hdmlnYXRpb24gaXMgbmVlZGVkIHRoZSBjYWNoZSBpcyBpbnZhbGlkYXRlZCBiZWxvdyB0aGUgZmxpZ2h0U2VnbWVudFBhdGhcbiAqICAgIC0gVGhlIG1pc3NpbmcgY2FjaGUgbm9kZXMgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBmZXRjaGVkIGluIGxheW91dC1yb3V0ZXIgYW5kIHRyaWdnZXIgdGhlIFNFUlZFUl9QQVRDSCBhY3Rpb25cbiAqICAtIElmIGhhcmQgbmF2aWdhdGlvbiBpcyBub3QgbmVlZGVkXG4gKiAgICAtIFRoZSBjYWNoZSBpcyByZXVzZWRcbiAqICAgIC0gSWYgYW55IGNhY2hlIG5vZGVzIGFyZSBtaXNzaW5nIHRoZXknbGwgYmUgZmV0Y2hlZCBpbiBsYXlvdXQtcm91dGVyIGFuZCB0cmlnZ2VyIHRoZSBTRVJWRVJfUEFUQ0ggYWN0aW9uXG4gKiAtIHBhZ2Ugd2FzIG5vdCBwcmVmZXRjaGVkXG4gKiAgLSBUaGUgbmF2aWdhdGUgd2FzIGNhbGxlZCBmcm9tIGBuZXh0L3JvdXRlcmAgKGByb3V0ZXIucHVzaCgpYCAvIGByb3V0ZXIucmVwbGFjZSgpYCkgLyBgbmV4dC9saW5rYCB3aXRob3V0IHByZWZldGNoZWQgZGF0YSBhdmFpbGFibGUgKGUuZy4gdGhlIHByZWZldGNoIGRpZG4ndCBjb21lIGJhY2sgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSBjbGlja2luZyB0aGUgbGluaylcbiAqICAgIC0gRmxpZ2h0IGRhdGEgaXMgZmV0Y2hlZCBpbiB0aGUgcmVkdWNlciAoc3VzcGVuZHMgdGhlIHJlZHVjZXIpXG4gKiAgICAtIFJvdXRlciBzdGF0ZSB0cmVlIGlzIGNyZWF0ZWQgYmFzZWQgb24gRmxpZ2h0IGRhdGFcbiAqICAgIC0gQ2FjaGUgaXMgZmlsbGVkIGJhc2VkIG9uIHRoZSBGbGlnaHQgZGF0YVxuICpcbiAqIEFib3ZlIHN0ZXBzIGV4cGxhaW4gMyBjYXNlczpcbiAqIC0gYHNvZnRgIC0gUmV1c2VzIHRoZSBleGlzdGluZyBjYWNoZSBhbmQgZmV0Y2hlcyBtaXNzaW5nIG5vZGVzIGluIGxheW91dC1yb3V0ZXIuXG4gKiAtIGBoYXJkYCAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgd2hlcmUgY2FjaGUgbm9kZXMgYXJlIHJlbW92ZWQgYmVsb3cgdGhlIGNvbW1vbiBsYXlvdXQgYW5kIGZldGNoZXMgbWlzc2luZyBub2RlcyBpbiBsYXlvdXQtcm91dGVyLlxuICogLSBgb3B0aW1pc3RpY2AgKGV4cGxpY2l0IG5vIHByZWZldGNoKSAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgYW5kIGtpY2tzIG9mZiB0aGUgZGF0YSBmZXRjaCBpbiB0aGUgcmVkdWNlci4gVGhlIGRhdGEgZmV0Y2ggaXMgYXdhaXRlZCBpbiB0aGUgbGF5b3V0LXJvdXRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZUFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fTkFWSUdBVEVcbiAgdXJsOiBVUkxcbiAgaXNFeHRlcm5hbFVybDogYm9vbGVhblxuICBsb2NhdGlvblNlYXJjaDogTG9jYXRpb25bJ3NlYXJjaCddXG4gIG5hdmlnYXRlVHlwZTogJ3B1c2gnIHwgJ3JlcGxhY2UnXG4gIHNob3VsZFNjcm9sbDogYm9vbGVhblxuICBhbGxvd0FsaWFzaW5nOiBib29sZWFuXG59XG5cbi8qKlxuICogUmVzdG9yZSBhcHBsaWVzIHRoZSBwcm92aWRlZCByb3V0ZXIgc3RhdGUuXG4gKiAtIFVzZWQgZm9yIGBwb3BzdGF0ZWAgKGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uKSB3aGVyZSBhIGtub3duIHJvdXRlciBzdGF0ZSBoYXMgdG8gYmUgYXBwbGllZC5cbiAqIC0gQWxzbyB1c2VkIHdoZW4gc3luY2luZyB0aGUgcm91dGVyIHN0YXRlIHdpdGggYHB1c2hTdGF0ZWAvYHJlcGxhY2VTdGF0ZWAgY2FsbHMuXG4gKiAtIFJvdXRlciBzdGF0ZSBpcyBhcHBsaWVkIGFzLWlzIGZyb20gdGhlIGhpc3Rvcnkgc3RhdGUsIGlmIGF2YWlsYWJsZS5cbiAqIC0gSWYgdGhlIGhpc3Rvcnkgc3RhdGUgZG9lcyBub3QgY29udGFpbiB0aGUgcm91dGVyIHN0YXRlLCB0aGUgZXhpc3Rpbmcgcm91dGVyIHN0YXRlIGlzIHVzZWQuXG4gKiAtIElmIGFueSBjYWNoZSBub2RlIGlzIG1pc3NpbmcgaXQgd2lsbCBiZSBmZXRjaGVkIGluIGxheW91dC1yb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyBhbmQgdGhlIHNlcnZlci1wYXRjaCBjYXNlLlxuICogLSBJZiBleGlzdGluZyBjYWNoZSBub2RlcyBtYXRjaCB0aGVzZSBhcmUgdXNlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXN0b3JlQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9SRVNUT1JFXG4gIHVybDogVVJMXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlIHwgdW5kZWZpbmVkXG59XG5cbi8qKlxuICogU2VydmVyLXBhdGNoIGFwcGxpZXMgdGhlIHByb3ZpZGVkIEZsaWdodCBkYXRhIHRvIHRoZSBjYWNoZSBhbmQgcm91dGVyIHRyZWUuXG4gKiAtIE9ubHkgdHJpZ2dlcmVkIGluIGxheW91dC1yb3V0ZXIuXG4gKiAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgYW5kIHJvdXRlciBzdGF0ZSB3aXRoIHRoZSBGbGlnaHQgZGF0YSBhcHBsaWVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlclBhdGNoQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9TRVJWRVJfUEFUQ0hcbiAgbmF2aWdhdGVkQXQ6IG51bWJlclxuICBzZXJ2ZXJSZXNwb25zZTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuICBwcmV2aW91c1RyZWU6IEZsaWdodFJvdXRlclN0YXRlXG59XG5cbi8qKlxuICogUHJlZmV0Y2hLaW5kIGRlZmluZXMgdGhlIHR5cGUgb2YgcHJlZmV0Y2hpbmcgdGhhdCBzaG91bGQgYmUgZG9uZS5cbiAqIC0gYGF1dG9gIC0gaWYgdGhlIHBhZ2UgaXMgZHluYW1pYywgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBwYXJ0aWFsbHksIGlmIHN0YXRpYyBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgZnVsbGAgLSBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgdGVtcG9yYXJ5YCAtIGEgdGVtcG9yYXJ5IHByZWZldGNoIGVudHJ5IGlzIGFkZGVkIHRvIHRoZSBjYWNoZSwgdGhpcyBpcyB1c2VkIHdoZW4gcHJlZmV0Y2g9e2ZhbHNlfSBpcyB1c2VkIGluIG5leHQvbGluayBvciB3aGVuIHlvdSBwdXNoIGEgcm91dGUgcHJvZ3JhbW1hdGljYWxseS5cbiAqL1xuXG5leHBvcnQgZW51bSBQcmVmZXRjaEtpbmQge1xuICBBVVRPID0gJ2F1dG8nLFxuICBGVUxMID0gJ2Z1bGwnLFxuICBURU1QT1JBUlkgPSAndGVtcG9yYXJ5Jyxcbn1cblxuLyoqXG4gKiBQcmVmZXRjaCBhZGRzIHRoZSBwcm92aWRlZCBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBDcmVhdGVzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBiYXNlZCBvbiB0aGUgcGF0Y2ggaW4gRmxpZ2h0RGF0YVxuICogLSBBZGRzIHRoZSBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBJbiBBQ1RJT05fTkFWSUdBVEUgdGhlIHByZWZldGNoIGNhY2hlIGlzIGNoZWNrZWQgYW5kIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBhbmQgRmxpZ2h0RGF0YSBhcmUgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVmZXRjaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fUFJFRkVUQ0hcbiAgdXJsOiBVUkxcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaFJlZiB7XG4gIC8qKlxuICAgKiBJZiB0aGUgYXBwLXJvdXRlciBzaG91bGQgcHVzaCBhIG5ldyBoaXN0b3J5IGVudHJ5IGluIGFwcC1yb3V0ZXIncyB1c2VFZmZlY3QoKVxuICAgKi9cbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW5cbiAgLyoqXG4gICAqIE11bHRpLXBhZ2UgbmF2aWdhdGlvbiB0aHJvdWdoIGxvY2F0aW9uLmhyZWYuXG4gICAqL1xuICBtcGFOYXZpZ2F0aW9uOiBib29sZWFuXG4gIC8qKlxuICAgKiBTa2lwIGFwcGx5aW5nIHRoZSByb3V0ZXIgc3RhdGUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeSBzdGF0ZS5cbiAgICovXG4gIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZvY3VzQW5kU2Nyb2xsUmVmID0ge1xuICAvKipcbiAgICogSWYgZm9jdXMgYW5kIHNjcm9sbCBzaG91bGQgYmUgc2V0IGluIHRoZSBsYXlvdXQtcm91dGVyJ3MgdXNlRWZmZWN0KClcbiAgICovXG4gIGFwcGx5OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB0by5cbiAgICovXG4gIGhhc2hGcmFnbWVudDogc3RyaW5nIHwgbnVsbFxuICAvKipcbiAgICogVGhlIHBhdGhzIG9mIHRoZSBzZWdtZW50cyB0aGF0IHNob3VsZCBiZSBmb2N1c2VkLlxuICAgKi9cbiAgc2VnbWVudFBhdGhzOiBGbGlnaHRTZWdtZW50UGF0aFtdXG4gIC8qKlxuICAgKiBJZiBvbmx5IHRoZSBVUkxzIGhhc2ggZnJhZ21lbnQgY2hhbmdlZFxuICAgKi9cbiAgb25seUhhc2hDaGFuZ2U6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5ID0ge1xuICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbiAgZGF0YTogUHJvbWlzZTxGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0PlxuICBraW5kOiBQcmVmZXRjaEtpbmRcbiAgcHJlZmV0Y2hUaW1lOiBudW1iZXJcbiAgc3RhbGVUaW1lOiBudW1iZXJcbiAgbGFzdFVzZWRUaW1lOiBudW1iZXIgfCBudWxsXG4gIGtleTogc3RyaW5nXG4gIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzXG4gIHVybDogVVJMXG59XG5cbmV4cG9ydCBlbnVtIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyB7XG4gIGZyZXNoID0gJ2ZyZXNoJyxcbiAgcmV1c2FibGUgPSAncmV1c2FibGUnLFxuICBleHBpcmVkID0gJ2V4cGlyZWQnLFxuICBzdGFsZSA9ICdzdGFsZScsXG59XG5cbi8qKlxuICogSGFuZGxlcyBrZWVwaW5nIHRoZSBzdGF0ZSBvZiBhcHAtcm91dGVyLlxuICovXG5leHBvcnQgdHlwZSBBcHBSb3V0ZXJTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFRoZSByb3V0ZXIgc3RhdGUsIHRoaXMgaXMgd3JpdHRlbiBpbnRvIHRoZSBoaXN0b3J5IHN0YXRlIGluIGFwcC1yb3V0ZXIgdXNpbmcgcmVwbGFjZVN0YXRlL3B1c2hTdGF0ZS5cbiAgICogLSBIYXMgdG8gYmUgc2VyaWFsaXphYmxlIGFzIGl0IGlzIHdyaXR0ZW4gaW50byB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICogLSBIb2xkcyB3aGljaCBzZWdtZW50cyBhbmQgcGFyYWxsZWwgcm91dGVzIGFyZSBzaG93biBvbiB0aGUgc2NyZWVuLlxuICAgKi9cbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBob2xkcyBSZWFjdCBub2RlcyBmb3IgZXZlcnkgc2VnbWVudCB0aGF0IGlzIHNob3duIG9uIHNjcmVlbiBhcyB3ZWxsIGFzIHByZXZpb3VzbHkgc2hvd24gc2VnbWVudHMuXG4gICAqIEl0IGFsc28gaG9sZHMgaW4tcHJvZ3Jlc3MgZGF0YSByZXF1ZXN0cy5cbiAgICogUHJlZmV0Y2hlZCBkYXRhIGlzIHN0b3JlZCBzZXBhcmF0ZWx5IGluIGBwcmVmZXRjaENhY2hlYCwgdGhhdCBpcyBhcHBsaWVkIGR1cmluZyBBQ1RJT05fTkFWSUdBVEUuXG4gICAqL1xuICBjYWNoZTogQ2FjaGVOb2RlXG4gIC8qKlxuICAgKiBDYWNoZSB0aGF0IGhvbGRzIHByZWZldGNoZWQgRmxpZ2h0IHJlc3BvbnNlcyBrZXllZCBieSB1cmwuXG4gICAqL1xuICBwcmVmZXRjaENhY2hlOiBNYXA8c3RyaW5nLCBQcmVmZXRjaENhY2hlRW50cnk+XG4gIC8qKlxuICAgKiBEZWNpZGVzIGlmIHRoZSB1cGRhdGUgc2hvdWxkIGNyZWF0ZSBhIG5ldyBoaXN0b3J5IGVudHJ5IGFuZCBpZiB0aGUgbmF2aWdhdGlvbiBoYXMgdG8gdHJpZ2dlciBhIGJyb3dzZXIgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1c2hSZWY6IFB1c2hSZWZcbiAgLyoqXG4gICAqIERlY2lkZXMgaWYgdGhlIHVwZGF0ZSBzaG91bGQgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgKi9cbiAgZm9jdXNBbmRTY3JvbGxSZWY6IEZvY3VzQW5kU2Nyb2xsUmVmXG4gIC8qKlxuICAgKiBUaGUgY2Fub25pY2FsIHVybCB0aGF0IGlzIHB1c2hlZC9yZXBsYWNlZC5cbiAgICogLSBUaGlzIGlzIHRoZSB1cmwgeW91IHNlZSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNhbm9uaWNhbFVybDogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyBcInVybFwiIHJlcHJlc2VudGluZyB0aGUgVUkgc3RhdGUsIHdoaWNoIGlzIHVzZWQgZm9yIGludGVyY2VwdGluZyByb3V0ZXMuXG4gICAqL1xuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlID0gUmVhZG9ubHk8QXBwUm91dGVyU3RhdGU+XG5leHBvcnQgdHlwZSBSZWR1Y2VyU3RhdGUgPSBQcm9taXNlPEFwcFJvdXRlclN0YXRlPiB8IEFwcFJvdXRlclN0YXRlXG5leHBvcnQgdHlwZSBSZWR1Y2VyQWN0aW9ucyA9IFJlYWRvbmx5PFxuICB8IFJlZnJlc2hBY3Rpb25cbiAgfCBOYXZpZ2F0ZUFjdGlvblxuICB8IFJlc3RvcmVBY3Rpb25cbiAgfCBTZXJ2ZXJQYXRjaEFjdGlvblxuICB8IFByZWZldGNoQWN0aW9uXG4gIHwgSG1yUmVmcmVzaEFjdGlvblxuICB8IFNlcnZlckFjdGlvbkFjdGlvblxuPlxuIl0sIm5hbWVzIjpbIkFDVElPTl9ITVJfUkVGUkVTSCIsIkFDVElPTl9OQVZJR0FURSIsIkFDVElPTl9QUkVGRVRDSCIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJQcmVmZXRjaEtpbmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"reducer\", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\");\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\");\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _hmrrefreshreducer = __webpack_require__(/*! ./reducers/hmr-refresh-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\");\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ \"(ssr)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_HMR_REFRESH:\n            {\n                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw Object.defineProperty(new Error('Unknown action'), \"__NEXT_ERROR_CODE\", {\n                value: \"E295\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  true ? serverReducer : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7MkNBaUVhQTs7O2VBQUFBOzs7Z0RBekROOzZDQU15QjtnREFDRzs0Q0FDSjs0Q0FDQTs2Q0FDQzsrQ0FDRTtpREFDRTtBQUVwQzs7Q0FFQyxHQUNELFNBQVNDLGNBQ1BDLEtBQTJCLEVBQzNCQyxNQUFzQjtJQUV0QixPQUFRQSxPQUFPQyxJQUFJO1FBQ2pCLEtBQUtDLG9CQUFBQSxlQUFlO1lBQUU7Z0JBQ3BCLE9BQU9DLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFBQSxFQUFnQkosT0FBT0M7WUFDaEM7UUFDQSxLQUFLSSxvQkFBQUEsbUJBQW1CO1lBQUU7Z0JBQ3hCLE9BQU9DLENBQUFBLEdBQUFBLG9CQUFBQSxrQkFBQUEsRUFBbUJOLE9BQU9DO1lBQ25DO1FBQ0EsS0FBS00sb0JBQUFBLGNBQWM7WUFBRTtnQkFDbkIsT0FBT0MsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQUFBLEVBQWVSLE9BQU9DO1lBQy9CO1FBQ0EsS0FBS1Esb0JBQUFBLGNBQWM7WUFBRTtnQkFDbkIsT0FBT0MsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQUFBLEVBQWVWLE9BQU9DO1lBQy9CO1FBQ0EsS0FBS1Usb0JBQUFBLGtCQUFrQjtZQUFFO2dCQUN2QixPQUFPQyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCWixPQUFPQztZQUNsQztRQUNBLEtBQUtZLG9CQUFBQSxlQUFlO1lBQUU7Z0JBQ3BCLE9BQU9DLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFBQSxFQUFnQmQsT0FBT0M7WUFDaEM7UUFDQSxLQUFLYyxvQkFBQUEsb0JBQW9CO1lBQUU7Z0JBQ3pCLE9BQU9DLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFBb0JoQixPQUFPQztZQUNwQztRQUNBLCtEQUErRDtRQUMvRDtZQUNFLE1BQU0scUJBQTJCLENBQTNCLElBQUlnQixNQUFNLG1CQUFWO3VCQUFBOzRCQUFBOzhCQUFBO1lBQTBCO0lBQ3BDO0FBQ0Y7QUFFQSxTQUFTQyxjQUNQbEIsS0FBMkIsRUFDM0JtQixPQUF1QjtJQUV2QixPQUFPbkI7QUFDVDtBQUdPLE1BQU1GLFVBQ1gsS0FBNkIsR0FBR29CLGdCQUFnQm5CLENBQWFBIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyb3V0ZXItcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBQ1RJT05fTkFWSUdBVEUsXG4gIEFDVElPTl9TRVJWRVJfUEFUQ0gsXG4gIEFDVElPTl9SRVNUT1JFLFxuICBBQ1RJT05fUkVGUkVTSCxcbiAgQUNUSU9OX1BSRUZFVENILFxuICBBQ1RJT05fSE1SX1JFRlJFU0gsXG4gIEFDVElPTl9TRVJWRVJfQUNUSU9OLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBSZWR1Y2VyQWN0aW9ucyxcbiAgUmVkdWNlclN0YXRlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IG5hdmlnYXRlUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IHNlcnZlclBhdGNoUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXInXG5pbXBvcnQgeyByZXN0b3JlUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgcmVmcmVzaFJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlcidcbmltcG9ydCB7IHByZWZldGNoUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlcidcbmltcG9ydCB7IGhtclJlZnJlc2hSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9obXItcmVmcmVzaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgc2VydmVyQWN0aW9uUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvc2VydmVyLWFjdGlvbi1yZWR1Y2VyJ1xuXG4vKipcbiAqIFJlZHVjZXIgdGhhdCBoYW5kbGVzIHRoZSBhcHAtcm91dGVyIHN0YXRlIHVwZGF0ZXMuXG4gKi9cbmZ1bmN0aW9uIGNsaWVudFJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBSZWR1Y2VyQWN0aW9uc1xuKTogUmVkdWNlclN0YXRlIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgQUNUSU9OX05BVklHQVRFOiB7XG4gICAgICByZXR1cm4gbmF2aWdhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX1NFUlZFUl9QQVRDSDoge1xuICAgICAgcmV0dXJuIHNlcnZlclBhdGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9SRVNUT1JFOiB7XG4gICAgICByZXR1cm4gcmVzdG9yZVJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fUkVGUkVTSDoge1xuICAgICAgcmV0dXJuIHJlZnJlc2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX0hNUl9SRUZSRVNIOiB7XG4gICAgICByZXR1cm4gaG1yUmVmcmVzaFJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fUFJFRkVUQ0g6IHtcbiAgICAgIHJldHVybiBwcmVmZXRjaFJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fU0VSVkVSX0FDVElPTjoge1xuICAgICAgcmV0dXJuIHNlcnZlckFjdGlvblJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBiZSBoaXQgYXMgZGlzcGF0Y2ggaXMgc3Ryb25nbHkgdHlwZWQuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhY3Rpb24nKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlcnZlclJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgX2FjdGlvbjogUmVkdWNlckFjdGlvbnNcbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHJldHVybiBzdGF0ZVxufVxuXG4vLyB3ZSBkb24ndCBydW4gdGhlIGNsaWVudCByZWR1Y2VyIG9uIHRoZSBzZXJ2ZXIsIHNvIHdlIHVzZSBhIG5vb3AgZnVuY3Rpb24gZm9yIGJldHRlciB0cmVlIHNoYWtpbmdcbmV4cG9ydCBjb25zdCByZWR1Y2VyID1cbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBzZXJ2ZXJSZWR1Y2VyIDogY2xpZW50UmVkdWNlclxuIl0sIm5hbWVzIjpbInJlZHVjZXIiLCJjbGllbnRSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX05BVklHQVRFIiwibmF2aWdhdGVSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInNlcnZlclBhdGNoUmVkdWNlciIsIkFDVElPTl9SRVNUT1JFIiwicmVzdG9yZVJlZHVjZXIiLCJBQ1RJT05fUkVGUkVTSCIsInJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX0hNUl9SRUZSRVNIIiwiaG1yUmVmcmVzaFJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJwcmVmZXRjaFJlZHVjZXIiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsInNlcnZlckFjdGlvblJlZHVjZXIiLCJFcnJvciIsInNlcnZlclJlZHVjZXIiLCJfYWN0aW9uIiwid2luZG93Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"setCacheBustingSearchParam\", ({\n    enumerable: true,\n    get: function() {\n        return setCacheBustingSearchParam;\n    }\n}));\nconst _hash = __webpack_require__(/*! ../../../shared/lib/hash */ \"(ssr)/./node_modules/next/dist/shared/lib/hash.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(ssr)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _hash.hexHash)([\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER],\n        headers[_approuterheaders.NEXT_URL]\n    ].join(','));\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    const pairs = rawQuery.split('&').filter(Boolean);\n    pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + \"=\" + uniqueCacheKey);\n    url.search = pairs.length ? \"?\" + pairs.join('&') : '';\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-cache-busting-search-param.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3NldC1jYWNoZS1idXN0aW5nLXNlYXJjaC1wYXJhbS5qcyIsIm1hcHBpbmdzIjoiOzs7OzhEQTJCYUE7OztlQUFBQTs7O2tDQTFCVzs4Q0FPakI7QUFtQkEsTUFBTUEsNkJBQTZCLENBQ3hDQyxLQUNBQztJQUVBLE1BQU1DLGlCQUFpQkMsQ0FBQUEsR0FBQUEsTUFBQUEsT0FBQUEsRUFDckI7UUFDRUYsT0FBTyxDQUFDRyxrQkFBQUEsMkJBQTJCLENBQUMsSUFBSTtRQUN4Q0gsT0FBTyxDQUFDSSxrQkFBQUEsbUNBQW1DLENBQUMsSUFBSTtRQUNoREosT0FBTyxDQUFDSyxrQkFBQUEsNkJBQTZCLENBQUM7UUFDdENMLE9BQU8sQ0FBQ00sa0JBQUFBLFFBQVEsQ0FBQztLQUNsQixDQUFDQyxJQUFJLENBQUM7SUFHVDs7Ozs7Ozs7OztHQVVDLEdBQ0QsTUFBTUMsaUJBQWlCVCxJQUFJVSxNQUFNO0lBQ2pDLE1BQU1DLFdBQVdGLGVBQWVHLFVBQVUsQ0FBQyxPQUN2Q0gsZUFBZUksS0FBSyxDQUFDLEtBQ3JCSjtJQUNKLE1BQU1LLFFBQVFILFNBQVNJLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDO0lBQ3pDSCxNQUFNSSxJQUFJLENBQUlDLGtCQUFBQSxvQkFBb0IsR0FBQyxNQUFHakI7SUFDdENGLElBQUlVLE1BQU0sR0FBR0ksTUFBTU0sTUFBTSxHQUFJLE1BQUdOLE1BQU1OLElBQUksQ0FBQyxPQUFTO0FBQ3REIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxzZXQtY2FjaGUtYnVzdGluZy1zZWFyY2gtcGFyYW0udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgeyBoZXhIYXNoIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9oYXNoJ1xuaW1wb3J0IHtcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBSZXF1ZXN0SGVhZGVycyB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG4vKipcbiAqIE11dGF0ZXMgdGhlIHByb3ZpZGVkIFVSTCBieSBhZGRpbmcgYSBjYWNoZS1idXN0aW5nIHNlYXJjaCBwYXJhbWV0ZXIgZm9yIENETnMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBjdXN0b20gaGVhZGVycy4gVGhpcyBoZWxwcyBhdm9pZCBjYWNoaW5nIGNvbmZsaWN0cyBieSBtYWtpbmcgZWFjaCByZXF1ZXN0IHVuaXF1ZS5cbiAqXG4gKiBSYXRoZXIgdGhhbiByZWx5aW5nIG9uIHRoZSBWYXJ5IGhlYWRlciB3aGljaCBzb21lIENETnMgaWdub3JlLCB3ZSBhcHBlbmQgYSBzZWFyY2ggcGFyYW1cbiAqIHRvIGNyZWF0ZSBhIHVuaXF1ZSBVUkwgdGhhdCBmb3JjZXMgYSBmcmVzaCByZXF1ZXN0LlxuICpcbiAqIEV4YW1wbGU6XG4gKiBVUkwgYmVmb3JlOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MVxuICogVVJMIGFmdGVyOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjPWFiYzEyM1xuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgaW5wdXQgVVJMIGRpcmVjdGx5IGFuZCBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXG4gKlxuICogVE9ETzogU2luY2Ugd2UgbmVlZCB0byB1c2UgYSBzZWFyY2ggcGFyYW0gYW55d2F5LCB3ZSBjb3VsZCBzaW1wbGlmeSBieSByZW1vdmluZyB0aGUgY3VzdG9tXG4gKiBoZWFkZXJzIGFwcHJvYWNoIGVudGlyZWx5IGFuZCBqdXN0IHVzZSBzZWFyY2ggcGFyYW1zLlxuICovXG5leHBvcnQgY29uc3Qgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gPSAoXG4gIHVybDogVVJMLFxuICBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVyc1xuKTogdm9pZCA9PiB7XG4gIGNvbnN0IHVuaXF1ZUNhY2hlS2V5ID0gaGV4SGFzaChcbiAgICBbXG4gICAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gfHwgJzAnLFxuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUl0gfHwgJzAnLFxuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl0sXG4gICAgICBoZWFkZXJzW05FWFRfVVJMXSxcbiAgICBdLmpvaW4oJywnKVxuICApXG5cbiAgLyoqXG4gICAqIE5vdGUgdGhhdCB3ZSBpbnRlbnRpb25hbGx5IGRvIG5vdCB1c2UgYHVybC5zZWFyY2hQYXJhbXMuc2V0YCBoZXJlOlxuICAgKlxuICAgKiBjb25zdCB1cmwgPSBuZXcgVVJMKCdodHRwczovL2V4YW1wbGUuY29tL3NlYXJjaD9xPWN1c3RvbSUyMHNwYWNpbmcnKTtcbiAgICogdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19yc2MnLCAnYWJjMTIzJyk7XG4gICAqIGNvbnNvbGUubG9nKHVybC50b1N0cmluZygpKTsgLy8gT3V0cHV0czogaHR0cHM6Ly9leGFtcGxlLmNvbS9zZWFyY2g/cT1jdXN0b20rc3BhY2luZyZfcnNjPWFiYzEyM1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXiA8LS0tIHRoaXMgaXMgY2F1c2luZyBjb25mdXNpb25cbiAgICogVGhpcyBpcyBpbiBmYWN0IGludGVuZGVkIGJhc2VkIG9uIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLXVybHNlYXJjaHBhcmFtcywgYnV0XG4gICAqIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlICUyMCBhcyAlMjAgaWYgdGhhdCdzIHdoYXQgdGhlIHVzZXIgcGFzc2VkIGluLCBoZW5jZSB0aGUgY3VzdG9tXG4gICAqIGxvZ2ljIGJlbG93LlxuICAgKi9cbiAgY29uc3QgZXhpc3RpbmdTZWFyY2ggPSB1cmwuc2VhcmNoXG4gIGNvbnN0IHJhd1F1ZXJ5ID0gZXhpc3RpbmdTZWFyY2guc3RhcnRzV2l0aCgnPycpXG4gICAgPyBleGlzdGluZ1NlYXJjaC5zbGljZSgxKVxuICAgIDogZXhpc3RpbmdTZWFyY2hcbiAgY29uc3QgcGFpcnMgPSByYXdRdWVyeS5zcGxpdCgnJicpLmZpbHRlcihCb29sZWFuKVxuICBwYWlycy5wdXNoKGAke05FWFRfUlNDX1VOSU9OX1FVRVJZfT0ke3VuaXF1ZUNhY2hlS2V5fWApXG4gIHVybC5zZWFyY2ggPSBwYWlycy5sZW5ndGggPyBgPyR7cGFpcnMuam9pbignJicpfWAgOiAnJ1xufVxuIl0sIm5hbWVzIjpbInNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwidXJsIiwiaGVhZGVycyIsInVuaXF1ZUNhY2hlS2V5IiwiaGV4SGFzaCIsIk5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIiLCJORVhUX1VSTCIsImpvaW4iLCJleGlzdGluZ1NlYXJjaCIsInNlYXJjaCIsInJhd1F1ZXJ5Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFpcnMiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJwdXNoIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"shouldHardNavigate\", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(ssr)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(ssr)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Nob3VsZC1oYXJkLW5hdmlnYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7c0RBU2dCQTs7O2VBQUFBOzs7K0NBSnlCOzJDQUNaO0FBR3RCLFNBQVNBLG1CQUNkQyxpQkFBaUMsRUFDakNDLGlCQUFvQztJQUVwQyxNQUFNLENBQUNDLFNBQVNDLGVBQWUsR0FBR0Y7SUFDbEMsMkNBQTJDO0lBQzNDLE1BQU0sQ0FBQ0csZ0JBQWdCQyxpQkFBaUIsR0FBR0w7SUFLM0MseURBQXlEO0lBQ3pELElBQUksQ0FBQ00sQ0FBQUEsR0FBQUEsZUFBQUEsWUFBQUEsRUFBYUYsZ0JBQWdCRixVQUFVO1FBQzFDLGtHQUFrRztRQUNsRyxJQUFJSyxNQUFNQyxPQUFPLENBQUNKLGlCQUFpQjtZQUNqQyxPQUFPO1FBQ1Q7UUFFQSxzRUFBc0U7UUFDdEUsT0FBTztJQUNUO0lBQ0EsTUFBTUssY0FBY1Qsa0JBQWtCVSxNQUFNLElBQUk7SUFFaEQsSUFBSUQsYUFBYTtRQUNmLE9BQU87SUFDVDtJQUVBLE9BQU9WLG1CQUNMWSxDQUFBQSxHQUFBQSxtQkFBQUEsd0JBQUFBLEVBQXlCWCxvQkFDekJHLGNBQWMsQ0FBQ0UsaUJBQWlCO0FBRXBDIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxzaG91bGQtaGFyZC1uYXZpZ2F0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHREYXRhUGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi4vbWF0Y2gtc2VnbWVudHMnXG5cbi8vIFRPRE8tQVBQOiBmbGlnaHRTZWdtZW50UGF0aCB3aWxsIGJlIGVtcHR5IGluIGNhc2Ugb2Ygc3RhdGljIHJlc3BvbnNlLCBuZWVkcyB0byBiZSBoYW5kbGVkLlxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodERhdGFQYXRoLFxuICBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IGJvb2xlYW4ge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGVcbiAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICBjb25zdCBbY3VycmVudFNlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gZmxpZ2h0U2VnbWVudFBhdGggYXMgW1xuICAgIFNlZ21lbnQsXG4gICAgc3RyaW5nLFxuICBdXG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCBzZWdtZW50IG1hdGNoZXMgdGhlIGV4aXN0aW5nIHNlZ21lbnQuXG4gIGlmICghbWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyXG5cbiAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gc2hvdWxkSGFyZE5hdmlnYXRlKFxuICAgIGdldE5leHRGbGlnaHRTZWdtZW50UGF0aChmbGlnaHRTZWdtZW50UGF0aCksXG4gICAgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV1cbiAgKVxufVxuIl0sIm5hbWVzIjpbInNob3VsZEhhcmROYXZpZ2F0ZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJtYXRjaFNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJsYXN0U2VnbWVudCIsImxlbmd0aCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/segment-cache.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/segment-cache.js ***!
  \*******************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("/**\n * Entry point to the Segment Cache implementation.\n *\n * All code related to the Segment Cache lives `segment-cache-impl` directory.\n * Callers access it through this indirection.\n *\n * This is to ensure the code is dead code eliminated from the bundle if the\n * flag is disabled.\n *\n * TODO: This is super tedious. Since experimental flags are an essential part\n * of our workflow, we should establish a better pattern for dead code\n * elimination. Ideally it would be done at the bundler level, like how React's\n * build process works. In the React repo, you don't even need to add any extra\n * configuration per experiment â€” if the code is not reachable, it gets stripped\n * from the build automatically by Rollup. Or, shorter term, we could stub out\n * experimental modules at build time by updating the build config, i.e. a more\n * automated version of what I'm doing manually in this file.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NavigationResultTag: function() {\n        return NavigationResultTag;\n    },\n    PrefetchPriority: function() {\n        return PrefetchPriority;\n    },\n    cancelPrefetchTask: function() {\n        return cancelPrefetchTask;\n    },\n    createCacheKey: function() {\n        return createCacheKey;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    navigate: function() {\n        return navigate;\n    },\n    prefetch: function() {\n        return prefetch;\n    },\n    reschedulePrefetchTask: function() {\n        return reschedulePrefetchTask;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    schedulePrefetchTask: function() {\n        return schedulePrefetchTask;\n    }\n});\nconst notEnabled = ()=>{\n    throw Object.defineProperty(new Error('Segment Cache experiment is not enabled. This is a bug in Next.js.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E654\",\n        enumerable: false,\n        configurable: true\n    });\n};\nconst prefetch =  false ? 0 : notEnabled;\nconst navigate =  false ? 0 : notEnabled;\nconst revalidateEntireCache =  false ? 0 : notEnabled;\nconst getCurrentCacheVersion =  false ? 0 : notEnabled;\nconst schedulePrefetchTask =  false ? 0 : notEnabled;\nconst cancelPrefetchTask =  false ? 0 : notEnabled;\nconst reschedulePrefetchTask =  false ? 0 : notEnabled;\nconst createCacheKey =  false ? 0 : notEnabled;\nvar NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag[\"MPA\"] = 0] = \"MPA\";\n    NavigationResultTag[NavigationResultTag[\"Success\"] = 1] = \"Success\";\n    NavigationResultTag[NavigationResultTag[\"NoOp\"] = 2] = \"NoOp\";\n    NavigationResultTag[NavigationResultTag[\"Async\"] = 3] = \"Async\";\n    return NavigationResultTag;\n}({});\nvar PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to any visible link that was hovered/touched at some point. This\n   * is not removed on mouse exit, because a link that was momentarily\n   * hovered is more likely to to be interacted with than one that was not.\n   */ PrefetchPriority[PrefetchPriority[\"Intent\"] = 2] = \"Intent\";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority[\"Default\"] = 1] = \"Default\";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority[\"Background\"] = 0] = \"Background\";\n    return PrefetchPriority;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=segment-cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3NlZ21lbnQtY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDOzs7Ozs7Ozs7Ozs7SUFrRmlCQSxtQkFBbUI7ZUFBbkJBOztJQVVBQyxnQkFBZ0I7ZUFBaEJBOztJQXhDTEMsa0JBQWtCO2VBQWxCQTs7SUFrQkFDLGNBQWM7ZUFBZEE7O0lBcENBQyxzQkFBc0I7ZUFBdEJBOztJQWhCQUMsUUFBUTtlQUFSQTs7SUFQQUMsUUFBUTtlQUFSQTs7SUFrREFDLHNCQUFzQjtlQUF0QkE7O0lBcENBQyxxQkFBcUI7ZUFBckJBOztJQWtCQUMsb0JBQW9CO2VBQXBCQTs7O0FBdENiLE1BQU1DLGFBQWtCO0lBQ3RCLE1BQU0scUJBRUwsQ0FGSyxJQUFJQyxNQUNSLHVFQURJO2VBQUE7b0JBQUE7c0JBQUE7SUFFTjtBQUNGO0FBRU8sTUFBTUwsV0FDWE0sTUFBdUMsR0FDbkMsQ0FFQyxHQUNERjtBQUVDLE1BQU1MLFdBQ1hPLE1BQXVDLEdBQ25DLENBRUMsR0FDREY7QUFFQyxNQUFNRix3QkFDWEksTUFBdUMsR0FDbkMsQ0FJQyxHQUNERjtBQUVDLE1BQU1OLHlCQUNYUSxNQUF1QyxHQUNuQyxDQUlDLEdBQ0RGO0FBRUMsTUFBTUQsdUJBQ1hHLE1BQXVDLEdBQ25DLENBSUMsR0FDREY7QUFFQyxNQUFNUixxQkFDWFUsTUFBdUMsR0FDbkMsQ0FJQyxHQUNERjtBQUVDLE1BQU1ILHlCQUNYSyxNQUF1QyxHQUNuQyxDQUlDLEdBQ0RGO0FBRUMsTUFBTVAsaUJBQ1hTLE1BQXVDLEdBQ25DLENBRUMsR0FDREY7QUFPQyxJQUFXVixzQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsbUJBQUFBOzs7OztXQUFBQTs7QUFVWCxJQUFXQyxtQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsZ0JBQUFBO0lBQ2hCOzs7O0dBSUM7SUFFRDs7R0FFQztJQUVEOzs7R0FHQztXQWRlQSIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxzZWdtZW50LWNhY2hlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW50cnkgcG9pbnQgdG8gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQWxsIGNvZGUgcmVsYXRlZCB0byB0aGUgU2VnbWVudCBDYWNoZSBsaXZlcyBgc2VnbWVudC1jYWNoZS1pbXBsYCBkaXJlY3RvcnkuXG4gKiBDYWxsZXJzIGFjY2VzcyBpdCB0aHJvdWdoIHRoaXMgaW5kaXJlY3Rpb24uXG4gKlxuICogVGhpcyBpcyB0byBlbnN1cmUgdGhlIGNvZGUgaXMgZGVhZCBjb2RlIGVsaW1pbmF0ZWQgZnJvbSB0aGUgYnVuZGxlIGlmIHRoZVxuICogZmxhZyBpcyBkaXNhYmxlZC5cbiAqXG4gKiBUT0RPOiBUaGlzIGlzIHN1cGVyIHRlZGlvdXMuIFNpbmNlIGV4cGVyaW1lbnRhbCBmbGFncyBhcmUgYW4gZXNzZW50aWFsIHBhcnRcbiAqIG9mIG91ciB3b3JrZmxvdywgd2Ugc2hvdWxkIGVzdGFibGlzaCBhIGJldHRlciBwYXR0ZXJuIGZvciBkZWFkIGNvZGVcbiAqIGVsaW1pbmF0aW9uLiBJZGVhbGx5IGl0IHdvdWxkIGJlIGRvbmUgYXQgdGhlIGJ1bmRsZXIgbGV2ZWwsIGxpa2UgaG93IFJlYWN0J3NcbiAqIGJ1aWxkIHByb2Nlc3Mgd29ya3MuIEluIHRoZSBSZWFjdCByZXBvLCB5b3UgZG9uJ3QgZXZlbiBuZWVkIHRvIGFkZCBhbnkgZXh0cmFcbiAqIGNvbmZpZ3VyYXRpb24gcGVyIGV4cGVyaW1lbnQg4oCUIGlmIHRoZSBjb2RlIGlzIG5vdCByZWFjaGFibGUsIGl0IGdldHMgc3RyaXBwZWRcbiAqIGZyb20gdGhlIGJ1aWxkIGF1dG9tYXRpY2FsbHkgYnkgUm9sbHVwLiBPciwgc2hvcnRlciB0ZXJtLCB3ZSBjb3VsZCBzdHViIG91dFxuICogZXhwZXJpbWVudGFsIG1vZHVsZXMgYXQgYnVpbGQgdGltZSBieSB1cGRhdGluZyB0aGUgYnVpbGQgY29uZmlnLCBpLmUuIGEgbW9yZVxuICogYXV0b21hdGVkIHZlcnNpb24gb2Ygd2hhdCBJJ20gZG9pbmcgbWFudWFsbHkgaW4gdGhpcyBmaWxlLlxuICovXG5cbmV4cG9ydCB0eXBlIHsgTmF2aWdhdGlvblJlc3VsdCB9IGZyb20gJy4vc2VnbWVudC1jYWNoZS1pbXBsL25hdmlnYXRpb24nXG5leHBvcnQgdHlwZSB7IFByZWZldGNoVGFzayB9IGZyb20gJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcidcblxuY29uc3Qgbm90RW5hYmxlZDogYW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1NlZ21lbnQgQ2FjaGUgZXhwZXJpbWVudCBpcyBub3QgZW5hYmxlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzLidcbiAgKVxufVxuXG5leHBvcnQgY29uc3QgcHJlZmV0Y2g6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3ByZWZldGNoJykucHJlZmV0Y2ggPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9wcmVmZXRjaCcpLnByZWZldGNoKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBuYXZpZ2F0ZTogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvbmF2aWdhdGlvbicpLm5hdmlnYXRlID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvbmF2aWdhdGlvbicpLm5hdmlnYXRlKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCByZXZhbGlkYXRlRW50aXJlQ2FjaGU6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJykucmV2YWxpZGF0ZUVudGlyZUNhY2hlID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUnKS5yZXZhbGlkYXRlRW50aXJlQ2FjaGUoXG4gICAgICAgICAgLi4uYXJnc1xuICAgICAgICApXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uOiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpLmdldEN1cnJlbnRDYWNoZVZlcnNpb24gPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpLmdldEN1cnJlbnRDYWNoZVZlcnNpb24oXG4gICAgICAgICAgLi4uYXJnc1xuICAgICAgICApXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBzY2hlZHVsZVByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuc2NoZWR1bGVQcmVmZXRjaFRhc2sgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKS5zY2hlZHVsZVByZWZldGNoVGFzayhcbiAgICAgICAgICAuLi5hcmdzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuZXhwb3J0IGNvbnN0IGNhbmNlbFByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuY2FuY2VsUHJlZmV0Y2hUYXNrID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuY2FuY2VsUHJlZmV0Y2hUYXNrKFxuICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG5leHBvcnQgY29uc3QgcmVzY2hlZHVsZVByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykucmVzY2hlZHVsZVByZWZldGNoVGFzayA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcicpLnJlc2NoZWR1bGVQcmVmZXRjaFRhc2soXG4gICAgICAgICAgLi4uYXJnc1xuICAgICAgICApXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDYWNoZUtleTogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUta2V5JykuY3JlYXRlQ2FjaGVLZXkgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZS1rZXknKS5jcmVhdGVDYWNoZUtleSguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG4vKipcbiAqIEJlbG93IGFyZSBwdWJsaWMgY29uc3RhbnRzLiBUaGV5J3JlIHNtYWxsIGVub3VnaCB0aGF0IHdlIGRvbid0IG5lZWQgdG9cbiAqIERDRSB0aGVtLlxuICovXG5cbmV4cG9ydCBjb25zdCBlbnVtIE5hdmlnYXRpb25SZXN1bHRUYWcge1xuICBNUEEsXG4gIFN1Y2Nlc3MsXG4gIE5vT3AsXG4gIEFzeW5jLFxufVxuXG4vKipcbiAqIFRoZSBwcmlvcml0eSBvZiB0aGUgcHJlZmV0Y2ggdGFzay4gSGlnaGVyIG51bWJlcnMgYXJlIGhpZ2hlciBwcmlvcml0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gUHJlZmV0Y2hQcmlvcml0eSB7XG4gIC8qKlxuICAgKiBBc3NpZ25lZCB0byBhbnkgdmlzaWJsZSBsaW5rIHRoYXQgd2FzIGhvdmVyZWQvdG91Y2hlZCBhdCBzb21lIHBvaW50LiBUaGlzXG4gICAqIGlzIG5vdCByZW1vdmVkIG9uIG1vdXNlIGV4aXQsIGJlY2F1c2UgYSBsaW5rIHRoYXQgd2FzIG1vbWVudGFyaWx5XG4gICAqIGhvdmVyZWQgaXMgbW9yZSBsaWtlbHkgdG8gdG8gYmUgaW50ZXJhY3RlZCB3aXRoIHRoYW4gb25lIHRoYXQgd2FzIG5vdC5cbiAgICovXG4gIEludGVudCA9IDIsXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwcmlvcml0eSBmb3IgcHJlZmV0Y2ggdGFza3MuXG4gICAqL1xuICBEZWZhdWx0ID0gMSxcbiAgLyoqXG4gICAqIEFzc2lnbmVkIHRvIHRhc2tzIHdoZW4gdGhleSBzcGF3biBub24tYmxvY2tpbmcgYmFja2dyb3VuZCB3b3JrLCBsaWtlXG4gICAqIHJldmFsaWRhdGluZyBhIHBhcnRpYWxseSBjYWNoZWQgZW50cnkgdG8gc2VlIGlmIG1vcmUgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBCYWNrZ3JvdW5kID0gMCxcbn1cbiJdLCJuYW1lcyI6WyJOYXZpZ2F0aW9uUmVzdWx0VGFnIiwiUHJlZmV0Y2hQcmlvcml0eSIsImNhbmNlbFByZWZldGNoVGFzayIsImNyZWF0ZUNhY2hlS2V5IiwiZ2V0Q3VycmVudENhY2hlVmVyc2lvbiIsIm5hdmlnYXRlIiwicHJlZmV0Y2giLCJyZXNjaGVkdWxlUHJlZmV0Y2hUYXNrIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwic2NoZWR1bGVQcmVmZXRjaFRhc2siLCJub3RFbmFibGVkIiwiRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwiYXJncyIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/segment-cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/static-generation-bailout.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBRWFBLHFCQUFxQjtlQUFyQkE7O0lBSUdDLHVCQUF1QjtlQUF2QkE7OztBQU5oQixNQUFNQywwQkFBMEI7QUFFekIsTUFBTUYsOEJBQThCRzs7UUFBcEMscUJBQ1dDLElBQUFBLEdBQU9GOztBQUN6QjtBQUVPLFNBQVNELHdCQUNkSSxLQUFjO0lBRWQsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFFLFdBQVVBLEtBQUFBLENBQUksRUFBSTtRQUNyRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtGO0FBQ3hCIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHN0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQgPSAnTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQnXG5cbmV4cG9ydCBjbGFzcyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBjb2RlID0gTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgU3RhdGljR2VuQmFpbG91dEVycm9yIHtcbiAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ29iamVjdCcgfHwgZXJyb3IgPT09IG51bGwgfHwgISgnY29kZScgaW4gZXJyb3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyb3IuY29kZSA9PT0gTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcbn1cbiJdLCJuYW1lcyI6WyJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJpc1N0YXRpY0dlbkJhaWxvdXRFcnJvciIsIk5FWFRfU1RBVElDX0dFTl9CQUlMT1VUIiwiRXJyb3IiLCJjb2RlIiwiZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/static-generation-bailout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/unauthorized.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/unauthorized.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"unauthorized\", ({\n    enumerable: true,\n    get: function() {\n        return unauthorized;\n    }\n}));\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback/http-access-fallback */ \"(ssr)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */ const DIGEST = \"\" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + \";401\";\nfunction unauthorized() {\n    if (true) {\n        throw Object.defineProperty(new Error(\"`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E411\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // eslint-disable-next-line no-throw-literal\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unauthorized.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VuYXV0aG9yaXplZC5qcyIsIm1hcHBpbmdzIjoiOzs7O2dEQXNCZ0JBOzs7ZUFBQUE7OztnREFuQlQ7QUFFUCxnQ0FBZ0M7QUFDaEM7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQsTUFBTUMsU0FBVSxLQUFFQyxvQkFBQUEsOEJBQThCLEdBQUM7QUFFMUMsU0FBU0Y7SUFDZCxJQUFJLElBQWdELEVBQUU7UUFDcEQsTUFBTSxxQkFFTCxDQUZLLElBQUlNLE1BQ1AsZ0hBREc7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsNENBQTRDO0lBQzVDLE1BQU1DLFFBQVEscUJBQWlCLENBQWpCLElBQUlELE1BQU1MLFNBQVY7ZUFBQTtvQkFBQTtzQkFBQTtJQUFnQjtJQUM1Qk0sTUFBa0NDLE1BQU0sR0FBR1A7SUFDN0MsTUFBTU07QUFDUiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFx1bmF1dGhvcml6ZWQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFLFxuICB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuXG4vLyBUT0RPOiBBZGQgYHVuYXV0aG9yaXplZGAgZG9jc1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gcmVuZGVyIHRoZSBbdW5hdXRob3JpemVkLmpzIGZpbGVdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2ZpbGUtY29udmVudGlvbnMvdW5hdXRob3JpemVkKVxuICogd2l0aGluIGEgcm91dGUgc2VnbWVudCBhcyB3ZWxsIGFzIGluamVjdCBhIHRhZy5cbiAqXG4gKiBgdW5hdXRob3JpemVkKClgIGNhbiBiZSB1c2VkIGluXG4gKiBbU2VydmVyIENvbXBvbmVudHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zZXJ2ZXItY29tcG9uZW50cyksXG4gKiBbUm91dGUgSGFuZGxlcnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcm91dGUtaGFuZGxlcnMpLCBhbmRcbiAqIFtTZXJ2ZXIgQWN0aW9uc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9zZXJ2ZXItYWN0aW9ucy1hbmQtbXV0YXRpb25zKS5cbiAqXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdW5hdXRob3JpemVkYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VuYXV0aG9yaXplZClcbiAqL1xuXG5jb25zdCBESUdFU1QgPSBgJHtIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREV9OzQwMWBcblxuZXhwb3J0IGZ1bmN0aW9uIHVuYXV0aG9yaXplZCgpOiBuZXZlciB7XG4gIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9BVVRIX0lOVEVSUlVQVFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgXFxgdW5hdXRob3JpemVkKClcXGAgaXMgZXhwZXJpbWVudGFsIGFuZCBvbmx5IGFsbG93ZWQgdG8gYmUgdXNlZCB3aGVuIFxcYGV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0c1xcYCBpcyBlbmFibGVkLmBcbiAgICApXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihESUdFU1QpIGFzIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yXG4gIDsoZXJyb3IgYXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IpLmRpZ2VzdCA9IERJR0VTVFxuICB0aHJvdyBlcnJvclxufVxuIl0sIm5hbWVzIjpbInVuYXV0aG9yaXplZCIsIkRJR0VTVCIsIkhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfRVhQRVJJTUVOVEFMX0FVVEhfSU5URVJSVVBUUyIsIkVycm9yIiwiZXJyb3IiLCJkaWdlc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/unauthorized.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/unresolved-thenable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/unresolved-thenable.js ***!
  \*************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"unresolvedThenable\", ({\n    enumerable: true,\n    get: function() {\n        return unresolvedThenable;\n    }\n}));\nconst unresolvedThenable = {\n    then: ()=>{}\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unresolved-thenable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VucmVzb2x2ZWQtdGhlbmFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7Ozs7c0RBQ1lBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLHFCQUFxQjtJQUNoQ0MsTUFBTSxLQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcdW5yZXNvbHZlZC10aGVuYWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZSBhIFwiVGhlbmFibGVcIiB0aGF0IGRvZXMgbm90IHJlc29sdmUuIFRoaXMgaXMgdXNlZCB0byBzdXNwZW5kIGluZGVmaW5pdGVseSB3aGVuIGRhdGEgaXMgbm90IGF2YWlsYWJsZSB5ZXQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bnJlc29sdmVkVGhlbmFibGUgPSB7XG4gIHRoZW46ICgpID0+IHt9LFxufSBhcyBQcm9taXNlTGlrZTx2b2lkPlxuIl0sIm5hbWVzIjpbInVucmVzb2x2ZWRUaGVuYWJsZSIsInRoZW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/unresolved-thenable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/unstable-rethrow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/unstable-rethrow.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"unstable_rethrow\", ({\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n}));\nconst unstable_rethrow =  true ? (__webpack_require__(/*! ./unstable-rethrow.server */ \"(ssr)/./node_modules/next/dist/client/components/unstable-rethrow.server.js\").unstable_rethrow) : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unstable-rethrow.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3Vuc3RhYmxlLXJldGhyb3cuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DOzs7O29EQUNZQTs7O2VBQUFBOzs7QUFBTixNQUFNQSxtQkFDWCxLQUE2QixHQUV2QkUsc0pBQ2dCLEdBRWhCQSxDQUNnQiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFx1bnN0YWJsZS1yZXRocm93LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCB0byByZXRocm93IGludGVybmFsIE5leHQuanMgZXJyb3JzIHNvIHRoYXQgdGhleSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgZnJhbWV3b3JrLlxuICogV2hlbiB3cmFwcGluZyBhbiBBUEkgdGhhdCB1c2VzIGVycm9ycyB0byBpbnRlcnJ1cHQgY29udHJvbCBmbG93LCB5b3Ugc2hvdWxkIHVzZSB0aGlzIGZ1bmN0aW9uIGJlZm9yZSB5b3UgZG8gYW55IGVycm9yIGhhbmRsaW5nLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGlzIGEgTmV4dC5qcyBlcnJvciBzbyBpdCBjYW4gYmUgaGFuZGxlZCwgb3RoZXJ3aXNlIGl0IHdpbGwgZG8gbm90aGluZy5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1bnN0YWJsZV9yZXRocm93YF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3Vuc3RhYmxlX3JldGhyb3cpXG4gKi9cbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9yZXRocm93ID1cbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IChcbiAgICAgICAgcmVxdWlyZSgnLi91bnN0YWJsZS1yZXRocm93LnNlcnZlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vdW5zdGFibGUtcmV0aHJvdy5zZXJ2ZXInKVxuICAgICAgKS51bnN0YWJsZV9yZXRocm93XG4gICAgOiAoXG4gICAgICAgIHJlcXVpcmUoJy4vdW5zdGFibGUtcmV0aHJvdy5icm93c2VyJykgYXMgdHlwZW9mIGltcG9ydCgnLi91bnN0YWJsZS1yZXRocm93LmJyb3dzZXInKVxuICAgICAgKS51bnN0YWJsZV9yZXRocm93XG4iXSwibmFtZXMiOlsidW5zdGFibGVfcmV0aHJvdyIsIndpbmRvdyIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/unstable-rethrow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/unstable-rethrow.server.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/unstable-rethrow.server.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"unstable_rethrow\", ({\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n}));\nconst _dynamicrenderingutils = __webpack_require__(/*! ../../server/dynamic-rendering-utils */ \"(ssr)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _ispostpone = __webpack_require__(/*! ../../server/lib/router-utils/is-postpone */ \"(ssr)/./node_modules/next/dist/server/lib/router-utils/is-postpone.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(ssr)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _isnextroutererror = __webpack_require__(/*! ./is-next-router-error */ \"(ssr)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../../server/app-render/dynamic-rendering */ \"(ssr)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _hooksservercontext = __webpack_require__(/*! ./hooks-server-context */ \"(ssr)/./node_modules/next/dist/client/components/hooks-server-context.js\");\nfunction unstable_rethrow(error) {\n    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error) || (0, _hooksservercontext.isDynamicServerError)(error) || (0, _dynamicrendering.isDynamicPostpone)(error) || (0, _ispostpone.isPostpone)(error) || (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error)) {\n        throw error;\n    }\n    if (error instanceof Error && 'cause' in error) {\n        unstable_rethrow(error.cause);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unstable-rethrow.server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3Vuc3RhYmxlLXJldGhyb3cuc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7b0RBT2dCQTs7O2VBQUFBOzs7bURBUCtCO3dDQUNwQjswQ0FDUzsrQ0FDRjs4Q0FDQTtnREFDRztBQUU5QixTQUFTQSxpQkFBaUJDLEtBQWM7SUFDN0MsSUFDRUMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQkQsVUFDbEJFLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFBQSxFQUFvQkYsVUFDcEJHLENBQUFBLEdBQUFBLG9CQUFBQSxvQkFBQUEsRUFBcUJILFVBQ3JCSSxDQUFBQSxHQUFBQSxrQkFBQUEsaUJBQUFBLEVBQWtCSixVQUNsQkssQ0FBQUEsR0FBQUEsWUFBQUEsVUFBQUEsRUFBV0wsVUFDWE0sQ0FBQUEsR0FBQUEsdUJBQUFBLDhCQUFBQSxFQUErQk4sUUFDL0I7UUFDQSxNQUFNQTtJQUNSO0lBRUEsSUFBSUEsaUJBQWlCTyxTQUFTLFdBQVdQLE9BQU87UUFDOUNELGlCQUFpQkMsTUFBTVEsS0FBSztJQUM5QjtBQUNGIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHVuc3RhYmxlLXJldGhyb3cuc2VydmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciB9IGZyb20gJy4uLy4uL3NlcnZlci9keW5hbWljLXJlbmRlcmluZy11dGlscydcbmltcG9ydCB7IGlzUG9zdHBvbmUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvbGliL3JvdXRlci11dGlscy9pcy1wb3N0cG9uZSdcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGlzRHluYW1pY1Bvc3Rwb25lIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5pbXBvcnQgeyBpc0R5bmFtaWNTZXJ2ZXJFcnJvciB9IGZyb20gJy4vaG9va3Mtc2VydmVyLWNvbnRleHQnXG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV9yZXRocm93KGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gIGlmIChcbiAgICBpc05leHRSb3V0ZXJFcnJvcihlcnJvcikgfHxcbiAgICBpc0JhaWxvdXRUb0NTUkVycm9yKGVycm9yKSB8fFxuICAgIGlzRHluYW1pY1NlcnZlckVycm9yKGVycm9yKSB8fFxuICAgIGlzRHluYW1pY1Bvc3Rwb25lKGVycm9yKSB8fFxuICAgIGlzUG9zdHBvbmUoZXJyb3IpIHx8XG4gICAgaXNIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yKGVycm9yKVxuICApIHtcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NhdXNlJyBpbiBlcnJvcikge1xuICAgIHVuc3RhYmxlX3JldGhyb3coZXJyb3IuY2F1c2UpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1bnN0YWJsZV9yZXRocm93IiwiZXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJpc0R5bmFtaWNTZXJ2ZXJFcnJvciIsImlzRHluYW1pY1Bvc3Rwb25lIiwiaXNQb3N0cG9uZSIsImlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciIsIkVycm9yIiwiY2F1c2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/unstable-rethrow.server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/components/use-action-queue.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/use-action-queue.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    dispatchAppRouterAction: function() {\n        return dispatchAppRouterAction;\n    },\n    useActionQueue: function() {\n        return useActionQueue;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(ssr)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nconst _isthenable = __webpack_require__(/*! ../../shared/lib/is-thenable */ \"(ssr)/./node_modules/next/dist/shared/lib/is-thenable.js\");\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch = null;\nfunction dispatchAppRouterAction(action) {\n    if (dispatch === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    dispatch(action);\n}\nfunction useActionQueue(actionQueue) {\n    const [state, setState] = _react.default.useState(actionQueue.state);\n    // Because of a known issue that requires to decode Flight streams inside the\n    // render phase, we have to be a bit clever and assign the dispatch method to\n    // a module-level variable upon initialization. The useState hook in this\n    // module only exists to synchronize state that lives outside of React.\n    // Ideally, what we'd do instead is pass the state as a prop to root.render;\n    // this is conceptually how we're modeling the app router state, despite the\n    // weird implementation details.\n    if (true) {\n        const useSyncDevRenderIndicator = (__webpack_require__(/*! ./react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator */ \"(ssr)/./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator.js\").useSyncDevRenderIndicator);\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const syncDevRenderIndicator = useSyncDevRenderIndicator();\n        dispatch = (action)=>{\n            syncDevRenderIndicator(()=>{\n                actionQueue.dispatch(action, setState);\n            });\n        };\n    } else {}\n    return (0, _isthenable.isThenable)(state) ? (0, _react.use)(state) : state;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-action-queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VzZS1hY3Rpb24tcXVldWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBZWdCQSx1QkFBdUI7ZUFBdkJBOztJQVNBQyxjQUFjO2VBQWRBOzs7OzZFQXZCVzt3Q0FDQTtBQVEzQiw2RUFBNkU7QUFDN0U7QUFDQSxjQUFjO0FBQ2QsSUFBSUMsV0FBNEM7QUFFekMsU0FBU0Ysd0JBQXdCRyxNQUFzQjtJQUM1RCxJQUFJRCxhQUFhLE1BQU07UUFDckIsTUFBTSxxQkFFTCxDQUZLLElBQUlFLE1BQ1IsNEVBREk7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBQ0FGLFNBQVNDO0FBQ1g7QUFFTyxTQUFTRixlQUNkSSxXQUFpQztJQUVqQyxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR0MsT0FBQUEsT0FBSyxDQUFDQyxRQUFRLENBQWVKLFlBQVlDLEtBQUs7SUFFeEUsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSx5RUFBeUU7SUFDekUsdUVBQXVFO0lBQ3ZFLDRFQUE0RTtJQUM1RSw0RUFBNEU7SUFDNUUsZ0NBQWdDO0lBQ2hDLElBQUlJLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU1HLDRCQUNKQyx1UEFDNEI7UUFDOUIsc0RBQXNEO1FBQ3RELE1BQU1DLHlCQUF5QkY7UUFFL0JYLFdBQVcsQ0FBQ0M7WUFDVlksdUJBQXVCO2dCQUNyQlYsWUFBWUgsUUFBUSxDQUFDQyxRQUFRSTtZQUMvQjtRQUNGO0lBQ0YsT0FBTyxFQUdOO0lBRUQsT0FBT1MsQ0FBQUEsR0FBQUEsWUFBQUEsVUFBQUEsRUFBV1YsU0FBU1csQ0FBQUEsR0FBQUEsT0FBQUEsR0FBQUEsRUFBSVgsU0FBU0E7QUFDMUMiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcdXNlLWFjdGlvbi1xdWV1ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IERpc3BhdGNoIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3QsIHsgdXNlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pcy10aGVuYWJsZSdcbmltcG9ydCB0eXBlIHsgQXBwUm91dGVyQWN0aW9uUXVldWUgfSBmcm9tICcuL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgdHlwZSB7XG4gIEFwcFJvdXRlclN0YXRlLFxuICBSZWR1Y2VyQWN0aW9ucyxcbiAgUmVkdWNlclN0YXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuXG4vLyBUaGUgYXBwIHJvdXRlciBzdGF0ZSBsaXZlcyBvdXRzaWRlIG9mIFJlYWN0LCBzbyB3ZSBjYW4gaW1wb3J0IHRoZSBkaXNwYXRjaFxuLy8gbWV0aG9kIGRpcmVjdGx5IHdoZXJldmVyIHdlIG5lZWQgaXQsIHJhdGhlciB0aGFuIHBhc3NpbmcgaXQgYXJvdW5kIHZpYSBwcm9wc1xuLy8gb3IgY29udGV4dC5cbmxldCBkaXNwYXRjaDogRGlzcGF0Y2g8UmVkdWNlckFjdGlvbnM+IHwgbnVsbCA9IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKGFjdGlvbjogUmVkdWNlckFjdGlvbnMpIHtcbiAgaWYgKGRpc3BhdGNoID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludGVybmFsIE5leHQuanMgZXJyb3I6IFJvdXRlciBhY3Rpb24gZGlzcGF0Y2hlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24uJ1xuICAgIClcbiAgfVxuICBkaXNwYXRjaChhY3Rpb24pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3Rpb25RdWV1ZShcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4pOiBBcHBSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGU8UmVkdWNlclN0YXRlPihhY3Rpb25RdWV1ZS5zdGF0ZSlcblxuICAvLyBCZWNhdXNlIG9mIGEga25vd24gaXNzdWUgdGhhdCByZXF1aXJlcyB0byBkZWNvZGUgRmxpZ2h0IHN0cmVhbXMgaW5zaWRlIHRoZVxuICAvLyByZW5kZXIgcGhhc2UsIHdlIGhhdmUgdG8gYmUgYSBiaXQgY2xldmVyIGFuZCBhc3NpZ24gdGhlIGRpc3BhdGNoIG1ldGhvZCB0b1xuICAvLyBhIG1vZHVsZS1sZXZlbCB2YXJpYWJsZSB1cG9uIGluaXRpYWxpemF0aW9uLiBUaGUgdXNlU3RhdGUgaG9vayBpbiB0aGlzXG4gIC8vIG1vZHVsZSBvbmx5IGV4aXN0cyB0byBzeW5jaHJvbml6ZSBzdGF0ZSB0aGF0IGxpdmVzIG91dHNpZGUgb2YgUmVhY3QuXG4gIC8vIElkZWFsbHksIHdoYXQgd2UnZCBkbyBpbnN0ZWFkIGlzIHBhc3MgdGhlIHN0YXRlIGFzIGEgcHJvcCB0byByb290LnJlbmRlcjtcbiAgLy8gdGhpcyBpcyBjb25jZXB0dWFsbHkgaG93IHdlJ3JlIG1vZGVsaW5nIHRoZSBhcHAgcm91dGVyIHN0YXRlLCBkZXNwaXRlIHRoZVxuICAvLyB3ZWlyZCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHVzZVN5bmNEZXZSZW5kZXJJbmRpY2F0b3IgPVxuICAgICAgcmVxdWlyZSgnLi9yZWFjdC1kZXYtb3ZlcmxheS91dGlscy9kZXYtaW5kaWNhdG9yL3VzZS1zeW5jLWRldi1yZW5kZXItaW5kaWNhdG9yJylcbiAgICAgICAgLnVzZVN5bmNEZXZSZW5kZXJJbmRpY2F0b3IgYXMgdHlwZW9mIGltcG9ydCgnLi9yZWFjdC1kZXYtb3ZlcmxheS91dGlscy9kZXYtaW5kaWNhdG9yL3VzZS1zeW5jLWRldi1yZW5kZXItaW5kaWNhdG9yJykudXNlU3luY0RldlJlbmRlckluZGljYXRvclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGNvbnN0IHN5bmNEZXZSZW5kZXJJbmRpY2F0b3IgPSB1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9yKClcblxuICAgIGRpc3BhdGNoID0gKGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+IHtcbiAgICAgIHN5bmNEZXZSZW5kZXJJbmRpY2F0b3IoKCkgPT4ge1xuICAgICAgICBhY3Rpb25RdWV1ZS5kaXNwYXRjaChhY3Rpb24sIHNldFN0YXRlKVxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlzcGF0Y2ggPSAoYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucykgPT5cbiAgICAgIGFjdGlvblF1ZXVlLmRpc3BhdGNoKGFjdGlvbiwgc2V0U3RhdGUpXG4gIH1cblxuICByZXR1cm4gaXNUaGVuYWJsZShzdGF0ZSkgPyB1c2Uoc3RhdGUpIDogc3RhdGVcbn1cbiJdLCJuYW1lcyI6WyJkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiIsInVzZUFjdGlvblF1ZXVlIiwiZGlzcGF0Y2giLCJhY3Rpb24iLCJFcnJvciIsImFjdGlvblF1ZXVlIiwic3RhdGUiLCJzZXRTdGF0ZSIsIlJlYWN0IiwidXNlU3RhdGUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9yIiwicmVxdWlyZSIsInN5bmNEZXZSZW5kZXJJbmRpY2F0b3IiLCJpc1RoZW5hYmxlIiwidXNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/components/use-action-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/dev-build-indicator.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-indicator/internal/dev-build-indicator.js ***!
  \***********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"devBuildIndicator\", ({\n    enumerable: true,\n    get: function() {\n        return devBuildIndicator;\n    }\n}));\nconst _initialize = __webpack_require__(/*! ./initialize */ \"(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/initialize.js\");\nconst NOOP = ()=>{};\nconst devBuildIndicator = {\n    /** Shows build indicator when Next.js is compiling. Requires initialize() first. */ show: NOOP,\n    /** Hides build indicator when Next.js finishes compiling. Requires initialize() first. */ hide: NOOP,\n    /** Sets up the build indicator UI component. Call this before using show/hide. */ initialize: _initialize.initialize\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dev-build-indicator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZGV2LWJ1aWxkLWluZGljYXRvci9pbnRlcm5hbC9kZXYtYnVpbGQtaW5kaWNhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7cURBSWFBOzs7ZUFBQUE7Ozt3Q0FKYztBQUUzQixNQUFNQyxPQUFPLEtBQU87QUFFYixNQUFNRCxvQkFBb0I7SUFDL0Isa0ZBQWtGLEdBQ2xGRSxNQUFNRDtJQUNOLHdGQUF3RixHQUN4RkUsTUFBTUY7SUFDTixnRkFBZ0YsR0FDaEZHLFlBQUFBLFlBQUFBLFVBQVU7QUFDWiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxkZXZcXGRldi1idWlsZC1pbmRpY2F0b3JcXGludGVybmFsXFxkZXYtYnVpbGQtaW5kaWNhdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXRpYWxpemUgfSBmcm9tICcuL2luaXRpYWxpemUnXG5cbmNvbnN0IE5PT1AgPSAoKSA9PiB7fVxuXG5leHBvcnQgY29uc3QgZGV2QnVpbGRJbmRpY2F0b3IgPSB7XG4gIC8qKiBTaG93cyBidWlsZCBpbmRpY2F0b3Igd2hlbiBOZXh0LmpzIGlzIGNvbXBpbGluZy4gUmVxdWlyZXMgaW5pdGlhbGl6ZSgpIGZpcnN0LiAqL1xuICBzaG93OiBOT09QLFxuICAvKiogSGlkZXMgYnVpbGQgaW5kaWNhdG9yIHdoZW4gTmV4dC5qcyBmaW5pc2hlcyBjb21waWxpbmcuIFJlcXVpcmVzIGluaXRpYWxpemUoKSBmaXJzdC4gKi9cbiAgaGlkZTogTk9PUCxcbiAgLyoqIFNldHMgdXAgdGhlIGJ1aWxkIGluZGljYXRvciBVSSBjb21wb25lbnQuIENhbGwgdGhpcyBiZWZvcmUgdXNpbmcgc2hvdy9oaWRlLiAqL1xuICBpbml0aWFsaXplLFxufVxuIl0sIm5hbWVzIjpbImRldkJ1aWxkSW5kaWNhdG9yIiwiTk9PUCIsInNob3ciLCJoaWRlIiwiaW5pdGlhbGl6ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/dev-build-indicator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/handle-dev-build-indicator-hmr-events.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-indicator/internal/handle-dev-build-indicator-hmr-events.js ***!
  \*****************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleDevBuildIndicatorHmrEvents\", ({\n    enumerable: true,\n    get: function() {\n        return handleDevBuildIndicatorHmrEvents;\n    }\n}));\nconst _hotreloadertypes = __webpack_require__(/*! ../../../../server/dev/hot-reloader-types */ \"(ssr)/./node_modules/next/dist/server/dev/hot-reloader-types.js\");\nconst _devbuildindicator = __webpack_require__(/*! ./dev-build-indicator */ \"(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/dev-build-indicator.js\");\nconst handleDevBuildIndicatorHmrEvents = (obj)=>{\n    try {\n        if (!('action' in obj)) {\n            return;\n        }\n        // eslint-disable-next-line default-case\n        switch(obj.action){\n            case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:\n                _devbuildindicator.devBuildIndicator.show();\n                break;\n            case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:\n            case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:\n                _devbuildindicator.devBuildIndicator.hide();\n                break;\n        }\n    } catch (e) {}\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-dev-build-indicator-hmr-events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZGV2LWJ1aWxkLWluZGljYXRvci9pbnRlcm5hbC9oYW5kbGUtZGV2LWJ1aWxkLWluZGljYXRvci1obXItZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7b0VBVWFBOzs7ZUFBQUE7Ozs4Q0FQTjsrQ0FDMkI7QUFNM0IsTUFBTUEsbUNBQW1DLENBQUNDO0lBQy9DLElBQUk7UUFDRixJQUFJLENBQUUsYUFBWUEsR0FBQUEsQ0FBRSxFQUFJO1lBQ3RCO1FBQ0Y7UUFFQSx3Q0FBd0M7UUFDeEMsT0FBUUEsSUFBSUMsTUFBTTtZQUNoQixLQUFLQyxrQkFBQUEsMkJBQTJCLENBQUNDLFFBQVE7Z0JBQ3ZDQyxtQkFBQUEsaUJBQWlCLENBQUNDLElBQUk7Z0JBQ3RCO1lBQ0YsS0FBS0gsa0JBQUFBLDJCQUEyQixDQUFDSSxLQUFLO1lBQ3RDLEtBQUtKLGtCQUFBQSwyQkFBMkIsQ0FBQ0ssSUFBSTtnQkFDbkNILG1CQUFBQSxpQkFBaUIsQ0FBQ0ksSUFBSTtnQkFDdEI7UUFDSjtJQUNGLEVBQUUsVUFBTSxDQUFDO0FBQ1giLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcZGV2XFxkZXYtYnVpbGQtaW5kaWNhdG9yXFxpbnRlcm5hbFxcaGFuZGxlLWRldi1idWlsZC1pbmRpY2F0b3ItaG1yLWV2ZW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIsXG4gIHR5cGUgSE1SX0FDVElPTl9UWVBFUyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2Rldi9ob3QtcmVsb2FkZXItdHlwZXMnXG5pbXBvcnQgeyBkZXZCdWlsZEluZGljYXRvciB9IGZyb20gJy4vZGV2LWJ1aWxkLWluZGljYXRvcidcblxuLyoqXG4gKiBIYW5kbGVzIEhNUiBldmVudHMgdG8gY29udHJvbCB0aGUgZGV2IGJ1aWxkIGluZGljYXRvciB2aXNpYmlsaXR5LlxuICogU2hvd3MgaW5kaWNhdG9yIHdoZW4gYnVpbGRpbmcgYW5kIGhpZGVzIGl0IHdoZW4gYnVpbGQgY29tcGxldGVzIG9yIHN5bmNzLlxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlRGV2QnVpbGRJbmRpY2F0b3JIbXJFdmVudHMgPSAob2JqOiBITVJfQUNUSU9OX1RZUEVTKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCEoJ2FjdGlvbicgaW4gb2JqKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgIHN3aXRjaCAob2JqLmFjdGlvbikge1xuICAgICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTERJTkc6XG4gICAgICAgIGRldkJ1aWxkSW5kaWNhdG9yLnNob3coKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTFQ6XG4gICAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TWU5DOlxuICAgICAgICBkZXZCdWlsZEluZGljYXRvci5oaWRlKClcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH0gY2F0Y2gge31cbn1cbiJdLCJuYW1lcyI6WyJoYW5kbGVEZXZCdWlsZEluZGljYXRvckhtckV2ZW50cyIsIm9iaiIsImFjdGlvbiIsIkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUiIsIkJVSUxESU5HIiwiZGV2QnVpbGRJbmRpY2F0b3IiLCJzaG93IiwiQlVJTFQiLCJTWU5DIiwiaGlkZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/handle-dev-build-indicator-hmr-events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/initialize.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-indicator/internal/initialize.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*\n * Singleton store to track whether the app is currently being built\n * Used by the dev tools indicator of the new overlay to show build status\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    initialize: function() {\n        return initialize;\n    },\n    useIsDevBuilding: function() {\n        return useIsDevBuilding;\n    }\n});\nconst _devbuildindicator = __webpack_require__(/*! ./dev-build-indicator */ \"(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/dev-build-indicator.js\");\nconst _react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nlet isVisible = false;\nlet listeners = [];\nconst subscribe = (listener)=>{\n    listeners.push(listener);\n    return ()=>{\n        listeners = listeners.filter((l)=>l !== listener);\n    };\n};\nconst getSnapshot = ()=>isVisible;\nfunction useIsDevBuilding() {\n    return (0, _react.useSyncExternalStore)(subscribe, getSnapshot);\n}\nfunction initialize() {\n    _devbuildindicator.devBuildIndicator.show = ()=>{\n        isVisible = true;\n        listeners.forEach((listener)=>listener());\n    };\n    _devbuildindicator.devBuildIndicator.hide = ()=>{\n        isVisible = false;\n        listeners.forEach((listener)=>listener());\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=initialize.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZGV2LWJ1aWxkLWluZGljYXRvci9pbnRlcm5hbC9pbml0aWFsaXplLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7Ozs7Ozs7Ozs7O0lBcUJlQSxVQUFVO2VBQVZBOztJQUpBQyxnQkFBZ0I7ZUFBaEJBOzs7K0NBZmtCO21DQUNHO0FBRXJDLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsWUFBK0IsRUFBRTtBQUVyQyxNQUFNQyxZQUFZLENBQUNDO0lBQ2pCRixVQUFVRyxJQUFJLENBQUNEO0lBQ2YsT0FBTztRQUNMRixZQUFZQSxVQUFVSSxNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsTUFBTUg7SUFDNUM7QUFDRjtBQUVBLE1BQU1JLGNBQWMsSUFBTVA7QUFFbkIsU0FBU0Q7SUFDZCxPQUFPUyxDQUFBQSxHQUFBQSxPQUFBQSxvQkFBQUEsRUFBcUJOLFdBQVdLO0FBQ3pDO0FBRU8sU0FBU1Q7SUFDZFcsbUJBQUFBLGlCQUFpQixDQUFDQyxJQUFJLEdBQUc7UUFDdkJWLFlBQVk7UUFDWkMsVUFBVVUsT0FBTyxDQUFDLENBQUNSLFdBQWFBO0lBQ2xDO0lBRUFNLG1CQUFBQSxpQkFBaUIsQ0FBQ0csSUFBSSxHQUFHO1FBQ3ZCWixZQUFZO1FBQ1pDLFVBQVVVLE9BQU8sQ0FBQyxDQUFDUixXQUFhQTtJQUNsQztBQUNGIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGRldlxcZGV2LWJ1aWxkLWluZGljYXRvclxcaW50ZXJuYWxcXGluaXRpYWxpemUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFNpbmdsZXRvbiBzdG9yZSB0byB0cmFjayB3aGV0aGVyIHRoZSBhcHAgaXMgY3VycmVudGx5IGJlaW5nIGJ1aWx0XG4gKiBVc2VkIGJ5IHRoZSBkZXYgdG9vbHMgaW5kaWNhdG9yIG9mIHRoZSBuZXcgb3ZlcmxheSB0byBzaG93IGJ1aWxkIHN0YXR1c1xuICovXG5cbmltcG9ydCB7IGRldkJ1aWxkSW5kaWNhdG9yIH0gZnJvbSAnLi9kZXYtYnVpbGQtaW5kaWNhdG9yJ1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tICdyZWFjdCdcblxubGV0IGlzVmlzaWJsZSA9IGZhbHNlXG5sZXQgbGlzdGVuZXJzOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdXG5cbmNvbnN0IHN1YnNjcmliZSA9IChsaXN0ZW5lcjogKCkgPT4gdm9pZCkgPT4ge1xuICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcilcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChsKSA9PiBsICE9PSBsaXN0ZW5lcilcbiAgfVxufVxuXG5jb25zdCBnZXRTbmFwc2hvdCA9ICgpID0+IGlzVmlzaWJsZVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSXNEZXZCdWlsZGluZygpIHtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICBkZXZCdWlsZEluZGljYXRvci5zaG93ID0gKCkgPT4ge1xuICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpXG4gIH1cblxuICBkZXZCdWlsZEluZGljYXRvci5oaWRlID0gKCkgPT4ge1xuICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKVxuICB9XG59XG4iXSwibmFtZXMiOlsiaW5pdGlhbGl6ZSIsInVzZUlzRGV2QnVpbGRpbmciLCJpc1Zpc2libGUiLCJsaXN0ZW5lcnMiLCJzdWJzY3JpYmUiLCJsaXN0ZW5lciIsInB1c2giLCJmaWx0ZXIiLCJsIiwiZ2V0U25hcHNob3QiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImRldkJ1aWxkSW5kaWNhdG9yIiwic2hvdyIsImZvckVhY2giLCJoaWRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/dev/dev-build-indicator/internal/initialize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/client/flight-data-helpers.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/flight-data-helpers.js ***!
  \**************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getFlightDataPartsFromPath: function() {\n        return getFlightDataPartsFromPath;\n    },\n    getNextFlightSegmentPath: function() {\n        return getNextFlightSegmentPath;\n    },\n    normalizeFlightData: function() {\n        return normalizeFlightData;\n    }\n});\nfunction getFlightDataPartsFromPath(flightDataPath) {\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n    const flightDataPathLength = 4;\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\n    var _segmentPath_;\n    return {\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\n        pathToSegment: segmentPath.slice(0, -1),\n        segmentPath,\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n        // in which case we default to ''.\n        segment: (_segmentPath_ = segmentPath[segmentPath.length - 1]) != null ? _segmentPath_ : '',\n        tree,\n        seedData,\n        head,\n        isHeadPartial,\n        isRootRender: flightDataPath.length === flightDataPathLength\n    };\n}\nfunction getNextFlightSegmentPath(flightSegmentPath) {\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n    // to get the next segment path.\n    return flightSegmentPath.slice(2);\n}\nfunction normalizeFlightData(flightData) {\n    // FlightData can be a string when the server didn't respond with a proper flight response,\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n    if (typeof flightData === 'string') {\n        return flightData;\n    }\n    return flightData.map(getFlightDataPartsFromPath);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=flight-data-helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9mbGlnaHQtZGF0YS1oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQStCZ0JBLDBCQUEwQjtlQUExQkE7O0lBNEJBQyx3QkFBd0I7ZUFBeEJBOztJQVFBQyxtQkFBbUI7ZUFBbkJBOzs7QUFwQ1QsU0FBU0YsMkJBQ2RHLGNBQThCO0lBRTlCLHdHQUF3RztJQUN4RyxNQUFNQyx1QkFBdUI7SUFDN0Isc0ZBQXNGO0lBQ3RGLE1BQU0sQ0FBQ0MsTUFBTUMsVUFBVUMsTUFBTUMsY0FBYyxHQUN6Q0wsZUFBZU0sS0FBSyxDQUFDLENBQUNMO0lBQ3hCLDZHQUE2RztJQUM3RyxNQUFNTSxjQUFjUCxlQUFlTSxLQUFLLENBQUMsR0FBRyxDQUFDTDtRQVVsQ007SUFSWCxPQUFPO1FBQ0wsa0dBQWtHO1FBQ2xHLHNHQUFzRztRQUN0RyxxREFBcUQ7UUFDckRDLGVBQWVELFlBQVlELEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDckNDO1FBQ0Esa0ZBQWtGO1FBQ2xGLGtDQUFrQztRQUNsQ0UsU0FBU0YsQ0FBQUEsZ0JBQUFBLFdBQVcsQ0FBQ0EsWUFBWUcsTUFBTSxHQUFHLE9BQUUsT0FBbkNILGdCQUF1QztRQUNoREw7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQU0sY0FBY1gsZUFBZVUsTUFBTSxLQUFLVDtJQUMxQztBQUNGO0FBRU8sU0FBU0gseUJBQ2RjLGlCQUFvQztJQUVwQyw0R0FBNEc7SUFDNUcsZ0NBQWdDO0lBQ2hDLE9BQU9BLGtCQUFrQk4sS0FBSyxDQUFDO0FBQ2pDO0FBRU8sU0FBU1Asb0JBQ2RjLFVBQXNCO0lBRXRCLDJGQUEyRjtJQUMzRixrR0FBa0c7SUFDbEcsSUFBSSxPQUFPQSxlQUFlLFVBQVU7UUFDbEMsT0FBT0E7SUFDVDtJQUVBLE9BQU9BLFdBQVdDLEdBQUcsQ0FBQ2pCO0FBQ3hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxmbGlnaHQtZGF0YS1oZWxwZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgQ2FjaGVOb2RlU2VlZERhdGEsXG4gIEZsaWdodERhdGEsXG4gIEZsaWdodERhdGFQYXRoLFxuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0U2VnbWVudFBhdGgsXG4gIFNlZ21lbnQsXG59IGZyb20gJy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBIZWFkRGF0YSB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG5leHBvcnQgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSA9IHtcbiAgLyoqXG4gICAqIFRoZSBmdWxsIGBGbGlnaHRTZWdtZW50UGF0aGAgaW5jbHVzaXZlIG9mIHRoZSBmaW5hbCBgU2VnbWVudGBcbiAgICovXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxuICAvKipcbiAgICogVGhlIGBGbGlnaHRTZWdtZW50UGF0aGAgZXhjbHVzaXZlIG9mIHRoZSBmaW5hbCBgU2VnbWVudGBcbiAgICovXG4gIHBhdGhUb1NlZ21lbnQ6IEZsaWdodFNlZ21lbnRQYXRoXG4gIHNlZ21lbnQ6IFNlZ21lbnRcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgc2VlZERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbFxuICBoZWFkOiBIZWFkRGF0YVxuICBpc0hlYWRQYXJ0aWFsOiBib29sZWFuXG4gIGlzUm9vdFJlbmRlcjogYm9vbGVhblxufVxuXG4vLyBUT0RPOiBXZSBzaG91bGQgb25seSBoYXZlIHRvIGV4cG9ydCBgbm9ybWFsaXplRmxpZ2h0RGF0YWAsIGhvd2V2ZXIgYmVjYXVzZSB0aGUgaW5pdGlhbCBmbGlnaHQgZGF0YVxuLy8gdGhhdCBnZXRzIHBhc3NlZCB0byBgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlYCBkb2Vzbid0IGNvbmZvcm0gdG8gdGhlIGBGbGlnaHREYXRhUGF0aGAgdHlwZSAoaXQncyBtaXNzaW5nIHRoZSByb290IHNlZ21lbnQpXG4vLyB3ZSdyZSBjdXJyZW50bHkgZXhwb3J0aW5nIGl0IHNvIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHkuIFRoaXMgc2hvdWxkIGJlIGZpeGVkIGFzIHBhcnQgb2YgdGhlIHVuaWZpY2F0aW9uIG9mXG4vLyB0aGUgZGlmZmVyZW50IHdheXMgd2UgZXhwcmVzcyBgRmxpZ2h0U2VnbWVudFBhdGhgLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoKFxuICBmbGlnaHREYXRhUGF0aDogRmxpZ2h0RGF0YVBhdGhcbik6IE5vcm1hbGl6ZWRGbGlnaHREYXRhIHtcbiAgLy8gUGljayB0aGUgbGFzdCA0IGl0ZW1zIGZyb20gdGhlIGBGbGlnaHREYXRhUGF0aGAgdG8gZ2V0IHRoZSBbdHJlZSwgc2VlZERhdGEsIHZpZXdwb3J0LCBpc0hlYWRQYXJ0aWFsXS5cbiAgY29uc3QgZmxpZ2h0RGF0YVBhdGhMZW5ndGggPSA0XG4gIC8vIHRyZWUsIHNlZWREYXRhLCBhbmQgaGVhZCBhcmUgKmFsd2F5cyogdGhlIGxhc3QgdGhyZWUgaXRlbXMgaW4gdGhlIGBGbGlnaHREYXRhUGF0aGAuXG4gIGNvbnN0IFt0cmVlLCBzZWVkRGF0YSwgaGVhZCwgaXNIZWFkUGFydGlhbF0gPVxuICAgIGZsaWdodERhdGFQYXRoLnNsaWNlKC1mbGlnaHREYXRhUGF0aExlbmd0aClcbiAgLy8gVGhlIGBGbGlnaHRTZWdtZW50UGF0aGAgaXMgZXZlcnl0aGluZyBleGNlcHQgdGhlIGxhc3QgdGhyZWUgaXRlbXMuIEZvciBhIHJvb3QgcmVuZGVyLCBpdCB3b24ndCBiZSBwcmVzZW50LlxuICBjb25zdCBzZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC1mbGlnaHREYXRhUGF0aExlbmd0aClcblxuICByZXR1cm4ge1xuICAgIC8vIFRPRE86IFVuaWZ5IHRoZXNlIHR3byBzZWdtZW50IHBhdGggaGVscGVycy4gV2UgYXJlIGluY29uc2lzdGVudGx5IHB1c2hpbmcgYW4gZW1wdHkgc2VnbWVudCAoXCJcIilcbiAgICAvLyB0byB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnQgcGF0aCBpbiBzb21lIHBsYWNlcyB3aGljaCBtYWtlcyBpdCBoYXJkIHRvIHVzZSBzb2xlbHkgdGhlIHNlZ21lbnQgcGF0aC5cbiAgICAvLyBMb29rIGZvciBcIi8vIFRPRE8tQVBQOiByZW1vdmUgJydcIiBpbiB0aGUgY29kZWJhc2UuXG4gICAgcGF0aFRvU2VnbWVudDogc2VnbWVudFBhdGguc2xpY2UoMCwgLTEpLFxuICAgIHNlZ21lbnRQYXRoLFxuICAgIC8vIGlmIHRoZSBgRmxpZ2h0RGF0YVBhdGhgIGNvcnJlc3BvbmRzIHdpdGggdGhlIHJvb3QsIHRoZXJlJ2xsIGJlIG5vIHNlZ21lbnQgcGF0aCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gJycuXG4gICAgc2VnbWVudDogc2VnbWVudFBhdGhbc2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gPz8gJycsXG4gICAgdHJlZSxcbiAgICBzZWVkRGF0YSxcbiAgICBoZWFkLFxuICAgIGlzSGVhZFBhcnRpYWwsXG4gICAgaXNSb290UmVuZGVyOiBmbGlnaHREYXRhUGF0aC5sZW5ndGggPT09IGZsaWdodERhdGFQYXRoTGVuZ3RoLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxuKTogRmxpZ2h0U2VnbWVudFBhdGgge1xuICAvLyBTaW5jZSBgRmxpZ2h0U2VnbWVudFBhdGhgIGlzIGEgcmVwZWF0ZWQgdHVwbGUgb2YgYFNlZ21lbnRgIGFuZCBgUGFyYWxsZWxSb3V0ZUtleWAsIHdlIHNsaWNlIG9mZiB0d28gaXRlbXNcbiAgLy8gdG8gZ2V0IHRoZSBuZXh0IHNlZ21lbnQgcGF0aC5cbiAgcmV0dXJuIGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGbGlnaHREYXRhKFxuICBmbGlnaHREYXRhOiBGbGlnaHREYXRhXG4pOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nIHtcbiAgLy8gRmxpZ2h0RGF0YSBjYW4gYmUgYSBzdHJpbmcgd2hlbiB0aGUgc2VydmVyIGRpZG4ndCByZXNwb25kIHdpdGggYSBwcm9wZXIgZmxpZ2h0IHJlc3BvbnNlLFxuICAvLyBvciB3aGVuIGEgcmVkaXJlY3QgaGFwcGVucywgdG8gc2lnbmFsIHRvIHRoZSBjbGllbnQgdGhhdCBpdCBuZWVkcyB0byBwZXJmb3JtIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZsaWdodERhdGFcbiAgfVxuXG4gIHJldHVybiBmbGlnaHREYXRhLm1hcChnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aClcbn1cbiJdLCJuYW1lcyI6WyJnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmbGlnaHREYXRhUGF0aCIsImZsaWdodERhdGFQYXRoTGVuZ3RoIiwidHJlZSIsInNlZWREYXRhIiwiaGVhZCIsImlzSGVhZFBhcnRpYWwiLCJzbGljZSIsInNlZ21lbnRQYXRoIiwicGF0aFRvU2VnbWVudCIsInNlZ21lbnQiLCJsZW5ndGgiLCJpc1Jvb3RSZW5kZXIiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZsaWdodERhdGEiLCJtYXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/client/flight-data-helpers.js\n");

/***/ })

};
;